From: Gabriel Valcazar <gabriel.valcazar@digi.com>
Date: Mon, 19 Feb 2018 10:48:50 +0100
Subject: [PATCH 2/2] Remove unused HAL implementations

When building the library, all HAL implementations get compiled, leading to
failures due to missing Windows header files. The official README states that
only the necessary HAL implementations should be included in a project, so keep
the Linux userpace I2C HAL and remove everything else.

https://jira.digi.com/browse/DEL-5591

Signed-off-by: Gabriel Valcazar <gabriel.valcazar@digi.com>
---
 lib/hal/hal_at90usb1287_i2c_asf.c   | 520 ----------------------------
 lib/hal/hal_at90usb1287_i2c_asf.h   |  64 ----
 lib/hal/hal_at90usb1287_timer_asf.c |  79 -----
 lib/hal/hal_i2c_bitbang.c           | 518 ----------------------------
 lib/hal/hal_i2c_bitbang.h           |  78 -----
 lib/hal/hal_linux_kit_cdc.c         | 428 -----------------------
 lib/hal/hal_linux_kit_cdc.h         |  67 ----
 lib/hal/hal_linux_kit_hid.c         | 429 -----------------------
 lib/hal/hal_linux_kit_hid.h         |  62 ----
 lib/hal/hal_pic32mx695f512h_i2c.c   | 510 ---------------------------
 lib/hal/hal_pic32mx695f512h_i2c.h   |  74 ----
 lib/hal/hal_pic32mx695f512h_timer.c | 106 ------
 lib/hal/hal_sam4s_i2c_asf.c         | 667 ------------------------------------
 lib/hal/hal_sam4s_i2c_asf.h         |  67 ----
 lib/hal/hal_sam4s_timer_asf.c       |  86 -----
 lib/hal/hal_samb11_i2c_asf.c        | 485 --------------------------
 lib/hal/hal_samb11_i2c_asf.h        |  60 ----
 lib/hal/hal_samb11_timer_asf.c      |  78 -----
 lib/hal/hal_samd21_i2c_asf.c        | 572 -------------------------------
 lib/hal/hal_samd21_i2c_asf.h        |  63 ----
 lib/hal/hal_samd21_i2c_start.c      | 545 -----------------------------
 lib/hal/hal_samd21_i2c_start.h      |  64 ----
 lib/hal/hal_samd21_timer_asf.c      |  79 -----
 lib/hal/hal_samd21_timer_start.c    |  80 -----
 lib/hal/hal_samg55_i2c_asf.c        | 661 -----------------------------------
 lib/hal/hal_samg55_i2c_asf.h        |  67 ----
 lib/hal/hal_samg55_timer_asf.c      |  86 -----
 lib/hal/hal_samv71_i2c_asf.c        | 583 -------------------------------
 lib/hal/hal_samv71_i2c_asf.h        |  63 ----
 lib/hal/hal_samv71_timer_asf.c      |  79 -----
 lib/hal/hal_swi_bitbang.c           | 347 -------------------
 lib/hal/hal_swi_bitbang.h           |  76 ----
 lib/hal/hal_swi_uart.c              | 527 ----------------------------
 lib/hal/hal_swi_uart.h              |  62 ----
 lib/hal/hal_win_kit_cdc.c           | 556 ------------------------------
 lib/hal/hal_win_kit_cdc.h           |  58 ----
 lib/hal/hal_win_kit_hid.c           | 469 -------------------------
 lib/hal/hal_win_kit_hid.h           |  64 ----
 lib/hal/hal_win_timer.c             |  86 -----
 lib/hal/hal_xmega_a3bu_i2c_asf.c    | 520 ----------------------------
 lib/hal/hal_xmega_a3bu_i2c_asf.h    |  64 ----
 lib/hal/hal_xmega_a3bu_timer_asf.c  |  78 -----
 lib/hal/i2c_bitbang_samd21.c        | 262 --------------
 lib/hal/i2c_bitbang_samd21.h        | 195 -----------
 lib/hal/kit_phy.h                   |  62 ----
 lib/hal/kit_protocol.c              | 430 -----------------------
 lib/hal/kit_protocol.h              |  77 -----
 lib/hal/swi_bitbang_samd21.c        | 272 ---------------
 lib/hal/swi_bitbang_samd21.h        | 148 --------
 lib/hal/swi_uart_at90usb1287_asf.c  | 260 --------------
 lib/hal/swi_uart_at90usb1287_asf.h  |  83 -----
 lib/hal/swi_uart_samd21_asf.c       | 238 -------------
 lib/hal/swi_uart_samd21_asf.h       |  84 -----
 lib/hal/swi_uart_samd21_start.c     | 208 -----------
 lib/hal/swi_uart_samd21_start.h     |  80 -----
 lib/hal/swi_uart_xmega_a3bu_asf.c   | 258 --------------
 lib/hal/swi_uart_xmega_a3bu_asf.h   |  83 -----
 57 files changed, 12967 deletions(-)
 delete mode 100644 lib/hal/hal_at90usb1287_i2c_asf.c
 delete mode 100644 lib/hal/hal_at90usb1287_i2c_asf.h
 delete mode 100644 lib/hal/hal_at90usb1287_timer_asf.c
 delete mode 100644 lib/hal/hal_i2c_bitbang.c
 delete mode 100644 lib/hal/hal_i2c_bitbang.h
 delete mode 100644 lib/hal/hal_linux_kit_cdc.c
 delete mode 100644 lib/hal/hal_linux_kit_cdc.h
 delete mode 100644 lib/hal/hal_linux_kit_hid.c
 delete mode 100644 lib/hal/hal_linux_kit_hid.h
 delete mode 100644 lib/hal/hal_pic32mx695f512h_i2c.c
 delete mode 100644 lib/hal/hal_pic32mx695f512h_i2c.h
 delete mode 100644 lib/hal/hal_pic32mx695f512h_timer.c
 delete mode 100644 lib/hal/hal_sam4s_i2c_asf.c
 delete mode 100644 lib/hal/hal_sam4s_i2c_asf.h
 delete mode 100644 lib/hal/hal_sam4s_timer_asf.c
 delete mode 100644 lib/hal/hal_samb11_i2c_asf.c
 delete mode 100644 lib/hal/hal_samb11_i2c_asf.h
 delete mode 100644 lib/hal/hal_samb11_timer_asf.c
 delete mode 100644 lib/hal/hal_samd21_i2c_asf.c
 delete mode 100644 lib/hal/hal_samd21_i2c_asf.h
 delete mode 100644 lib/hal/hal_samd21_i2c_start.c
 delete mode 100644 lib/hal/hal_samd21_i2c_start.h
 delete mode 100644 lib/hal/hal_samd21_timer_asf.c
 delete mode 100644 lib/hal/hal_samd21_timer_start.c
 delete mode 100644 lib/hal/hal_samg55_i2c_asf.c
 delete mode 100644 lib/hal/hal_samg55_i2c_asf.h
 delete mode 100644 lib/hal/hal_samg55_timer_asf.c
 delete mode 100644 lib/hal/hal_samv71_i2c_asf.c
 delete mode 100644 lib/hal/hal_samv71_i2c_asf.h
 delete mode 100644 lib/hal/hal_samv71_timer_asf.c
 delete mode 100644 lib/hal/hal_swi_bitbang.c
 delete mode 100644 lib/hal/hal_swi_bitbang.h
 delete mode 100644 lib/hal/hal_swi_uart.c
 delete mode 100644 lib/hal/hal_swi_uart.h
 delete mode 100644 lib/hal/hal_win_kit_cdc.c
 delete mode 100644 lib/hal/hal_win_kit_cdc.h
 delete mode 100644 lib/hal/hal_win_kit_hid.c
 delete mode 100644 lib/hal/hal_win_kit_hid.h
 delete mode 100644 lib/hal/hal_win_timer.c
 delete mode 100644 lib/hal/hal_xmega_a3bu_i2c_asf.c
 delete mode 100644 lib/hal/hal_xmega_a3bu_i2c_asf.h
 delete mode 100644 lib/hal/hal_xmega_a3bu_timer_asf.c
 delete mode 100644 lib/hal/i2c_bitbang_samd21.c
 delete mode 100644 lib/hal/i2c_bitbang_samd21.h
 delete mode 100644 lib/hal/kit_phy.h
 delete mode 100644 lib/hal/kit_protocol.c
 delete mode 100644 lib/hal/kit_protocol.h
 delete mode 100644 lib/hal/swi_bitbang_samd21.c
 delete mode 100644 lib/hal/swi_bitbang_samd21.h
 delete mode 100644 lib/hal/swi_uart_at90usb1287_asf.c
 delete mode 100644 lib/hal/swi_uart_at90usb1287_asf.h
 delete mode 100644 lib/hal/swi_uart_samd21_asf.c
 delete mode 100644 lib/hal/swi_uart_samd21_asf.h
 delete mode 100644 lib/hal/swi_uart_samd21_start.c
 delete mode 100644 lib/hal/swi_uart_samd21_start.h
 delete mode 100644 lib/hal/swi_uart_xmega_a3bu_asf.c
 delete mode 100644 lib/hal/swi_uart_xmega_a3bu_asf.h

diff --git a/lib/hal/hal_at90usb1287_i2c_asf.c b/lib/hal/hal_at90usb1287_i2c_asf.c
deleted file mode 100644
index 878d82e48470..000000000000
--- a/lib/hal/hal_at90usb1287_i2c_asf.c
+++ /dev/null
@@ -1,520 +0,0 @@
-/**
- * \file
- * \brief ATCA Hardware abstraction layer for AT90USB1287 I2C over ASF drivers.
- *
- * Prerequisite: Add I2C Master Polled/Interrupt support to application in Atmel Studio
- *  this HAL implementation assumes you've included the ASF I2C libraries in your project, otherwise,
- *  the HAL layer will not compile because the ASF I2C drivers are a dependency
- *
- * \copyright (c) 2017 Microchip Technology Inc. and its subsidiaries.
- *            You may use this software and any derivatives exclusively with
- *            Microchip products.
- *
- * \page License
- *
- * (c) 2017 Microchip Technology Inc. and its subsidiaries. You may use this
- * software and any derivatives exclusively with Microchip products.
- *
- * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
- * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
- * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
- * PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
- * WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
- *
- * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
- * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
- * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
- * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
- * FULLEST EXTENT ALLOWED BY LAW, MICROCHIPS TOTAL LIABILITY ON ALL CLAIMS IN
- * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
- * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
- *
- * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
- * TERMS.
- */
-
-#include <asf.h>
-#include <string.h>
-#include <stdio.h>
-#include "atca_hal.h"
-#include "hal_at90usb1287_i2c_asf.h"
-#include "atca_device.h"
-
-/** \defgroup hal_ Hardware abstraction layer (hal_)
- *
- * \brief
- * These methods define the hardware abstraction layer for communicating with a CryptoAuth device
- * using I2C driver of ASF.
- *
-   @{ */
-
-/** \brief logical to physical bus mapping structure */
-ATCAI2CMaster_t *i2c_hal_data[MAX_I2C_BUSES];   // map logical, 0-based bus number to index
-int i2c_bus_ref_ct = 0;                         // total in-use count across buses
-static twi_master_options_t config_i2c_master;
-
-
-/** \brief discover i2c buses available for this hardware
- * this maintains a list of logical to physical bus mappings freeing the application
- * of the prior knowledge
- * \param[in] i2c_buses - an array of logical bus numbers
- * \param[in] max_buses - maximum number of buses the app wants to attempt to discover
- * \return ATCA_SUCCESS
- */
-
-ATCA_STATUS hal_i2c_discover_buses(int i2c_buses[], int max_buses)
-{
-
-    // if every PORT was a likely candidate bus, then would need to initialize the entire array to all PORT n numbers.
-    //  As an optimization and making discovery safer, make assumptions about bus-num / PORT map based on AT90USB1287
-    //  If you were using a raw XMEGA on your own board, you would supply your own bus numbers based on your particular hardware configuration.
-    //
-
-    i2c_buses[0] = 0; /* AT90USB1287 has only one I2C Port */
-
-    return ATCA_SUCCESS;
-}
-
-/** \brief discover any CryptoAuth devices on a given logical bus number
- * \param[in] busNum - logical bus number on which to look for CryptoAuth devices
- * \param[out] cfg[] - pointer to head of an array of interface config structures which get filled in by this method
- * \param[out] *found - number of devices found on this bus
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-
-ATCA_STATUS hal_i2c_discover_devices(int busNum, ATCAIfaceCfg cfg[], int *found)
-{
-    ATCAIfaceCfg *head = cfg;
-    uint8_t slaveAddress = 0x01;
-    ATCADevice device;
-    ATCAIface discoverIface;
-    ATCACommand command;
-    ATCAPacket packet;
-    ATCA_STATUS status;
-    uint8_t revs508[1][4] = { { 0x00, 0x00, 0x50, 0x00 } };
-    uint8_t revs108[1][4] = { { 0x80, 0x00, 0x10, 0x01 } };
-    uint8_t revs204[3][4] = { { 0x00, 0x02, 0x00, 0x08 },
-                              { 0x00, 0x02, 0x00, 0x09 },
-                              { 0x00, 0x04, 0x05, 0x00 } };
-    int i;
-
-    /**  default configuration, to be reused during discovery process */
-    ATCAIfaceCfg discoverCfg = {
-        .iface_type             = ATCA_I2C_IFACE,
-        .devtype                = ATECC508A,
-        .atcai2c.slave_address  = 0x07,
-        .atcai2c.bus            = busNum,
-        .atcai2c.baud           = 400000,
-        .wake_delay             = 800,
-        .rx_retries             = 3
-    };
-
-    // build an info command
-    packet.param1 = INFO_MODE_REVISION;
-    packet.param2 = 0;
-
-    device = newATCADevice(&discoverCfg);
-    discoverIface = atGetIFace(device);
-    command = atGetCommands(device);
-
-    // iterate through all addresses on given i2c bus
-    // all valid 7-bit addresses go from 0x07 to 0x78
-    for (slaveAddress = 0x08; slaveAddress <= 0x77; slaveAddress++)
-    {
-        discoverCfg.atcai2c.slave_address = slaveAddress << 1;  // turn it into an 8-bit address which is what the rest of the i2c HAL is expecting when a packet is sent
-
-        // wake up device
-        // If it wakes, send it a dev rev command.  Based on that response, determine the device type
-        // BTW - this will wake every cryptoauth device living on the same bus (ecc508a, sha204a)
-
-        if (hal_i2c_wake(discoverIface) == ATCA_SUCCESS)
-        {
-            (*found)++;
-            memcpy( (uint8_t*)head, (uint8_t*)&discoverCfg, sizeof(ATCAIfaceCfg));
-
-            memset(packet.data, 0x00, sizeof(packet.data));
-
-            // get devrev info and set device type accordingly
-            atInfo(command, &packet);
-            if ((status = atGetExecTime(packet.opcode, command)) != ATCA_SUCCESS)
-            {
-                continue;
-            }
-
-            // send the command
-            if ( (status = atsend(discoverIface, (uint8_t*)&packet, packet.txsize)) != ATCA_SUCCESS)
-            {
-                printf("packet send error\r\n");
-                continue;
-            }
-
-            // delay the appropriate amount of time for command to execute
-            atca_delay_ms((command->execution_time_msec) + 1);
-
-            // receive the response
-            if ( (status = atreceive(discoverIface, &(packet.data[0]), &(packet.rxsize) )) != ATCA_SUCCESS)
-            {
-                continue;
-            }
-
-            if ( (status = isATCAError(packet.data)) != ATCA_SUCCESS)
-            {
-                printf("command response error\r\n");
-                continue;
-            }
-
-            // determine device type from common info and dev rev response byte strings
-            for (i = 0; i < sizeof(revs508) / 4; i++)
-            {
-                if (memcmp(&packet.data[1], &revs508[i], 4) == 0)
-                {
-                    discoverCfg.devtype = ATECC508A;
-                    break;
-                }
-            }
-
-            for (i = 0; i < sizeof(revs204) / 4; i++)
-            {
-                if (memcmp(&packet.data[1], &revs204[i], 4) == 0)
-                {
-                    discoverCfg.devtype = ATSHA204A;
-                    break;
-                }
-            }
-
-            for (i = 0; i < sizeof(revs108) / 4; i++)
-            {
-                if (memcmp(&packet.data[1], &revs108[i], 4) == 0)
-                {
-                    discoverCfg.devtype = ATECC108A;
-                    break;
-                }
-            }
-
-            atca_delay_ms(15);
-            // now the device type is known, so update the caller's cfg array element with it
-            head->devtype = discoverCfg.devtype;
-            head++;
-        }
-
-        hal_i2c_idle(discoverIface);
-    }
-
-    deleteATCADevice(&device);
-
-    return ATCA_SUCCESS;
-}
-
-
-
-
-/** \brief hal_i2c_init manages requests to initialize a physical interface.  it manages use counts so when an interface
- * has released the physical layer, it will disable the interface for some other use.
- * You can have multiple ATCAIFace instances using the same bus, and you can have multiple ATCAIFace instances on
- * multiple i2c buses, so hal_i2c_init manages these things and ATCAIFace is abstracted from the physical details.
- */
-
-/** \brief initialize an I2C interface using given config
- * \param[in] hal - opaque ptr to HAL data
- * \param[in] cfg - pointer to interface configuration
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-ATCA_STATUS hal_i2c_init(void *hal, ATCAIfaceCfg *cfg)
-{
-    int bus = cfg->atcai2c.bus;  // 0-based logical bus number
-    ATCAHAL_t *phal = (ATCAHAL_t*)hal;
-
-    if (i2c_bus_ref_ct == 0)       // power up state, no i2c buses will have been used
-    {
-        for (int i = 0; i < MAX_I2C_BUSES; i++)
-        {
-            i2c_hal_data[i] = NULL;
-        }
-    }
-
-    i2c_bus_ref_ct++;  // total across buses
-
-    if (bus >= 0 && bus < MAX_I2C_BUSES)
-    {
-        // if this is the first time this bus and interface has been created, do the physical work of enabling it
-        if (i2c_hal_data[bus] == NULL)
-        {
-            i2c_hal_data[bus] = malloc(sizeof(ATCAI2CMaster_t) );
-            i2c_hal_data[bus]->ref_ct = 1;  // buses are shared, this is the first instance
-
-            config_i2c_master.speed = cfg->atcai2c.baud;
-            config_i2c_master.chip  = 0x50;
-            config_i2c_master.baud_reg = TWI_CLOCK_RATE(sysclk_get_cpu_hz(), cfg->atcai2c.baud);
-
-            i2c_hal_data[bus]->i2c_master_instance = (int*)&TWBR;
-
-            sysclk_enable_peripheral_clock((i2c_hal_data[bus]->i2c_master_instance));
-            twi_master_init((i2c_hal_data[bus]->i2c_master_instance), &config_i2c_master);
-
-            // store this for use during the release phase
-            i2c_hal_data[bus]->bus_index = bus;
-        }
-        else
-        {
-            // otherwise, another interface already initialized the bus, so this interface will share it and any different
-            // cfg parameters will be ignored...first one to initialize this sets the configuration
-            i2c_hal_data[bus]->ref_ct++;
-        }
-
-        phal->hal_data = i2c_hal_data[bus];
-
-        return ATCA_SUCCESS;
-    }
-
-    return ATCA_COMM_FAIL;
-}
-
-/** \brief HAL implementation of I2C post init
- * \param[in] iface  instance
- * \return ATCA_STATUS
- */
-ATCA_STATUS hal_i2c_post_init(ATCAIface iface)
-{
-    return ATCA_SUCCESS;
-}
-
-/** \brief HAL implementation of I2C send over ASF
- * \param[in] iface     instance
- * \param[in] txdata    pointer to space to bytes to send
- * \param[in] txlength  number of bytes to send
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-
-ATCA_STATUS hal_i2c_send(ATCAIface iface, uint8_t *txdata, int txlength)
-{
-    ATCAIfaceCfg *cfg = atgetifacecfg(iface);
-    int bus = cfg->atcai2c.bus;
-
-    twi_package_t packet = {
-        .addr_length    = 0,                                // TWI slave memory address data size
-        .chip           = cfg->atcai2c.slave_address,       // TWI slave bus address
-        .buffer         = txdata,                           // transfer data source buffer
-        .length         = txlength,                         // transfer data size (bytes)
-    };
-
-    // for this implementation of I2C with CryptoAuth chips, txdata is assumed to have ATCAPacket format
-
-    // other device types that don't require i/o tokens on the front end of a command need a different hal_i2c_send and wire it up instead of this one
-    // this covers devices such as ATSHA204A and ATECCx08A that require a word address value pre-pended to the packet
-    // txdata[0] is using _reserved byte of the ATCAPacket
-    txdata[0] = 0x03;   // insert the Word Address Value, Command token
-    txlength++;         // account for word address value byte.
-    packet.length = txlength;
-
-    if (twi_master_write(i2c_hal_data[bus]->i2c_master_instance, &packet) != STATUS_OK)
-    {
-        return ATCA_COMM_FAIL;
-    }
-
-    return ATCA_SUCCESS;
-}
-
-/** \brief HAL implementation of I2C receive function for ASF I2C
- * \param[in] iface     instance
- * \param[in] rxdata    pointer to space to receive the data
- * \param[in] rxlength  ptr to expected number of receive bytes to request
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-
-ATCA_STATUS hal_i2c_receive(ATCAIface iface, uint8_t *rxdata, uint16_t *rxlength)
-{
-    ATCAIfaceCfg *cfg = atgetifacecfg(iface);
-    int bus = cfg->atcai2c.bus;
-    int retries = cfg->rx_retries;
-    int status = !STATUS_OK;
-
-    twi_package_t packet = {
-        .addr_length    = 0,                                // TWI slave memory address data size
-        .chip           = cfg->atcai2c.slave_address,       // TWI slave bus address
-        .buffer         = rxdata,                           // transfer data source buffer
-        .length         = *rxlength,                        // transfer data size (bytes)
-    };
-
-    while (retries-- > 0 && status != STATUS_OK)
-    {
-        status = twi_master_read(i2c_hal_data[bus]->i2c_master_instance, &packet);
-    }
-
-    if (status != STATUS_OK)
-    {
-        return ATCA_COMM_FAIL;
-    }
-
-    return ATCA_SUCCESS;
-}
-
-/** \brief method to change the bus speed of I2C
- * \param[in] iface  interface on which to change bus speed
- * \param[in] speed  baud rate (typically 100000 or 400000)
- */
-
-void change_i2c_speed(ATCAIface iface, uint32_t speed)
-{
-    ATCAIfaceCfg *cfg = atgetifacecfg(iface);
-    int bus = cfg->atcai2c.bus;
-
-    config_i2c_master.speed = speed;
-    config_i2c_master.baud_reg = TWI_CLOCK_RATE(sysclk_get_cpu_hz(), speed);
-
-    /*twi_reset();*/
-
-    twi_master_init((i2c_hal_data[bus]->i2c_master_instance), &config_i2c_master);
-}
-
-/** \brief wake up CryptoAuth device using I2C bus
- * \param[in] iface  interface to logical device to wakeup
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-
-ATCA_STATUS hal_i2c_wake(ATCAIface iface)
-{
-    ATCAIfaceCfg *cfg = atgetifacecfg(iface);
-    int bus = cfg->atcai2c.bus;
-    int retries = cfg->rx_retries;
-    uint32_t bdrt = cfg->atcai2c.baud;
-    int status = !STATUS_OK;
-    uint8_t data[4], expected[4] = { 0x04, 0x11, 0x33, 0x43 };
-
-    if (bdrt != 100000)    // if not already at 100KHz, change it
-    {
-        change_i2c_speed(iface, 100000);
-    }
-
-    // Send the wake by writing to an address of 0x00
-    twi_package_t packet = {
-        .addr_length    = 0,        // TWI slave memory address data size
-        .chip           = 0x00,     // TWI slave bus address
-        .buffer         = &data[0], // transfer data source buffer
-        .length         = 0         // transfer data size (bytes)
-    };
-
-
-    // Send the 00 address as the wake pulse
-    twi_master_write(i2c_hal_data[bus]->i2c_master_instance, &packet);  // part will NACK, so don't check for status
-
-    atca_delay_us(cfg->wake_delay);                                     // wait tWHI + tWLO which is configured based on device type and configuration structure
-
-    packet.chip = cfg->atcai2c.slave_address;
-    packet.length = 4;
-    packet.buffer = data;
-
-    while (retries-- > 0 && status != STATUS_OK)
-    {
-        status = twi_master_read(i2c_hal_data[bus]->i2c_master_instance, &packet);
-    }
-
-    if (status != STATUS_OK)
-    {
-        return ATCA_COMM_FAIL;
-    }
-
-    // if necessary, revert baud rate to what came in.
-    if (bdrt != 100000)
-    {
-        change_i2c_speed(iface, bdrt);
-    }
-
-    if (memcmp(data, expected, 4) == 0)
-    {
-        return ATCA_SUCCESS;
-    }
-
-    return ATCA_COMM_FAIL;
-}
-
-/** \brief idle CryptoAuth device using I2C bus
- * \param[in] iface  interface to logical device to idle
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-
-ATCA_STATUS hal_i2c_idle(ATCAIface iface)
-{
-    ATCAIfaceCfg *cfg = atgetifacecfg(iface);
-    int bus = cfg->atcai2c.bus;
-    uint8_t data[4];
-
-    twi_package_t packet = {
-        .addr_length    = 0,                                // TWI slave memory address data size
-        .chip           = cfg->atcai2c.slave_address,       // TWI slave bus address
-        .buffer         = &data[0],                         // transfer data source buffer
-        .length         = 1                                 // transfer data size (bytes)
-    };
-
-    data[0] = 0x02;  // idle word address value
-    if (twi_master_write((i2c_hal_data[bus]->i2c_master_instance), &packet) != STATUS_OK)
-    {
-        return ATCA_COMM_FAIL;
-    }
-
-    return ATCA_SUCCESS;
-
-}
-
-/** \brief sleep CryptoAuth device using I2C bus
- * \param[in] iface  interface to logical device to sleep
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-
-ATCA_STATUS hal_i2c_sleep(ATCAIface iface)
-{
-    ATCAIfaceCfg *cfg = atgetifacecfg(iface);
-    int bus = cfg->atcai2c.bus;
-    uint8_t data[4];
-
-    twi_package_t packet = {
-        .addr_length    = 0,                                // TWI slave memory address data size
-        .chip           = cfg->atcai2c.slave_address,       // TWI slave bus address
-        .buffer         = &data[0],                         // transfer data source buffer
-        .length         = 1                                 // transfer data size (bytes)
-    };
-
-    data[0] = 0x01;  // sleep word address value
-    if (twi_master_write((i2c_hal_data[bus]->i2c_master_instance), &packet) != STATUS_OK)
-    {
-        return ATCA_COMM_FAIL;
-    }
-
-    return ATCA_SUCCESS;
-}
-
-/** \brief manages reference count on given bus and releases resource if no more refences exist
- * \param[in] hal_data - opaque pointer to hal data structure - known only to the HAL implementation
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-
-ATCA_STATUS hal_i2c_release(void *hal_data)
-{
-    ATCAI2CMaster_t *hal = (ATCAI2CMaster_t*)hal_data;
-
-
-    if (i2c_bus_ref_ct > 0)
-    {
-        i2c_bus_ref_ct--;  // track total i2c bus interface instances for consistency checking and debugging
-    }
-    else
-    {
-        return ATCA_EXECUTION_ERROR;
-    }
-
-    if (hal->ref_ct <= 0)
-    {
-        return ATCA_EXECUTION_ERROR;
-    }
-
-    // if the use count for this bus has gone to 0 references, disable it.  protect against an unbracketed release
-    if (hal && --(hal->ref_ct) <= 0 && i2c_hal_data[hal->bus_index] != NULL)
-    {
-        twi_reset();
-        free(i2c_hal_data[hal->bus_index]);
-        i2c_hal_data[hal->bus_index] = NULL;
-    }
-
-    return ATCA_SUCCESS;
-}
-
-/** @} */
diff --git a/lib/hal/hal_at90usb1287_i2c_asf.h b/lib/hal/hal_at90usb1287_i2c_asf.h
deleted file mode 100644
index 82ef65e314e7..000000000000
--- a/lib/hal/hal_at90usb1287_i2c_asf.h
+++ /dev/null
@@ -1,64 +0,0 @@
-/**
- * \file
- * \brief ATCA Hardware abstraction layer for AT90USB1287 I2C over ASF drivers.
- *
- * Prerequisite: add I2C Master Polled support to application in Atmel Studio
- *
- * \copyright (c) 2017 Microchip Technology Inc. and its subsidiaries.
- *            You may use this software and any derivatives exclusively with
- *            Microchip products.
- *
- * \page License
- *
- * (c) 2017 Microchip Technology Inc. and its subsidiaries. You may use this
- * software and any derivatives exclusively with Microchip products.
- *
- * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
- * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
- * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
- * PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
- * WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
- *
- * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
- * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
- * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
- * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
- * FULLEST EXTENT ALLOWED BY LAW, MICROCHIPS TOTAL LIABILITY ON ALL CLAIMS IN
- * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
- * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
- *
- * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
- * TERMS.
- */
-
-#ifndef HAL_AT90USB1287_I2C_ASF_H_
-#define HAL_AT90USB1287_I2C_ASF_H_
-
-#include <asf.h>
-#include "twi_megarf.h"
-
-/** \defgroup hal_ Hardware abstraction layer (hal_)
- *
- * \brief
- * These methods define the hardware abstraction layer for communicating with a CryptoAuth device
- * using I2C driver of ASF.
- *
-   @{ */
-
-
-#define MAX_I2C_BUSES    1   // AT90USB1287 has only 1 PORT that can be configured as I2C
-
-/** \brief this is the hal_data for ATCA HAL created using ASF
- */
-typedef struct atcaI2Cmaster
-{
-    /*twi_master_t*/ int* i2c_master_instance;
-    int                   ref_ct;
-    // for conveniences during interface release phase
-    int bus_index;
-} ATCAI2CMaster_t;
-
-void change_i2c_speed(ATCAIface iface, uint32_t speed);
-
-/** @} */
-#endif /* HAL_AT90USB1287_I2C_ASF_H_ */
\ No newline at end of file
diff --git a/lib/hal/hal_at90usb1287_timer_asf.c b/lib/hal/hal_at90usb1287_timer_asf.c
deleted file mode 100644
index bd6260f5b11a..000000000000
--- a/lib/hal/hal_at90usb1287_timer_asf.c
+++ /dev/null
@@ -1,79 +0,0 @@
-/**
- * \file
- * \brief ATCA Hardware abstraction layer for AT90USB1287 timer/delay over ASF drivers.
- *
- * \copyright (c) 2017 Microchip Technology Inc. and its subsidiaries.
- *            You may use this software and any derivatives exclusively with
- *            Microchip products.
- *
- * \page License
- *
- * (c) 2017 Microchip Technology Inc. and its subsidiaries. You may use this
- * software and any derivatives exclusively with Microchip products.
- *
- * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
- * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
- * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
- * PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
- * WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
- *
- * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
- * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
- * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
- * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
- * FULLEST EXTENT ALLOWED BY LAW, MICROCHIPS TOTAL LIABILITY ON ALL CLAIMS IN
- * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
- * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
- *
- * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
- * TERMS.
- */
-
-#include <asf.h>
-#include <delay.h>
-#include "atca_hal.h"
-
-/** \defgroup hal_ Hardware abstraction layer (hal_)
- *
- * \brief
- * These methods define the hardware abstraction layer for communicating with a CryptoAuth device
- *
-   @{ */
-
-
-/** \brief This function delays for a number of microseconds.
- *
- * \param[in] delay number of microseconds to delay
- */
-void atca_delay_us(uint32_t delay)
-{
-    // use ASF supplied delay
-    delay_us(delay);
-}
-
-/** \brief This function delays for a number of tens of microseconds.
- *
- * \param[in] delay number of 0.01 milliseconds to delay
- */
-void atca_delay_10us(uint32_t delay)
-{
-    // use ASF supplied delay
-    delay_us(delay * 10);
-
-}
-
-/** \brief This function delays for a number of milliseconds.
- *
- *         You can override this function if you like to do
- *         something else in your system while delaying.
- * \param[in] delay number of milliseconds to delay
- */
-
-/* ASF already has delay_ms - see delay.h */
-void atca_delay_ms(uint32_t delay)
-{
-    // use ASF supplied delay
-    delay_ms(delay);
-}
-
-/** @} */
diff --git a/lib/hal/hal_i2c_bitbang.c b/lib/hal/hal_i2c_bitbang.c
deleted file mode 100644
index d25cc9887e03..000000000000
--- a/lib/hal/hal_i2c_bitbang.c
+++ /dev/null
@@ -1,518 +0,0 @@
-/**
- * \file
- * \brief ATCA Hardware abstraction layer for I2C bit banging.
- *
- * \copyright (c) 2017 Microchip Technology Inc. and its subsidiaries.
- *            You may use this software and any derivatives exclusively with
- *            Microchip products.
- *
- * \page License
- *
- * (c) 2017 Microchip Technology Inc. and its subsidiaries. You may use this
- * software and any derivatives exclusively with Microchip products.
- *
- * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
- * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
- * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
- * PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
- * WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
- *
- * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
- * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
- * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
- * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
- * FULLEST EXTENT ALLOWED BY LAW, MICROCHIPS TOTAL LIABILITY ON ALL CLAIMS IN
- * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
- * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
- *
- * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
- * TERMS.
- */
-
-#include <asf.h>
-#include <string.h>
-#include <stdio.h>
-#include "atca_hal.h"
-#include "atca_device.h"
-#include "hal_i2c_bitbang.h"
-
-
-/**
- * \defgroup hal_ Hardware abstraction layer (hal_)
- *
- * \brief These methods define the hardware abstraction layer for
- *        communicating with a CryptoAuth device using I2C bit banging.
-   @{ */
-
-/**
- * \brief Logical to physical bus mapping structure.
- */
-ATCAI2CMaster_t *i2c_hal_data[MAX_I2C_BUSES];   //!< map logical, 0-based bus number to index
-int i2c_bus_ref_ct = 0;                         //!< total in-use count across buses
-
-
-/** \brief discover i2c buses available for this hardware
- * this maintains a list of logical to physical bus mappings freeing the application
- * of the prior knowledge
- * \param[in] i2c_buses - an array of logical bus numbers
- * \param[in] max_buses - maximum number of buses the app wants to attempt to discover
- * \return ATCA_SUCCESS
- */
-
-ATCA_STATUS hal_i2c_discover_buses(int i2c_buses[], int max_buses)
-{
-
-    i2c_discover_buses(i2c_buses, max_buses);
-
-    return ATCA_SUCCESS;
-
-}
-
-
-/** \brief discover any CryptoAuth devices on a given logical bus number
- * \param[in] busNum - logical bus number on which to look for CryptoAuth devices
- * \param[out] cfg[] - pointer to head of an array of interface config structures which get filled in by this method
- * \param[out] *found - number of devices found on this bus
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-
-ATCA_STATUS hal_i2c_discover_devices(int busNum, ATCAIfaceCfg cfg[], int *found)
-{
-    ATCAIfaceCfg *head = cfg;
-    uint8_t slaveAddress = 0x01;
-    ATCADevice device;
-    ATCAIface discoverIface;
-    ATCACommand command;
-    ATCAPacket packet;
-    ATCA_STATUS status;
-    uint8_t revs508[1][4] = { { 0x00, 0x00, 0x50, 0x00 } };
-    uint8_t revs108[1][4] = { { 0x80, 0x00, 0x10, 0x01 } };
-    uint8_t revs204[3][4] = { { 0x00, 0x02, 0x00, 0x08 },
-                              { 0x00, 0x02, 0x00, 0x09 },
-                              { 0x00, 0x04, 0x05, 0x00 } };
-    int i;
-
-    /** \brief default configuration, to be reused during discovery process */
-    ATCAIfaceCfg discoverCfg = {
-        .iface_type             = ATCA_I2C_IFACE,
-        .devtype                = ATECC508A,
-        .atcai2c.slave_address  = 0x07,
-        .atcai2c.bus            = busNum,
-        .atcai2c.baud           = 400000,
-        //.atcai2c.baud = 100000,
-        .wake_delay             = 800,
-        .rx_retries             = 3
-    };
-
-    ATCAHAL_t hal;
-
-    hal_i2c_init(&hal, &discoverCfg);
-    device = newATCADevice(&discoverCfg);
-    discoverIface = atGetIFace(device);
-    command = atGetCommands(device);
-
-    // iterate through all addresses on given i2c bus
-    // all valid 7-bit addresses go from 0x07 to 0x78
-    for (slaveAddress = 0x07; slaveAddress <= 0x78; slaveAddress++)
-    {
-        discoverCfg.atcai2c.slave_address = slaveAddress << 1;  // turn it into an 8-bit address which is what the rest of the i2c HAL is expecting when a packet is sent
-
-        // wake up device
-        // If it wakes, send it a dev rev command.  Based on that response, determine the device type
-        // BTW - this will wake every cryptoauth device living on the same bus (ecc508a, sha204a)
-
-        if (hal_i2c_wake(discoverIface) == ATCA_SUCCESS)
-        {
-            (*found)++;
-            memcpy( (uint8_t*)head, (uint8_t*)&discoverCfg, sizeof(ATCAIfaceCfg));
-
-            memset(packet.data, 0x00, sizeof(packet.data));
-
-            // get devrev info and set device type accordingly
-            atInfo(command, &packet);
-            if ((status = atGetExecTime(packet.opcode, command)) != ATCA_SUCCESS)
-            {
-                continue;
-            }
-
-            // send the command
-            if ( (status = atsend(discoverIface, (uint8_t*)&packet, packet.txsize)) != ATCA_SUCCESS)
-            {
-                printf("packet send error\r\n");
-                continue;
-            }
-
-            // delay the appropriate amount of time for command to execute
-            atca_delay_ms((command->execution_time_msec) + 1);
-
-            // receive the response
-            if ( (status = atreceive(discoverIface, &(packet.data[0]), &(packet.rxsize) )) != ATCA_SUCCESS)
-            {
-                continue;
-            }
-
-            if ( (status = isATCAError(packet.data)) != ATCA_SUCCESS)
-            {
-                printf("command response error\r\n");
-                continue;
-            }
-
-            // determine device type from common info and dev rev response byte strings
-            for (i = 0; i < (int)sizeof(revs508) / 4; i++)
-            {
-                if (memcmp(&packet.data[1], &revs508[i], 4) == 0)
-                {
-                    discoverCfg.devtype = ATECC508A;
-                    break;
-                }
-            }
-
-            for (i = 0; i < (int)sizeof(revs204) / 4; i++)
-            {
-                if (memcmp(&packet.data[1], &revs204[i], 4) == 0)
-                {
-                    discoverCfg.devtype = ATSHA204A;
-                    break;
-                }
-            }
-
-            for (i = 0; i < (int)sizeof(revs108) / 4; i++)
-            {
-                if (memcmp(&packet.data[1], &revs108[i], 4) == 0)
-                {
-                    discoverCfg.devtype = ATECC108A;
-                    break;
-                }
-            }
-
-            atca_delay_ms(15);
-            // now the device type is known, so update the caller's cfg array element with it
-            head->devtype = discoverCfg.devtype;
-            head++;
-        }
-
-        hal_i2c_idle(discoverIface);
-    }
-
-    hal_i2c_release(&hal);
-
-    return ATCA_SUCCESS;
-}
-
-/**
- * \brief This function creates a Start condition and sends the I2C
- *        address.
- *
- * \param[in] RorW  I2C_READ for reading, I2C_WRITE for writing.
- *
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-static ATCA_STATUS hal_i2c_send_slave_address(ATCAIface iface, uint8_t RorW)
-{
-    ATCAIfaceCfg *cfg = atgetifacecfg(iface);
-
-    ATCA_STATUS status = ATCA_TX_TIMEOUT;
-
-    uint8_t sla = cfg->atcai2c.slave_address | RorW;
-
-    i2c_send_start();
-
-    status = i2c_send_byte(sla);
-    if (status != ATCA_SUCCESS)
-    {
-        i2c_send_stop();
-    }
-
-    return status;
-}
-
-/**
- * \brief hal_i2c_init manages requests to initialize a physical
- *        interface. It manages use counts so when an interface has
- *        released the physical layer, it will disable the interface for
- *        some other use. You can have multiple ATCAIFace instances using
- *        the same bus, and you can have multiple ATCAIFace instances on
- *        multiple i2c buses, so hal_i2c_init manages these things and
- *        ATCAIFace is abstracted from the physical details.
- */
-
-/**
- * \brief Initialize an I2C interface using given config.
- *
- * \param[in] hal  opaque pointer to HAL data
- * \param[in] cfg  interface configuration
- *
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-ATCA_STATUS hal_i2c_init(void *hal, ATCAIfaceCfg *cfg)
-{
-    ATCAHAL_t *phal = (ATCAHAL_t*)hal;
-
-    int bus = cfg->atcai2c.bus; //!< 0-based logical bus number
-
-    if (i2c_bus_ref_ct == 0)    //!< power up state, no i2c buses will have been used
-
-    {
-        for (int i = 0; i < MAX_I2C_BUSES; i++)
-        {
-            i2c_hal_data[i] = NULL;
-        }
-    }
-
-    i2c_bus_ref_ct++;   //!< total across buses
-
-    if (bus >= 0 && bus < MAX_I2C_BUSES)
-    {
-        //! if this is the first time this bus and interface has been created, do the physical work of enabling it
-        if (i2c_hal_data[bus] == NULL)
-        {
-            i2c_hal_data[bus] = malloc(sizeof(ATCAI2CMaster_t));
-            i2c_hal_data[bus]->ref_ct = 1;  //!< buses are shared, this is the first instance
-
-            //! assign GPIO pins
-            i2c_hal_data[bus]->pin_sda = i2c_buses_default.pin_sda[bus];
-            i2c_hal_data[bus]->pin_scl = i2c_buses_default.pin_scl[bus];
-
-            i2c_set_pin(i2c_hal_data[bus]->pin_sda, i2c_hal_data[bus]->pin_scl);
-            i2c_enable();
-
-            //! store this for use during the release phase
-            i2c_hal_data[bus]->bus_index = bus;
-        }
-        else
-        {
-            //! otherwise, another interface already initialized the bus, so this interface will share it and any different
-            //! cfg parameters will be ignored...first one to initialize this sets the configuration
-            i2c_hal_data[bus]->ref_ct++;
-        }
-
-        phal->hal_data = i2c_hal_data[bus];
-
-        return ATCA_SUCCESS;
-    }
-
-    return ATCA_COMM_FAIL;
-}
-
-
-
-/** \brief HAL implementation of I2C post init
- * \param[in] iface  instance
- * \return ATCA_STATUS
- */
-ATCA_STATUS hal_i2c_post_init(ATCAIface iface)
-{
-    return ATCA_SUCCESS;
-}
-
-/**
- * \brief HAL implementation of Send byte(s) via I2C.
- *
- * \param[in] iface     interface of the logical device to send data to
- * \param[in] txdata    pointer to bytes to send
- * \param[in] txlength  number of bytes to send
- *
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-ATCA_STATUS hal_i2c_send(ATCAIface iface, uint8_t *txdata, int txlength)
-{
-    ATCAIfaceCfg *cfg = atgetifacecfg(iface);
-
-    ATCA_STATUS status = ATCA_TX_TIMEOUT;
-
-    int bus     = cfg->atcai2c.bus;
-
-    txdata[0] = 0x03;   //!< Word Address Value = Command
-    txlength++;         //!< count Word Address byte towards txlength
-
-    //! Set I2C pins
-    i2c_set_pin(i2c_hal_data[bus]->pin_sda, i2c_hal_data[bus]->pin_scl);
-
-    do
-    {
-        //! Address the device and indicate that bytes are to be written
-        status = hal_i2c_send_slave_address(iface, I2C_WRITE);
-        if (status != ATCA_SUCCESS)
-        {
-            break;
-        }
-
-        //! Send the remaining bytes
-        status = i2c_send_bytes(txlength, txdata);
-    }
-    while (0);
-
-    //! Send STOP regardless of i2c_status
-    i2c_send_stop();
-
-    return status;
-}
-
-/**
- * \brief HAL implementation of Receive byte(s) via I2C.
- *
- * \param[in] iface     interface of the logical device to receive data
- *                      from
- * \param[in] rxdata    pointer to where bytes will be received
- * \param[in] rxlength  pointer to expected number of receive bytes to
- *                      request
- *
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-ATCA_STATUS hal_i2c_receive(ATCAIface iface, uint8_t *rxdata, uint16_t *rxlength)
-{
-    ATCAIfaceCfg *cfg = atgetifacecfg(iface);
-
-    ATCA_STATUS status = ATCA_RX_TIMEOUT;
-
-    int bus     = cfg->atcai2c.bus;
-    int retries = cfg->rx_retries;
-    uint8_t count;
-
-    //! Set I2C pins
-    i2c_set_pin(i2c_hal_data[bus]->pin_sda, i2c_hal_data[bus]->pin_scl);
-
-    while (retries-- > 0 && status != ATCA_SUCCESS)
-    {
-        //! Address the device and indicate that bytes are to be read
-        status = hal_i2c_send_slave_address(iface, I2C_READ);
-        if (status == ATCA_SUCCESS)
-        {
-            //! Receive count byte
-            i2c_receive_byte(rxdata);
-            count = rxdata[0];
-            if ((count < ATCA_RSP_SIZE_MIN) || (count > *rxlength))
-            {
-                i2c_send_stop();
-                status = ATCA_INVALID_SIZE;
-                break;
-            }
-
-            //! Receive the remaining bytes
-            i2c_receive_bytes(count - 1, &rxdata[1]);
-        }
-    }
-    if (status == ATCA_TX_TIMEOUT)
-    {
-        status = ATCA_RX_NO_RESPONSE;
-    }
-
-    return status;
-}
-
-
-/** \brief wake up CryptoAuth device using I2C bus
- * \param[in] iface  interface to logical device to wakeup
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-
-ATCA_STATUS hal_i2c_wake(ATCAIface iface)
-{
-    ATCAIfaceCfg *cfg = atgetifacecfg(iface);
-
-    ATCA_STATUS status = ATCA_WAKE_FAILED;
-
-    int bus     = cfg->atcai2c.bus;
-    uint8_t response[4] = { 0x00, 0x00, 0x00, 0x00 };
-    uint8_t expected_response[4] = { 0x04, 0x11, 0x33, 0x43 };
-    uint16_t response_size = sizeof(response);
-
-    //! Set I2C pins
-    i2c_set_pin(i2c_hal_data[bus]->pin_sda, i2c_hal_data[bus]->pin_scl);
-
-    //! Generate Wake Token
-    i2c_send_wake_token();
-
-    //! Wait tWHI + tWLO
-    atca_delay_us(cfg->wake_delay);
-
-    //! Receive Wake Response
-    status = hal_i2c_receive(iface, response, &response_size);
-    if (status == ATCA_SUCCESS)
-    {
-        //! Compare response with expected_response
-        if (memcmp(response, expected_response, 4) != 0)
-        {
-            status = ATCA_WAKE_FAILED;
-        }
-    }
-
-    return status;
-}
-
-/** \brief idle CryptoAuth device using I2C bus
- * \param[in] iface  interface to logical device to idle
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-ATCA_STATUS hal_i2c_idle(ATCAIface iface)
-{
-    ATCAIfaceCfg *cfg = atgetifacecfg(iface);
-
-    ATCA_STATUS status = ATCA_TX_TIMEOUT;
-
-    int bus     = cfg->atcai2c.bus;
-
-    //! Set I2C pins
-    i2c_set_pin(i2c_hal_data[bus]->pin_sda, i2c_hal_data[bus]->pin_scl);
-
-    //! Address the device and indicate that bytes are to be written
-    status = hal_i2c_send_slave_address(iface, I2C_WRITE);
-    if (status == ATCA_SUCCESS)
-    {
-        status = i2c_send_byte(0x02);   //!< Word Address Value = Idle
-        i2c_send_stop();
-    }
-
-    return status;
-}
-
-/** \brief sleep CryptoAuth device using I2C bus
- * \param[in] iface  interface to logical device to sleep
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-
-ATCA_STATUS hal_i2c_sleep(ATCAIface iface)
-{
-    ATCAIfaceCfg *cfg = atgetifacecfg(iface);
-
-    ATCA_STATUS status = ATCA_TX_TIMEOUT;
-
-    int bus     = cfg->atcai2c.bus;
-
-    //! Set I2C pins
-    i2c_set_pin(i2c_hal_data[bus]->pin_sda, i2c_hal_data[bus]->pin_scl);
-
-    //! Address the device and indicate that bytes are to be written
-    status = hal_i2c_send_slave_address(iface, I2C_WRITE);
-    if (status == ATCA_SUCCESS)
-    {
-        status = i2c_send_byte(0x01);   //!< Word Address Value = Sleep
-        i2c_send_stop();
-    }
-
-    return status;
-}
-
-/** \brief manages reference count on given bus and releases resource if no more refences exist
- * \param[in] hal_data - opaque pointer to hal data structure - known only to the HAL implementation
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-ATCA_STATUS hal_i2c_release(void *hal_data)
-{
-    ATCAI2CMaster_t *hal = (ATCAI2CMaster_t*)hal_data;
-
-    i2c_bus_ref_ct--;   // track total i2c bus interface instances for consistency checking and debugging
-
-    // if the use count for this bus has gone to 0 references, disable it.  protect against an unbracketed release
-    if (hal && --(hal->ref_ct) <= 0 && i2c_hal_data[hal->bus_index] != NULL)
-    {
-        i2c_set_pin(i2c_hal_data[hal->bus_index]->pin_sda, i2c_hal_data[hal->bus_index]->pin_scl);
-        i2c_disable();
-        free(i2c_hal_data[hal->bus_index]);
-        i2c_hal_data[hal->bus_index] = NULL;
-    }
-
-    return ATCA_SUCCESS;
-}
-
-/** @} */
\ No newline at end of file
diff --git a/lib/hal/hal_i2c_bitbang.h b/lib/hal/hal_i2c_bitbang.h
deleted file mode 100644
index 02b33f83babf..000000000000
--- a/lib/hal/hal_i2c_bitbang.h
+++ /dev/null
@@ -1,78 +0,0 @@
-/**
- * \file
- * \brief ATCA Hardware abstraction layer for I2C bit banging.
- *
- * \copyright (c) 2017 Microchip Technology Inc. and its subsidiaries.
- *            You may use this software and any derivatives exclusively with
- *            Microchip products.
- *
- * \page License
- *
- * (c) 2017 Microchip Technology Inc. and its subsidiaries. You may use this
- * software and any derivatives exclusively with Microchip products.
- *
- * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
- * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
- * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
- * PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
- * WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
- *
- * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
- * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
- * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
- * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
- * FULLEST EXTENT ALLOWED BY LAW, MICROCHIPS TOTAL LIABILITY ON ALL CLAIMS IN
- * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
- * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
- *
- * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
- * TERMS.
- */
-
-#ifndef HAL_I2C_BITBANG_H_
-#define HAL_I2C_BITBANG_H_
-
-
-
-
-
-#if     BOARD == AT88CK9000
-#       include "i2c_bitbang_at88ck9000.h"
-#endif
-
-#if    (SAMD21 == 1)
-#include "i2c_bitbang_samd21.h"
-#endif
-
-
-/**
- * \defgroup hal_ Hardware abstraction layer (hal_)
- *
- * \brief These methods define the hardware abstraction layer for
- *        communicating with a CryptoAuth device using I2C bit banging.
-   @{ */
-
-/**
- * \brief This enumeration lists flags for I2C read or write addressing.
- */
-enum i2c_read_write_flag
-{
-    I2C_WRITE = (uint8_t)0x00,  //!< write command flag
-    I2C_READ  = (uint8_t)0x01   //!< read command flag
-};
-
-/**
- * \brief This is the hal_data for ATCA HAL.
- */
-typedef struct atcaI2Cmaster
-{
-    uint32_t pin_sda;
-    uint32_t pin_scl;
-    int      ref_ct;
-    //! for conveniences during interface release phase
-    int bus_index;
-} ATCAI2CMaster_t;
-
-/** @} */
-
-#endif /* HAL_AT88CK900X_I2C_H_ */
\ No newline at end of file
diff --git a/lib/hal/hal_linux_kit_cdc.c b/lib/hal/hal_linux_kit_cdc.c
deleted file mode 100644
index 232cefc93b97..000000000000
--- a/lib/hal/hal_linux_kit_cdc.c
+++ /dev/null
@@ -1,428 +0,0 @@
-/**
- * \file
- * \brief ATCA Hardware abstraction layer for Linux using kit protocol over a USB CDC device.
- *
- * \copyright (c) 2017 Microchip Technology Inc. and its subsidiaries.
- *            You may use this software and any derivatives exclusively with
- *            Microchip products.
- *
- * \page License
- *
- * (c) 2017 Microchip Technology Inc. and its subsidiaries. You may use this
- * software and any derivatives exclusively with Microchip products.
- *
- * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
- * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
- * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
- * PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
- * WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
- *
- * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
- * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
- * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
- * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
- * FULLEST EXTENT ALLOWED BY LAW, MICROCHIPS TOTAL LIABILITY ON ALL CLAIMS IN
- * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
- * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
- *
- * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
- * TERMS.
- */
-
-#include "atca_hal.h"
-#include "kit_phy.h"
-#include "hal_linux_kit_cdc.h"
-#include "kit_protocol.h"
-
-#include <stdio.h>
-#include <string.h>
-#include <termios.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <fcntl.h>
-#include <unistd.h>
-
-/** \defgroup hal_ Hardware abstraction layer (hal_)
- *
- * \brief
- * These methods define the hardware abstraction layer for communicating with a CryptoAuth device
- *
-   @{ */
-
-// File scope macros
-#ifndef __cplusplus
-#define max(a, b)    (((a) > (b)) ? (a) : (b))
-#define min(a, b)    (((a) < (b)) ? (a) : (b))
-#endif
-
-// File scope globals
-atcacdc_t _gCdc;
-
-
-
-char *dev = "/dev/ttyACM0";  // default device, Atmel CryptoAuth %n
-//char *dev = "/dev/ttyATCA0";  // default device, Atmel CryptoAuth %n
-int speed = B115200;
-
-/** \brief discover cdc buses available for this hardware
- * this maintains a list of logical to physical bus mappings freeing the application
- * of the a-priori knowledge.This function is currently not implemented.
- * \param[in] cdc_buses - an array of logical bus numbers
- * \param[in] max_buses - maximum number of buses the app wants to attempt to discover
- * \return ATCA_UNIMPLEMENTED
-
- */
-
-ATCA_STATUS hal_cdc_discover_buses(int cdc_buses[], int max_buses)
-{
-    return ATCA_UNIMPLEMENTED;
-}
-
-/** \brief discover any CryptoAuth devices on a given logical bus number
- * \param[in] busNum - logical bus number on which to look for CryptoAuth devices
- * \param[out] cfg[] - pointer to head of an array of interface config structures which get filled in by this method
- * \param[out] *found - number of devices found on this bus
- * \return ATCA_UNIMPLEMENTED
- */
-
-ATCA_STATUS hal_cdc_discover_devices(int busNum, ATCAIfaceCfg cfg[], int *found)
-{
-    return ATCA_UNIMPLEMENTED;
-}
-
-
-
-/** \brief HAL implementation of Kit USB CDC init
- *
- * this discovery assumes a udev rule is active which renames the ATCK101 CDC device as a ttyATCA%n
- * the udev rule is:
- *
- *  SUBSYSTEMS=="usb", ATTRS{idVendor}=="03eb", ATTRS{idProduct}=="2122", MODE:="0777", SYMLINK+="ttyATCA%n"
- *
- *  \param[in] hal pointer to HAL specific data that is maintained by this HAL
- *  \param[in] cfg pointer to HAL specific configuration data that is used to initialize this HAL
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-ATCA_STATUS hal_kit_cdc_init(void* hal, ATCAIfaceCfg* cfg)
-{
-    ATCAHAL_t *phal = NULL;
-    struct termios serialTermios;
-    uint32_t i = 0;
-    uint32_t index = 0;
-    int fd;
-
-    // Check the input variables
-    if ((hal == NULL) || (cfg == NULL))
-    {
-        return ATCA_BAD_PARAM;
-    }
-
-    // Cast the hal to the ATCAHAL_t structure
-    phal = (ATCAHAL_t*)hal;
-
-    // Initialize the _gCdc structure
-    memset(&_gCdc, 0, sizeof(_gCdc));
-    for (i = 0; i < CDC_DEVICES_MAX; i++)
-    {
-        _gCdc.kits[i].read_handle = INVALID_HANDLE_VALUE;
-        _gCdc.kits[i].write_handle = INVALID_HANDLE_VALUE;
-    }
-    _gCdc.num_kits_found = 0;
-
-    // Get the read & write handles
-    // todo: perform an actual discovery here...
-    if ( (fd = open(dev, O_RDWR | O_NOCTTY)) < 0)
-    {
-        printf("Failed to open %s ret:%02X\n", dev, fd);
-        return ATCA_COMM_FAIL;
-    }
-    index++;
-    // Save the results of this discovery of CDC
-    if (index > 0)
-    {
-        _gCdc.num_kits_found = 1;
-        phal->hal_data = &_gCdc;
-    }
-
-    tcgetattr(fd, &serialTermios);
-    cfsetispeed(&serialTermios, speed);
-    cfsetospeed(&serialTermios, speed);
-    cfmakeraw(&serialTermios);
-
-    serialTermios.c_cflag |= CS8 | CLOCAL | CREAD;
-    serialTermios.c_iflag = 0;
-    serialTermios.c_oflag = 0;
-    serialTermios.c_lflag = 0;
-    // serialTermios.c_cc[VMIN] = 1;
-    // serialTermios.c_cc[VTIME] = 0;
-
-    tcsetattr(fd, TCSANOW, &serialTermios);
-
-    _gCdc.kits[0].read_handle = fd;
-    _gCdc.kits[0].write_handle = fd;
-
-    return ATCA_SUCCESS;
-}
-
-/** \brief HAL implementation of Kit USB CDC post init
- *  \param[in] iface  instance
- *   \return ATCA_SUCCESS on success, otherwise an error code.
- */
-ATCA_STATUS hal_kit_cdc_post_init(ATCAIface iface)
-{
-    ATCA_STATUS status = ATCA_SUCCESS;
-    atcacdc_t* phaldat = atgetifacehaldat(iface);
-    ATCAIfaceCfg *cfg = atgetifacecfg(iface);
-    //int cdcid = cfg->atcauart.port;
-    int i = 0;
-
-    // Init all kit USB devices
-    for (i = 0; i < phaldat->num_kits_found; i++)
-    {
-        // Set the port
-        cfg->atcauart.port = i;
-        // Perform the kit protocol init
-        status = kit_init(iface);
-        if (status != ATCA_SUCCESS)
-        {
-            return status;
-        }
-    }
-
-    return status;
-}
-
-/** \brief HAL implementation of kit protocol send .It is called by the top layer.
- *  \param[in] iface     instance
- *  \param[in] txdata    pointer to bytes to send
- *  \param[in] txlength  number of bytes to send
- *  \return ATCA_SUCCESS on success, otherwise an error code.
- */
-ATCA_STATUS kit_phy_send(ATCAIface iface, const char* txdata, int txlength)
-{
-    ATCA_STATUS status = ATCA_SUCCESS;
-    ATCAIfaceCfg *cfg = atgetifacecfg(iface);
-    int cdcid = cfg->atcauart.port;
-    atcacdc_t* pCdc = (atcacdc_t*)atgetifacehaldat(iface);
-    size_t bytesWritten = 0;
-
-#ifdef KIT_DEBUG
-    printf("--> %s", txdata);
-#endif
-    // Verify the input parameters
-    if ((txdata == NULL) || (pCdc == NULL))
-    {
-        return ATCA_BAD_PARAM;
-    }
-
-    // Verify the write handle
-    if (pCdc->kits[cdcid].write_handle == INVALID_HANDLE_VALUE)
-    {
-        return ATCA_COMM_FAIL;
-    }
-
-    // Write the bytes to the specified com port
-    bytesWritten = write(pCdc->kits[cdcid].write_handle, txdata, txlength);
-
-    return status;
-}
-
-/** \brief HAL implementation of kit protocol receive data.It is called by the top layer.
- * \param[in]    iface   instance
- * \param[out]   rxdata  pointer to space to receive the data
- * \param[inout] rxsize  ptr to expected number of receive bytes to request
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-ATCA_STATUS kit_phy_receive(ATCAIface iface, char* rxdata, int* rxsize)
-{
-    ATCA_STATUS status = ATCA_SUCCESS;
-    ATCAIfaceCfg *cfg = atgetifacecfg(iface);
-    int cdcid = cfg->atcauart.port;
-    atcacdc_t* pCdc = (atcacdc_t*)atgetifacehaldat(iface);
-    uint8_t buffer[CDC_BUFFER_MAX] = { 0 };
-    bool continue_read = true;
-    int bytes_read = 0;
-    uint16_t total_bytes = 0;
-    char* location = NULL;
-    int bytes_remain = 0;
-    int bytes_to_cpy = 0;
-
-    do
-    {
-        // Verify the input variables
-        if ((rxdata == NULL) || (rxsize == NULL) || (pCdc == NULL))
-        {
-            status = ATCA_BAD_PARAM;
-            break;
-        }
-        // Verify the write handle
-        if (pCdc->kits[cdcid].read_handle == INVALID_HANDLE_VALUE)
-        {
-            status = ATCA_COMM_FAIL;
-            break;
-        }
-        // Read all of the bytes
-        while (continue_read == true)
-        {
-            bytes_read = read(pCdc->kits[cdcid].read_handle, buffer, CDC_BUFFER_MAX);
-
-            // Find the location of the '\n' character in read buffer
-            // todo: generalize this read...  it only applies if there is an ascii protocol with an <eom> of \n and if the <eom> exists
-            location = strchr((char*)&buffer[0], '\n');
-            if (location == NULL)
-            {
-                // Copy all of the bytes
-                bytes_to_cpy = bytes_read;
-            }
-            else
-            {
-                // Copy only the bytes remaining in the read buffer to the <eom>
-                bytes_to_cpy = (uint8_t)(location - (char*)buffer) + 1;
-                // The response has been received, stop receiving more data
-                continue_read = false;
-            }
-            // Protect rxdata from overwriting, this will have the result of truncating the returned bytes
-            // Remaining space in rxdata
-            bytes_remain = (*rxsize - total_bytes);
-            // Use the minimum between number of bytes read and remaining space
-            bytes_to_cpy = min(bytes_remain, bytes_to_cpy);
-
-            // Copy the received data
-            memcpy(&rxdata[total_bytes], &buffer[0], bytes_to_cpy);
-            total_bytes += bytes_to_cpy;
-        }
-
-    }
-    while (0);
-
-    *rxsize = total_bytes;
-#ifdef KIT_DEBUG
-    printf("<-- %s", rxdata);
-#endif
-    return status;
-}
-
-/** \brief Number of USB CDC devices found
- *  \param[out] num_found
- *  \return ATCA_STATUS
- */
-ATCA_STATUS hal_kit_phy_num_found(int8_t* num_found)
-{
-    *num_found = _gCdc.num_kits_found;
-    return ATCA_SUCCESS;
-}
-
-/** \brief HAL implementation of kit protocol send over USB CDC
- *  \param[in] iface     instance
- *  \param[in] txdata    pointer to bytes to send
- *  \param[in] txlength  number of bytes to send
- *  \return ATCA_SUCCESS on success, otherwise an error code.
- */
-ATCA_STATUS hal_kit_cdc_send(ATCAIface iface, uint8_t* txdata, int txlength)
-{
-    // Call the hal_kit_send() function that will call hal_phy_send() implemented below
-    return kit_send(iface, txdata, txlength);
-}
-
-/** \brief HAL implementation of kit protocol receive over USB CDC
- * \param[in]    iface   instance
- * \param[in]    rxdata  pointer to space to receive the data
- * \param[inout] rxsize  ptr to expected number of receive bytes to request
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-ATCA_STATUS hal_kit_cdc_receive(ATCAIface iface, uint8_t* rxdata, uint16_t* rxsize)
-{
-    // Call the hal_kit_receive() function that will call hal_phy_receive() implemented below
-    return kit_receive(iface, rxdata, rxsize);
-}
-
-/** \brief Call the wake for kit protocol over USB CDC
- * \param[in] iface ATCAIface instance that is the interface object to send the bytes over
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-ATCA_STATUS hal_kit_cdc_wake(ATCAIface iface)
-{
-    // Call the hal_kit_wake() function that will call hal_phy_send() and hal_phy_receive()
-    return kit_wake(iface);
-}
-
-/** \brief Call the idle for kit protocol over USB CDC
- * \param[in] iface ATCAIface instance that is the interface object to send the bytes over
- * \return ATCA_SUCCESS on success, otherwise an error code.S
- */
-ATCA_STATUS hal_kit_cdc_idle(ATCAIface iface)
-{
-    // Call the hal_kit_idle() function that will call hal_phy_send() and hal_phy_receive()
-    return kit_idle(iface);
-}
-
-/** \brief Call the sleep for kit protocol over USB CDC
- * \param[in] iface ATCAIface instance that is the interface object to send the bytes over
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-ATCA_STATUS hal_kit_cdc_sleep(ATCAIface iface)
-{
-    // Call the hal_kit_sleep() function that will call hal_phy_send() and hal_phy_receive()
-    return kit_sleep(iface);
-}
-
-/** \brief Close the physical port for CDC over USB CDC
- * \param[in] hal_data The hardware abstraction data specific to this HAL
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-ATCA_STATUS hal_kit_cdc_release(void* hal_data)
-{
-    int i = 0;
-    atcacdc_t* phaldat = (atcacdc_t*)hal_data;
-
-    if ((hal_data == NULL))
-    {
-        return ATCA_BAD_PARAM;
-    }
-
-    // Close all kit USB devices
-    for (i = 0; i < phaldat->num_kits_found; i++)
-    {
-        if (phaldat->kits[i].read_handle != INVALID_HANDLE_VALUE)
-        {
-            close(phaldat->kits[i].read_handle);
-            phaldat->kits[i].read_handle = INVALID_HANDLE_VALUE;
-        }
-
-        if (phaldat->kits[i].write_handle != INVALID_HANDLE_VALUE)
-        {
-            close(phaldat->kits[i].write_handle);
-            phaldat->kits[i].write_handle = INVALID_HANDLE_VALUE;
-        }
-    }
-    return ATCA_SUCCESS;
-}
-
-/** \brief discover cdc buses available for this hardware
- * this maintains a list of logical to physical bus mappings freeing the application
- * of the a-priori knowledge.This function is currently not implemented.
- * \param[in] cdc_buses - an array of logical bus numbers
- * \param[in] max_buses - maximum number of buses the app wants to attempt to discover
- * \return ATCA_UNIMPLEMENTED
-
- */
-ATCA_STATUS hal_kit_cdc_discover_buses(int cdc_buses[], int max_buses)
-{
-    // TODO: Implement
-    return ATCA_UNIMPLEMENTED;
-}
-
-/** \brief discover any CryptoAuth devices on a given logical bus number
- * \param[in] busNum - logical bus number on which to look for CryptoAuth devices
- * \param[out] cfg[] - pointer to head of an array of interface config structures which get filled in by this method
- * \param[out] *found - number of devices found on this bus
- * \return ATCA_UNIMPLEMENTED
- */
-
-ATCA_STATUS hal_kit_cdc_discover_devices(int busNum, ATCAIfaceCfg *cfg, int *found)
-{
-    // TODO: Implement
-    *found = 0;
-    return ATCA_UNIMPLEMENTED;
-}
-/** @} */
diff --git a/lib/hal/hal_linux_kit_cdc.h b/lib/hal/hal_linux_kit_cdc.h
deleted file mode 100644
index c0dcf4ab9801..000000000000
--- a/lib/hal/hal_linux_kit_cdc.h
+++ /dev/null
@@ -1,67 +0,0 @@
-/**
- * \file
- * \brief ATCA Hardware abstraction layer for Linux using kit protocol over a USB CDC device.
- *
- * \copyright (c) 2017 Microchip Technology Inc. and its subsidiaries.
- *            You may use this software and any derivatives exclusively with
- *            Microchip products.
- *
- * \page License
- *
- * (c) 2017 Microchip Technology Inc. and its subsidiaries. You may use this
- * software and any derivatives exclusively with Microchip products.
- *
- * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
- * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
- * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
- * PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
- * WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
- *
- * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
- * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
- * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
- * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
- * FULLEST EXTENT ALLOWED BY LAW, MICROCHIPS TOTAL LIABILITY ON ALL CLAIMS IN
- * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
- * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
- *
- * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
- * TERMS.
- */
-
-#ifndef HAL_LINUX_KIT_CDC_H_
-#define HAL_LINUX_KIT_CDC_H_
-
-/** \defgroup hal_ Hardware abstraction layer (hal_)
- *
- * \brief
- * These methods define the hardware abstraction layer for communicating with a CryptoAuth device
- *
-   @{ */
-
-// Kit USB defines
-#define CDC_DEVICES_MAX     10      //! Maximum number of supported Kit USB devices
-#define CDC_BUFFER_MAX      1024    //! Maximum number of bytes read per port read
-
-
-// Each device that is found will have a read handle and a write handle
-typedef int HANDLE;
-#define INVALID_HANDLE_VALUE ((int)(-1))
-typedef struct cdc_device
-{
-    HANDLE read_handle;         //! The kit USB read file handle
-    HANDLE write_handle;        //! The kit USB write file handle
-} cdc_device_t;
-
-
-// A structure to hold CDC information
-typedef struct atcacdc
-{
-    cdc_device_t kits[CDC_DEVICES_MAX];
-    int8_t       num_kits_found;
-} atcacdc_t;
-
-/** @} */
-
-#endif /* HAL_LINUX_KIT_CDC_H_ */
-
diff --git a/lib/hal/hal_linux_kit_hid.c b/lib/hal/hal_linux_kit_hid.c
deleted file mode 100644
index 960d18c7ddea..000000000000
--- a/lib/hal/hal_linux_kit_hid.c
+++ /dev/null
@@ -1,429 +0,0 @@
-/**
- * \file
- * \brief ATCA Hardware abstraction layer for Linux using kit protocol over a USB HID device.
- *
- * \copyright (c) 2017 Microchip Technology Inc. and its subsidiaries.
- *            You may use this software and any derivatives exclusively with
- *            Microchip products.
- *
- * \page License
- *
- * (c) 2017 Microchip Technology Inc. and its subsidiaries. You may use this
- * software and any derivatives exclusively with Microchip products.
- *
- * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
- * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
- * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
- * PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
- * WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
- *
- * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
- * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
- * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
- * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
- * FULLEST EXTENT ALLOWED BY LAW, MICROCHIPS TOTAL LIABILITY ON ALL CLAIMS IN
- * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
- * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
- *
- * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
- * TERMS.
- */
-
-#include <libudev.h>
-#include <stdio.h>
-#include <string.h>
-#include <errno.h>
-
-#include "atca_hal.h"
-#include "hal_linux_kit_hid.h"
-#include "hal/kit_protocol.h"
-
-/** \defgroup hal_ Hardware abstraction layer (hal_)
- *
- * \brief
- * These methods define the hardware abstraction layer for communicating with a CryptoAuth device
- *
-   @{ */
-
-// File scope globals
-atcahid_t _gHid;
-
-/** \brief discover hid buses available for this hardware
- * this maintains a list of logical to physical bus mappings freeing the application
- * of the a-priori knowledge.This function is currently not implemented.
- * \param[in] cdc_buses - an array of logical bus numbers
- * \param[in] max_buses - maximum number of buses the app wants to attempt to discover
- * \return ATCA_UNIMPLEMENTED
- */
-
-ATCA_STATUS hal_kit_hid_discover_buses(int hid_buses[], int max_buses)
-{
-    return ATCA_UNIMPLEMENTED;
-}
-
-/** \brief discover any CryptoAuth devices on a given logical bus number.This function is currently not implemented.
- * \param[in] busNum - logical bus number on which to look for CryptoAuth devices
- * \param[out] cfg[] - pointer to head of an array of interface config structures which get filled in by this method
- * \param[out] *found - number of devices found on this bus
- * \return ATCA_UNIMPLEMENTED
- */
-ATCA_STATUS hal_kit_hid_discover_devices(int busNum, ATCAIfaceCfg cfg[], int *found)
-{
-    return ATCA_UNIMPLEMENTED;
-}
-
-/** \brief HAL implementation of Kit USB HID init
- *  \param[in] hal pointer to HAL specific data that is maintained by this HAL
- *  \param[in] cfg pointer to HAL specific configuration data that is used to initialize this HAL
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-ATCA_STATUS hal_kit_hid_init(void* hal, ATCAIfaceCfg* cfg)
-{
-    ATCAHAL_t *phal = (ATCAHAL_t*)hal;
-    int status = 0;
-    struct udev *udev = NULL;
-    struct udev_enumerate *enumerate = NULL;
-    struct udev_list_entry *list = NULL;
-    struct udev_list_entry *list_entry = NULL;
-    struct udev_device *syspath_device = NULL;
-    struct udev_device *device = NULL;
-    int i = 0;
-    char hid_filter[20];
-    char device_hid[20];
-    FILE *file_descriptor = NULL;
-    int index = 0;
-
-    // Check the input variables
-    if ((cfg == NULL) || (phal == NULL))
-    {
-        return ATCA_BAD_PARAM;
-    }
-
-    // Initialize the _gHid structure
-    memset(&_gHid, 0, sizeof(_gHid));
-    for (i = 0; i < HID_DEVICES_MAX; i++)
-    {
-        _gHid.kits[i].read_handle = NULL;
-        _gHid.kits[i].write_handle = NULL;
-    }
-
-    _gHid.num_kits_found = 0;
-
-    // Create the udev object
-    udev = udev_new();
-    if (udev == NULL)
-    {
-        return ATCA_COMM_FAIL;
-    }
-
-    // Create the enumerate object
-    enumerate = udev_enumerate_new(udev);
-    if (enumerate == NULL)
-    {
-        // Free the udev object
-        udev_unref(udev);
-
-        return ATCA_COMM_FAIL;
-    }
-
-    // Create the list of available USB devices
-    status = udev_enumerate_add_match_subsystem(enumerate, "hidraw");
-    if (status >= 0)
-    {
-        status = udev_enumerate_scan_devices(enumerate);
-        if (status >= 0)
-        {
-            list = udev_enumerate_get_list_entry(enumerate);
-        }
-    }
-
-    // Create the HID filter string
-    memset(hid_filter, 0, sizeof(hid_filter));
-    sprintf(hid_filter, "vid_%04x&pid_%04x", cfg->atcahid.vid, cfg->atcahid.pid);
-
-    // Find the available kit USB devices
-    udev_list_entry_foreach(list_entry, list)
-    {
-        // Get the udev device
-        syspath_device = udev_device_new_from_syspath(udev, udev_list_entry_get_name(list_entry));
-        device = udev_device_get_parent_with_subsystem_devtype(syspath_device, "usb", "usb_device");
-
-        // Create the device HID string
-        memset(device_hid, 0, sizeof(device_hid));
-        sprintf(device_hid, "vid_%s&pid_%s",
-                udev_device_get_sysattr_value(device, "idVendor"),
-                udev_device_get_sysattr_value(device, "idProduct"));
-
-        // Determine if this is the correct kit USB device
-        if (strcasecmp(device_hid, hid_filter) == 0)
-        {
-            // Open the kit USB device for reading and writing
-            if (_gHid.kits[index].read_handle != NULL)
-            {
-                fclose(_gHid.kits[index].read_handle);
-            }
-            if (_gHid.kits[index].write_handle != NULL)
-            {
-                fclose(_gHid.kits[index].write_handle);
-            }
-
-            file_descriptor = fopen(udev_device_get_devnode(syspath_device), "rb+");
-            if (file_descriptor != NULL)
-            {
-                _gHid.kits[index].read_handle = file_descriptor;
-                _gHid.kits[index].write_handle = file_descriptor;
-
-                // Increment the opened kit USB device index
-                index++;
-
-#ifdef KIT_DEBUG
-                printf("Kit USB Device Node: %s\n", udev_device_get_devnode(syspath_device));
-                printf("  Manufacturer %s (%s)\n",
-                       udev_device_get_sysattr_value(device, "manufacturer"),
-                       udev_device_get_sysattr_value(device, "product"));
-                printf("  VID/PID:     %s %s\n",
-                       udev_device_get_sysattr_value(device, "idVendor"),
-                       udev_device_get_sysattr_value(device, "idProduct"));
-#endif          // KIT_DEBUG
-            }
-            else
-            {
-#ifdef KIT_DEBUG
-                printf("fopen(\"%s\") failed with errno=%d\n",
-                       udev_device_get_devnode(syspath_device),
-                       errno);
-#endif          // KIT_DEBUG
-            }
-        }
-
-        // Free the udev device object
-        udev_device_unref(syspath_device);
-    }
-
-    // Save the results of this discovery of HID
-    if (index > 0)
-    {
-        _gHid.num_kits_found = index;
-        phal->hal_data = &_gHid;
-    }
-
-    // Free the enumerator object
-    udev_enumerate_unref(enumerate);
-
-    // Free the udev object
-    udev_unref(udev);
-
-    return ATCA_SUCCESS;
-}
-
-/** \brief HAL implementation of Kit HID post init
- *  \param[in] iface  instance
- *  \return ATCA_SUCCESS on success, otherwise an error code.
- */
-ATCA_STATUS hal_kit_hid_post_init(ATCAIface iface)
-{
-    ATCA_STATUS status = ATCA_SUCCESS;
-    atcahid_t* pHid = atgetifacehaldat(iface);
-    ATCAIfaceCfg *pCfg = atgetifacecfg(iface);
-    int i = 0;
-
-    if ((pHid == NULL) || (pCfg == NULL))
-    {
-        return ATCA_BAD_PARAM;
-    }
-
-    // Perform the kit protocol init
-    for (i = 0; i < pHid->num_kits_found; i++)
-    {
-        status = kit_init(iface);
-        if (status != ATCA_SUCCESS)
-        {
-            BREAK(status, "kit_init() Failed");
-        }
-    }
-
-    return status;
-}
-
-/** \brief HAL implementation of send over Kit protocol.This function is called by the top layer.
- *  \param[in] iface     instance
- *  \param[in] txdata    pointer to bytes to send
- *  \param[in] txlength  number of bytes to send
- *  \return ATCA_SUCCESS on success, otherwise an error code.
- */
-ATCA_STATUS kit_phy_send(ATCAIface iface, uint8_t* txdata, int txlength)
-{
-    ATCAIfaceCfg *cfg = atgetifacecfg(iface);
-    atcahid_t* pHid = (atcahid_t*)atgetifacehaldat(iface);
-    size_t bytes_written = 0;
-
-    if ((txdata == NULL) || (cfg == NULL) || (pHid == NULL))
-    {
-        return ATCA_BAD_PARAM;
-    }
-
-    if (pHid->kits[cfg->atcahid.idx].write_handle == NULL)
-    {
-        return ATCA_COMM_FAIL;
-    }
-
-    // Send the data to the kit USB device
-    if (txlength > 0)
-    {
-        bytes_written = fwrite(txdata, sizeof(uint8_t), txlength,
-                               pHid->kits[cfg->atcahid.idx].write_handle);
-        if (bytes_written != txlength)
-        {
-            clearerr(pHid->kits[cfg->atcahid.idx].write_handle);
-            return ATCA_TX_FAIL;
-        }
-    }
-
-    return ATCA_SUCCESS;
-}
-
-/** \brief HAL implementation of kit protocol receive.This function is called by the top layer.
- * \param[in]    iface   instance
- * \param[out]   rxdata  pointer to space to receive the data
- * \param[inout] rxsize  ptr to expected number of receive bytes to request
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-ATCA_STATUS kit_phy_receive(ATCAIface iface, uint8_t* rxdata, int* rxsize)
-{
-    ATCAIfaceCfg *cfg = atgetifacecfg(iface);
-    atcahid_t* pHid = (atcahid_t*)atgetifacehaldat(iface);
-    bool continue_read = true;
-    size_t bytes_read = 0;
-    size_t total_bytes_read = 0;
-
-    if ((rxdata == NULL) || (rxsize == NULL) || (cfg == NULL) || (pHid == NULL))
-    {
-        return ATCA_BAD_PARAM;
-    }
-
-    if (pHid->kits[cfg->atcahid.idx].read_handle == NULL)
-    {
-        return ATCA_COMM_FAIL;
-    }
-
-    // Receive the data from the kit USB device
-    do
-    {
-        bytes_read = fread(&rxdata[total_bytes_read], sizeof(uint8_t), 1,
-                           pHid->kits[cfg->atcahid.idx].read_handle);
-        if (ferror(pHid->kits[cfg->atcahid.idx].read_handle) != 0)
-        {
-            clearerr(pHid->kits[cfg->atcahid.idx].read_handle);
-            return ATCA_RX_FAIL;
-        }
-
-        total_bytes_read += bytes_read;
-
-        // Check if the kit protocol message has been received
-        if (strstr((char*)rxdata, "\n") != NULL)
-        {
-            continue_read = false;
-        }
-    }
-    while (continue_read == true);
-
-    // Save the total bytes read
-    *rxsize = total_bytes_read;
-
-    return ATCA_SUCCESS;
-}
-
-/** \brief Number of USB HID devices found
- *  \param[out] num_found
- *  \return ATCA_SUCCESS on success, otherwise an error code.
- */
-ATCA_STATUS kit_phy_num_found(int8_t* num_found)
-{
-    *num_found = _gHid.num_kits_found;
-
-    return ATCA_SUCCESS;
-}
-
-/** \brief HAL implementation of kit protocol send over USB HID
- *  \param[in] iface     instance
- *  \param[in] txdata    pointer to bytes to send
- *  \param[in] txlength  number of bytes to send
- *  \return ATCA_SUCCESS on success, otherwise an error code.
- */
-ATCA_STATUS hal_kit_hid_send(ATCAIface iface, uint8_t* txdata, int txlength)
-{
-    // Call the kit_send() function that will call phy_send() implemented below
-    return kit_send(iface, txdata, txlength);
-}
-
-/** \brief HAL implementation of send over USB HID
- * \param[in]    iface   instance
- * \param[in]    rxdata  pointer to space to receive the data
- * \param[inout] rxsize  ptr to expected number of receive bytes to request
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-ATCA_STATUS hal_kit_hid_receive(ATCAIface iface, uint8_t* rxdata, uint16_t* rxsize)
-{
-    // Call the kit_receive() function that will call phy_receive() implemented below
-    return kit_receive(iface, rxdata, rxsize);
-}
-
-/** \brief Call the wake for kit protocol over USB HID
- * \param[in] iface  ATCAIface instance that is the interface object to send the bytes over
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-ATCA_STATUS hal_kit_hid_wake(ATCAIface iface)
-{
-    // Call the kit_wake() function that will call phy_send() and phy_receive()
-    return kit_wake(iface);
-}
-
-/** \brief Call the idle for kit protocol over USB HID
- * \param[in] iface  ATCAIface instance that is the interface object to send the bytes over
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-ATCA_STATUS hal_kit_hid_idle(ATCAIface iface)
-{
-    // Call the kit_idle() function that will call phy_send() and phy_receive()
-    return kit_idle(iface);
-}
-
-/** \brief Call the sleep for kit protocol over USB HID
- * \param[in] iface  ATCAIface instance that is the interface object to send the bytes over
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-ATCA_STATUS hal_kit_hid_sleep(ATCAIface iface)
-{
-    // Call the kit_sleep() function that will call phy_send() and phy_receive()
-    return kit_sleep(iface);
-}
-
-/** \brief Close the physical port for HID
- * \param[in] hal_data  The hardware abstraction data specific to this HAL
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-ATCA_STATUS hal_kit_hid_release(void* hal_data)
-{
-    atcahid_t* phaldat = (atcahid_t*)hal_data;
-    int i = 0;
-
-    if (phaldat == NULL)
-    {
-        return ATCA_BAD_PARAM;
-    }
-
-    // Close all kit USB devices
-    for (i = 0; i < phaldat->num_kits_found; i++)
-    {
-        if (_gHid.kits[i].read_handle != NULL)
-        {
-            fclose(_gHid.kits[i].read_handle);
-            _gHid.kits[i].read_handle = NULL;
-            _gHid.kits[i].write_handle = NULL;
-        }
-    }
-
-    return ATCA_SUCCESS;
-}
-
-/** @} */
diff --git a/lib/hal/hal_linux_kit_hid.h b/lib/hal/hal_linux_kit_hid.h
deleted file mode 100644
index 649aab556668..000000000000
--- a/lib/hal/hal_linux_kit_hid.h
+++ /dev/null
@@ -1,62 +0,0 @@
-/**
- * \file
- * \brief ATCA Hardware abstraction layer for Linux using kit protocol over a USB HID device.
- *
- * \copyright (c) 2017 Microchip Technology Inc. and its subsidiaries.
- *            You may use this software and any derivatives exclusively with
- *            Microchip products.
- *
- * \page License
- *
- * (c) 2017 Microchip Technology Inc. and its subsidiaries. You may use this
- * software and any derivatives exclusively with Microchip products.
- *
- * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
- * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
- * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
- * PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
- * WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
- *
- * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
- * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
- * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
- * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
- * FULLEST EXTENT ALLOWED BY LAW, MICROCHIPS TOTAL LIABILITY ON ALL CLAIMS IN
- * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
- * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
- *
- * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
- * TERMS.
- */
-
-#ifndef HAL_LINUX_KIT_HID_H_
-#define HAL_LINUX_KIT_HID_H_
-
-/** \defgroup hal_ Hardware abstraction layer (hal_)
- *
- * \brief
- * These methods define the hardware abstraction layer for communicating with a CryptoAuth device
- *
-   @{ */
-
-// Kit USB defines
-#define HID_DEVICES_MAX     10      //! Maximum number of supported Kit USB devices
-#define HID_PACKET_MAX      512     //! Maximum number of bytes for a HID send/receive packet (typically 64)
-
-// Each device that is found will have a read handle and a write handle
-typedef struct hid_device
-{
-    FILE *read_handle;         //! The kit USB read file handle
-    FILE *write_handle;        //! The kit USB write file handle
-} hid_device_t;
-
-
-// A structure to hold HID information
-typedef struct atcahid
-{
-    hid_device_t kits[HID_DEVICES_MAX];
-    int8_t       num_kits_found;
-} atcahid_t;
-
-/** @} */
-#endif /* HAL_LINUX_KIT_HID_H_ */
diff --git a/lib/hal/hal_pic32mx695f512h_i2c.c b/lib/hal/hal_pic32mx695f512h_i2c.c
deleted file mode 100644
index 730d782d7e51..000000000000
--- a/lib/hal/hal_pic32mx695f512h_i2c.c
+++ /dev/null
@@ -1,510 +0,0 @@
-/**
- * \file
- * \brief ATCA Hardware abstraction layer for PIC32MX695F512H I2C over plib drivers.
- *
- * This code is structured in two parts.  Part 1 is the connection of the ATCA HAL API to the physical I2C
- * implementation. Part 2 is the xxx I2C primitives to set up the interface.
- *
- * Prerequisite:
- *
- * \copyright (c) 2017 Microchip Technology Inc. and its subsidiaries.
- *            You may use this software and any derivatives exclusively with
- *            Microchip products.
- *
- * \page License
- *
- * (c) 2017 Microchip Technology Inc. and its subsidiaries. You may use this
- * software and any derivatives exclusively with Microchip products.
- *
- * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
- * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
- * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
- * PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
- * WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
- *
- * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
- * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
- * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
- * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
- * FULLEST EXTENT ALLOWED BY LAW, MICROCHIPS TOTAL LIABILITY ON ALL CLAIMS IN
- * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
- * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
- *
- * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
- * TERMS.
- */
-
-#include <plib.h>
-#include <stdio.h>
-#include <string.h>
-
-#include "hal/atca_hal.h"
-#include "hal/hal_pic32mx695f512h_i2c.h"
-
-
-/**
- * \defgroup hal_ Hardware abstraction layer (hal_)
- *
- * \brief
- * These methods define the hardware abstraction layer for communicating with a CryptoAuth device
- *
-   @{ */
-
-/**
- * \brief
- * Logical to physical bus mapping structure
- */
-ATCAI2CMaster_t *i2c_hal_data[MAX_I2C_BUSES];   // map logical, 0-based bus number to index
-int i2c_bus_ref_ct = 0;                         // total in-use count across buses
-//twi_options_t opt_twi_master;
-
-
-/****** I2C Driver implementation *******/
-static bool StartTransfer(I2C_MODULE i2c_id, bool restart)
-{
-    I2C_STATUS status;
-
-    // Send the Start (or Restart) signal
-    if (restart)
-    {
-        I2CRepeatStart(i2c_id);
-    }
-    else
-    {
-        // Wait for the bus to be idle, then start the transfer
-        while (!I2CBusIsIdle(i2c_id))
-        {
-            ;
-        }
-
-        if (I2CStart(i2c_id) != I2C_SUCCESS)
-        {
-            //DBPRINTF("Error: Bus collision during transfer Start\n");
-            return FALSE;
-        }
-    }
-
-    // Wait for the signal to complete
-    do
-    {
-        status = I2CGetStatus(i2c_id);
-    }
-
-    while (!(status & I2C_START));
-
-    return TRUE;
-}
-
-static bool TransmitOneByte(I2C_MODULE i2c_id, uint8_t data)
-{
-    // Wait for the transmitter to be ready
-    while (!I2CTransmitterIsReady(i2c_id))
-    {
-        ;
-    }
-
-    // Transmit the byte
-    if (I2CSendByte(i2c_id, data) == I2C_MASTER_BUS_COLLISION)
-    {
-        //DBPRINTF("Error: I2C Master Bus Collision\n");
-        return FALSE;
-    }
-
-    // Wait for the transmission to finish
-    while (!I2CTransmissionHasCompleted(i2c_id))
-    {
-        ;
-    }
-
-    return TRUE;
-}
-
-static uint8_t ReceiveOneByte(I2C_MODULE i2c_id, bool ack)
-{
-    uint8_t data;
-
-    // Enable I2C receive
-    I2CReceiverEnable(i2c_id, TRUE);
-
-    // Wait until 1-byte is fully received
-    while (!I2CReceivedDataIsAvailable(i2c_id))
-    {
-        ;
-    }
-
-    // Save the byte received
-    data = I2CGetByte(i2c_id);
-
-    // Perform acknowledgement sequence
-    I2CAcknowledgeByte(i2c_id, ack);
-
-    // Wait until acknowledgement is successfully sent
-    while (!I2CAcknowledgeHasCompleted(i2c_id))
-    {
-        ;
-    }
-
-    return data;
-}
-
-static void StopTransfer(I2C_MODULE i2c_id)
-{
-    I2C_STATUS status;
-
-    // Send the Stop signal
-    I2CStop(i2c_id);
-
-    // Wait for the signal to complete
-    do
-    {
-        status = I2CGetStatus(i2c_id);
-    }
-
-    while (!(status & I2C_STOP));
-}
-
-void i2c_write(I2C_MODULE i2c_id, uint8_t address, uint8_t *data, int len)
-{
-    uint8_t i2cBuffer[len + 1];
-    int i;
-
-    i2cBuffer[0] = address | 0x00;
-    memcpy(&i2cBuffer[1], data, len);
-
-    if (!StartTransfer(i2c_id, FALSE))
-    {
-        return;
-    }
-    for (i = 0; i < len + 1; i++)
-    {
-        if (!TransmitOneByte(i2c_id, i2cBuffer[i]))
-        {
-            break;
-        }
-    }
-
-    StopTransfer(i2c_id);
-}
-
-void i2c_read(I2C_MODULE i2c_id, uint8_t address, uint8_t *data, uint16_t len)
-{
-    uint16_t i;
-
-    if (!StartTransfer(i2c_id, FALSE))
-    {
-        return;
-    }
-
-    if (!TransmitOneByte(i2c_id, (address | 0x01)))
-    {
-        return;
-    }
-
-    for (i = 0; i < len; i++)
-    {
-        if (i < len - 1) // send ACK
-        {
-            data[i] = ReceiveOneByte(i2c_id, TRUE);
-        }
-        else             // send NACK
-        {
-            data[i] = ReceiveOneByte(i2c_id, FALSE);
-        }
-    }
-
-    StopTransfer(i2c_id);
-}
-/****************************************/
-
-
-/**
- * \brief
- * This HAL implementation assumes you've included the Plib libraries in your project, otherwise,
- * the HAL layer will not compile because the Plib drivers are a dependency
- */
-
-/** \brief discover i2c buses available for this hardware
- * this maintains a list of logical to physical bus mappings freeing the application
- * of the a-priori knowledge.This function is currently not implemented.
- * \param[in] i2c_buses - an array of logical bus numbers
- * \param[in] max_buses - maximum number of buses the app wants to attempt to discover
- * \return ATCA_UNIMPLEMENTED
- */
-ATCA_STATUS hal_i2c_discover_buses(int i2c_buses[], int max_buses)
-{
-    return ATCA_UNIMPLEMENTED;
-}
-
-/** \brief discover any CryptoAuth devices on a given logical bus number.This function is currently not implemented.
- * \param[in] busNum - logical bus number on which to look for CryptoAuth devices
- * \param[out] cfg[] - pointer to head of an array of interface config structures which get filled in by this method
- * \param[out] *found - number of devices found on this bus
- * \return ATCA_UNIMPLEMENTED
- */
-ATCA_STATUS hal_i2c_discover_devices(int busNum, ATCAIfaceCfg cfg[], int *found)
-{
-    return ATCA_UNIMPLEMENTED;
-}
-
-/**
- * \brief
- * hal_i2c_init manages requests to initialize a physical interface. It manages use counts so when an interface
- * has released the physical layer, it will disable the interface for some other use.
- * You can have multiple ATCAIFace instances using the same bus, and you can have multiple ATCAIFace instances on
- * multiple i2c buses, so hal_i2c_init manages these things and ATCAIFace is abstracted from the physical details.
- */
-
-/**
- * \brief initialize an I2C interface using given config
- *
- * \param[in] hal - opaque ptr to HAL data
- * \param[in] cfg - interface configuration
- *
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-ATCA_STATUS hal_i2c_init(void *hal, ATCAIfaceCfg *cfg)
-{
-    int bus = cfg->atcai2c.bus; // 0-based logical bus number
-    int i;
-    ATCAHAL_t *phal = (ATCAHAL_t*)hal;
-
-    if (i2c_bus_ref_ct == 0)    // power up state, no i2c buses will have been used
-
-    {
-        for (i = 0; i < MAX_I2C_BUSES; i++)
-        {
-            i2c_hal_data[i] = NULL;
-        }
-    }
-
-    i2c_bus_ref_ct++;   // total across buses
-
-    if (bus >= 0 && bus < MAX_I2C_BUSES)
-    {
-        //// if this is the first time this bus and interface has been created, do the physical work of enabling it
-        if (i2c_hal_data[bus] == NULL)
-        {
-            i2c_hal_data[bus] = malloc(sizeof(ATCAI2CMaster_t));
-            i2c_hal_data[bus]->ref_ct = 1;  // buses are shared, this is the first instance
-
-            switch (bus)
-            {
-//            case 0:
-//                i2c_hal_data[bus]->id = I2C0;
-//                break;
-            case 1:
-                i2c_hal_data[bus]->id = I2C1;
-                break;
-//            case 2:
-//                i2c_hal_data[bus]->id = I2C2;
-//                break;
-            case 3:
-                i2c_hal_data[bus]->id = I2C3;
-                break;
-            }
-
-            // Set the I2C baudrate
-            I2CSetFrequency(i2c_hal_data[bus]->id, GetPeripheralClock(), cfg->atcai2c.baud);
-
-            // Enable the I2C bus
-            I2CEnable(i2c_hal_data[bus]->id, TRUE);
-
-            // store this for use during the release phase
-            i2c_hal_data[bus]->bus_index = bus;
-        }
-        else
-        {
-            // otherwise, another interface already initialized the bus, so this interface will share it and any different
-            // cfg parameters will be ignored...first one to initialize this sets the configuration
-            i2c_hal_data[bus]->ref_ct++;
-        }
-
-        phal->hal_data = i2c_hal_data[bus];
-
-        return ATCA_SUCCESS;
-    }
-
-    return ATCA_COMM_FAIL;
-}
-
-/**
- * \brief HAL implementation of I2C post init
- *
- * \param[in] iface  instance
- *
- * \return ATCA_SUCCESS
- */
-ATCA_STATUS hal_i2c_post_init(ATCAIface iface)
-{
-    return ATCA_SUCCESS;
-}
-
-/**
- * \brief HAL implementation of I2C send over ASF
- *
- * \param[in] iface     instance
- * \param[in] txdata    pointer to space to bytes to send
- * \param[in] txlength  number of bytes to send
- *
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-ATCA_STATUS hal_i2c_send(ATCAIface iface, uint8_t *txdata, int txlength)
-{
-    ATCAIfaceCfg *cfg = atgetifacecfg(iface);
-    int bus = cfg->atcai2c.bus;
-
-    txdata[0] = 0x03;   // insert the Word Address Value, Command token
-    txlength++;         // account for word address value byte.
-
-    i2c_write(i2c_hal_data[bus]->id, cfg->atcai2c.slave_address, txdata, txlength);
-
-    return ATCA_SUCCESS;
-}
-
-/**
- * \brief HAL implementation of I2C receive function for ASF I2C
- *
- * \param[in] iface     instance
- * \param[in] rxdata    pointer to space to receive the data
- * \param[in] rxlength  ptr to expected number of receive bytes to request
- *
- * \return ATCA_SUCCESS
- */
-ATCA_STATUS hal_i2c_receive(ATCAIface iface, uint8_t *rxdata, uint16_t *rxlength)
-{
-    ATCAIfaceCfg *cfg = atgetifacecfg(iface);
-    int bus = cfg->atcai2c.bus;
-
-    i2c_read(i2c_hal_data[bus]->id, cfg->atcai2c.slave_address, rxdata, *rxlength);
-
-    return ATCA_SUCCESS;
-}
-
-/**
- * \brief method to change the bus speed of I2C
- *
- * \param[in] iface  interface on which to change bus speed
- * \param[in] speed  baud rate (typically 100000 or 400000)
- */
-void change_i2c_speed(ATCAIface iface, uint32_t speed)
-{
-    ATCAIfaceCfg *cfg = atgetifacecfg(iface);
-    int bus = cfg->atcai2c.bus;
-
-    // Disable the I2C bus
-    I2CEnable(i2c_hal_data[bus]->id, FALSE);
-
-    // Set the I2C baudrate
-    I2CSetFrequency(i2c_hal_data[bus]->id, GetPeripheralClock(), speed);
-
-    // Enable the I2C bus
-    I2CEnable(i2c_hal_data[bus]->id, TRUE);
-}
-
-/**
- * \brief wake up CryptoAuth device using I2C bus
- *
- * \param[in] iface  interface to logical device to wakeup
- *
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-ATCA_STATUS hal_i2c_wake(ATCAIface iface)
-{
-    ATCAIfaceCfg *cfg = atgetifacecfg(iface);
-    int bus = cfg->atcai2c.bus;
-    uint32_t bdrt = cfg->atcai2c.baud;
-
-    uint8_t data[4], expected[4] = { 0x04, 0x11, 0x33, 0x43 };
-
-    if (bdrt != 100000)     // if not already at 100KHz, change it
-    {
-        change_i2c_speed(iface, 100000);
-    }
-
-    // Send 0x00 as wake pulse
-    i2c_write(i2c_hal_data[bus]->id, 0x00, NULL, NULL);
-
-    atca_delay_ms(3);   // wait tWHI + tWLO which is configured based on device type and configuration structure
-    //atca_delay_us(cfg->wake_delay);
-
-    // if necessary, revert baud rate to what came in.
-    if (bdrt != 100000)
-    {
-        change_i2c_speed(iface, cfg->atcai2c.baud);
-    }
-
-    i2c_read(i2c_hal_data[bus]->id, cfg->atcai2c.slave_address, data, 4);
-
-    if (memcmp(data, expected, 4) == 0)
-    {
-        return ATCA_SUCCESS;
-    }
-
-    return ATCA_COMM_FAIL;
-}
-
-/**
- * \brief idle CryptoAuth device using I2C bus
- *
- * \param[in] iface  interface to logical device to idle
- *
- * \return ATCA_SUCCESS
- */
-ATCA_STATUS hal_i2c_idle(ATCAIface iface)
-{
-    ATCAIfaceCfg *cfg = atgetifacecfg(iface);
-    int bus = cfg->atcai2c.bus;
-    uint8_t data[4];
-
-    data[0] = 0x02; // idle word address value
-
-    i2c_write(i2c_hal_data[bus]->id, cfg->atcai2c.slave_address, data, 1);
-
-    return ATCA_SUCCESS;
-}
-
-/**
- * \brief sleep CryptoAuth device using I2C bus
- *
- * \param[in] iface  interface to logical device to sleep
- *
- * \return ATCA_SUCESS
- */
-ATCA_STATUS hal_i2c_sleep(ATCAIface iface)
-{
-    ATCAIfaceCfg *cfg = atgetifacecfg(iface);
-    int bus = cfg->atcai2c.bus;
-    uint8_t data[4];
-
-    data[0] = 0x01; // idle word address value
-
-    i2c_write(i2c_hal_data[bus]->id, cfg->atcai2c.slave_address, data, 1);
-
-    return ATCA_SUCCESS;
-}
-
-/**
- * \brief manages reference count on given bus and releases resource if no more refences exist
- *
- * \param[in] hal_data - opaque pointer to hal data structure - known only to the HAL implementation
- *
- * \return ATCA_SUCESS
- */
-ATCA_STATUS hal_i2c_release(void *hal_data)
-{
-    ATCAI2CMaster_t *hal = (ATCAI2CMaster_t*)hal_data;
-
-    i2c_bus_ref_ct--;  // track total i2c bus interface instances for consistency checking and debugging
-
-    // if the use count for this bus has gone to 0 references, disable it.  protect against an unbracketed release
-    if (hal && --(hal->ref_ct) <= 0 && i2c_hal_data[hal->bus_index] != NULL)
-    {
-        I2CEnable(hal->id, FALSE);
-        free(i2c_hal_data[hal->bus_index]);
-        i2c_hal_data[hal->bus_index] = NULL;
-    }
-
-    return ATCA_SUCCESS;
-}
-
-/** @} */
\ No newline at end of file
diff --git a/lib/hal/hal_pic32mx695f512h_i2c.h b/lib/hal/hal_pic32mx695f512h_i2c.h
deleted file mode 100644
index 1b242168b43d..000000000000
--- a/lib/hal/hal_pic32mx695f512h_i2c.h
+++ /dev/null
@@ -1,74 +0,0 @@
-/**
- * \file
- * \brief ATCA Hardware abstraction layer for PIC32MX695F512H I2C over xxx drivers.
- *
- * This code is structured in two parts.  Part 1 is the connection of the ATCA HAL API to the physical I2C
- * implementation. Part 2 is the xxx I2C primitives to set up the interface.
- *
- * Prerequisite:
- *
- * \copyright (c) 2017 Microchip Technology Inc. and its subsidiaries.
- *            You may use this software and any derivatives exclusively with
- *            Microchip products.
- *
- * \page License
- *
- * (c) 2017 Microchip Technology Inc. and its subsidiaries. You may use this
- * software and any derivatives exclusively with Microchip products.
- *
- * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
- * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
- * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
- * PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
- * WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
- *
- * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
- * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
- * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
- * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
- * FULLEST EXTENT ALLOWED BY LAW, MICROCHIPS TOTAL LIABILITY ON ALL CLAIMS IN
- * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
- * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
- *
- * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
- * TERMS.
- */
-
-#ifndef HAL_PIC32MX695F512H_I2C_ASF_H_
-#define HAL_PIC32MX695F512H_I2C_ASF_H_
-
-
-/**
- * \defgroup hal_ Hardware abstraction layer (hal_)
- *
- * \brief
- * These methods define the hardware abstraction layer for communicating with a CryptoAuth device
- *
-   @{ */
-
-// Clock Constants
-#define GetSystemClock()        (80000000ul)
-#define GetPeripheralClock()    (GetSystemClock() / (1 << OSCCONbits.PBDIV))
-#define GetInstructionClock()   (GetSystemClock())
-
-#define MAX_I2C_BUSES           4   // PIC32MX695F512H has 4 TWI
-
-/**
- * \brief this is the hal_data for ATCA HAL
- */
-typedef struct atcaI2Cmaster
-{
-    I2C_MODULE id;
-    int        ref_ct;
-    // for conveniences during interface release phase
-    int bus_index;
-} ATCAI2CMaster_t;
-
-void i2c_write(I2C_MODULE i2c_id, uint8_t address, uint8_t *data, int len);
-void i2c_read(I2C_MODULE i2c_id, uint8_t address, uint8_t *data, uint16_t len);
-
-void change_i2c_speed(ATCAIface iface, uint32_t speed);
-
-/** @} */
-
-#endif  /* HAL_PIC32MX695F512H_I2C_ASF_H_ */
\ No newline at end of file
diff --git a/lib/hal/hal_pic32mx695f512h_timer.c b/lib/hal/hal_pic32mx695f512h_timer.c
deleted file mode 100644
index b4963d2d31a8..000000000000
--- a/lib/hal/hal_pic32mx695f512h_timer.c
+++ /dev/null
@@ -1,106 +0,0 @@
-/**
- * \file
- * \brief ATCA Hardware abstraction layer for PIC32MX695F512H timer/delay routine
- *
- *
- * \copyright (c) 2017 Microchip Technology Inc. and its subsidiaries.
- *            You may use this software and any derivatives exclusively with
- *            Microchip products.
- *
- * \page License
- *
- * (c) 2017 Microchip Technology Inc. and its subsidiaries. You may use this
- * software and any derivatives exclusively with Microchip products.
- *
- * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
- * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
- * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
- * PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
- * WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
- *
- * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
- * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
- * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
- * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
- * FULLEST EXTENT ALLOWED BY LAW, MICROCHIPS TOTAL LIABILITY ON ALL CLAIMS IN
- * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
- * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
- *
- * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
- * TERMS.
- */
-
-#include <plib.h>
-
-#include "hal/atca_hal.h"
-
-
-/* ASF already have delay_us and delay_ms - see delay.h */
-
-/**
- * \defgroup hal_ Hardware abstraction layer (hal_)
- *
- * \brief
- * These methods define the hardware abstraction layer for communicating with a CryptoAuth device
- *
-   @{ */
-
-
-
-#define CPU_CLOCK (80000000UL)
-#define us_SCALE   ((CPU_CLOCK / 2) / 1000000)
-
-
-void delay_us(UINT32 delay)
-{
-    UINT32 startCnt = ReadCoreTimer();
-    UINT32 waitCnt = delay * us_SCALE;
-
-    while ((ReadCoreTimer() - startCnt) < waitCnt)
-    {
-        ;
-    }
-
-}
-
-
-
-
-/****************************************/
-
-/**
- * \brief This function delays for a number of microseconds.
- *
- * \param[in] delay number of 0.001 milliseconds to delay
- */
-void atca_delay_us(uint32_t delay)
-{
-    delay_us(delay);
-}
-
-/**
- * \brief This function delays for a number of tens of microseconds.
- *
- * \param[in] delay number of 0.01 milliseconds to delay
- */
-void atca_delay_10us(uint32_t delay)
-{
-    atca_delay_us(delay * 10);
-}
-
-/**
- * \brief This function delays for a number of milliseconds.
- *
- *        You can override this function if you like to do
- *        something else in your system while delaying.
- *
- * \param[in] delay number of milliseconds to delay
- */
-void atca_delay_ms(uint32_t delay)
-{
-
-    atca_delay_us(delay * 1000);
-
-}
-
-/** @} */
\ No newline at end of file
diff --git a/lib/hal/hal_sam4s_i2c_asf.c b/lib/hal/hal_sam4s_i2c_asf.c
deleted file mode 100644
index 619de4d1b6a4..000000000000
--- a/lib/hal/hal_sam4s_i2c_asf.c
+++ /dev/null
@@ -1,667 +0,0 @@
-/**
- * \file
- * \brief ATCA Hardware abstraction layer for SAM4S I2C over ASF drivers.
- *
- * This code is structured in two parts.  Part 1 is the connection of the ATCA HAL API to the physical I2C
- * implementation. Part 2 is the ASF I2C primitives to set up the interface.
- *
- * Prerequisite: add "TWI - Two-Wire Interface (Common API) (service)" module to application in Atmel Studio
- *
- * \copyright (c) 2017 Microchip Technology Inc. and its subsidiaries.
- *            You may use this software and any derivatives exclusively with
- *            Microchip products.
- *
- * \page License
- *
- * (c) 2017 Microchip Technology Inc. and its subsidiaries. You may use this
- * software and any derivatives exclusively with Microchip products.
- *
- * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
- * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
- * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
- * PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
- * WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
- *
- * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
- * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
- * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
- * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
- * FULLEST EXTENT ALLOWED BY LAW, MICROCHIPS TOTAL LIABILITY ON ALL CLAIMS IN
- * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
- * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
- *
- * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
- * TERMS.
- */
-
-#include <asf.h>
-#include <string.h>
-#include <stdio.h>
-#include "atca_hal.h"
-#include "hal_sam4s_i2c_asf.h"
-#include "atca_device.h"
-
-
-
-//!< Uncomment when debugging
-/*#define DEBUG_HAL*/
-
-/**
- * \defgroup hal_ Hardware abstraction layer (hal_)
- *
- * \brief
- * These methods define the hardware abstraction layer for communicating with a CryptoAuth device
- * using I2C driver of ASF.
- *
-   @{ */
-
-/**
- * \brief
- * Logical to physical bus mapping structure
- */
-ATCAI2CMaster_t *i2c_hal_data[MAX_I2C_BUSES];   // map logical, 0-based bus number to index
-int i2c_bus_ref_ct = 0;                         // total in-use count across buses
-twi_master_options_t opt_twi_master;
-
-
-#ifdef DEBUG_HAL
-static void print_array(uint8_t *data, uint32_t data_size)
-{
-    uint32_t n;
-
-    for (n = 0; n < data_size; n++)
-    {
-        printf("%.2x ", data[n]);
-        if (((n + 1) % 16) == 0)
-        {
-            printf("\r\n");
-            if ((n + 1) != data_size)
-            {
-                printf("         ");
-            }
-        }
-    }
-    if (data_size % 16 != 0)
-    {
-        printf("\r\n");
-    }
-}
-#endif
-
-/**
- * \brief
- * This HAL implementation assumes you've included the ASF TWI libraries in your project, otherwise,
- * the HAL layer will not compile because the ASF TWI drivers are a dependency
- */
-
-/** \brief discover i2c buses available for this hardware
- * this maintains a list of logical to physical bus mappings freeing the application
- * of the a-priori knowledge
- * \param[in] i2c_buses - an array of logical bus numbers
- * \param[in] max_buses - maximum number of buses the app wants to attempt to discover
- * \return ATCA_SUCCESS
- */
-
-ATCA_STATUS hal_i2c_discover_buses(int i2c_buses[], int max_buses)
-{
-    /* logical bus numbers 0-2 map to the SAM4S i2c buses:
-       ID_TWI0
-       ID_TWI1
-
-        TWS0 bus will respond on the SAM4S Xplained Pro board
-
-     */
-    int i;
-
-    i2c_buses[0] = 0;
-#if MAX_I2C_BUSES == 2
-    i2c_buses[1] = -1;
-#endif
-    return ATCA_SUCCESS;
-
-}
-
-/** \brief discover any CryptoAuth devices on a given logical bus number
- * \param[in] busNum - logical bus number on which to look for CryptoAuth devices
- * \param[out] cfg[] - pointer to head of an array of interface config structures which get filled in by this method
- * \param[out] *found - number of devices found on this bus
- * \return ATCA_SUCCESS
- */
-
-ATCA_STATUS hal_i2c_discover_devices(int busNum, ATCAIfaceCfg cfg[], int *found)
-{
-    ATCAIfaceCfg *head = cfg;
-    uint8_t slaveAddress = 0x01;
-    ATCADevice device;
-    ATCAIface discoverIface;
-    ATCACommand command;
-    ATCAPacket packet;
-    ATCA_STATUS status;
-    uint8_t revs508[1][4] = { { 0x00, 0x00, 0x50, 0x00 } };
-    uint8_t revs108[1][4] = { { 0x80, 0x00, 0x10, 0x01 } };
-    uint8_t revs204[3][4] = { { 0x00, 0x02, 0x00, 0x08 },
-                              { 0x00, 0x02, 0x00, 0x09 },
-                              { 0x00, 0x04, 0x05, 0x00 } };
-    int i;
-
-    /** \brief default configuration, to be reused during discovery process */
-    ATCAIfaceCfg discoverCfg = {
-        .iface_type             = ATCA_I2C_IFACE,
-        .devtype                = ATECC508A,
-        .atcai2c.slave_address  = 0x07,
-        .atcai2c.bus            = busNum,
-        .atcai2c.baud           = 400000,
-        .wake_delay             = 800,
-        .rx_retries             = 3
-    };
-
-    ATCAHAL_t hal;
-
-    if (busNum < 0)
-    {
-        return ATCA_COMM_FAIL;
-    }
-
-    hal_i2c_init(&hal, &discoverCfg);
-    device = newATCADevice(&discoverCfg);
-    discoverIface = atGetIFace(device);
-    command = atGetCommands(device);
-
-    // iterate through all addresses on given i2c bus
-    // all valid 7-bit addresses go from 0x07 to 0x78
-    for (slaveAddress = 0x07; slaveAddress <= 0x78; slaveAddress++)
-    {
-        discoverCfg.atcai2c.slave_address = slaveAddress << 1;  // turn it into an 8-bit address which is what the rest of the i2c HAL is expecting when a packet is sent
-
-        // wake up device
-        // If it wakes, send it a dev rev command.  Based on that response, determine the device type
-        // BTW - this will wake every cryptoauth device living on the same bus (ecc508a, sha204a)
-
-        if (hal_i2c_wake(discoverIface) == ATCA_SUCCESS)
-        {
-            (*found)++;
-            memcpy( (uint8_t*)head, (uint8_t*)&discoverCfg, sizeof(ATCAIfaceCfg));
-
-            memset(packet.data, 0x00, sizeof(packet.data));
-
-            // get devrev info and set device type accordingly
-            atInfo(command, &packet);
-            if ((status = atGetExecTime(packet.opcode, command)) != ATCA_SUCCESS)
-            {
-                continue;
-            }
-
-            // send the command
-            if ( (status = atsend(discoverIface, (uint8_t*)&packet, packet.txsize)) != ATCA_SUCCESS)
-            {
-                printf("packet send error\r\n");
-                continue;
-            }
-
-            // delay the appropriate amount of time for command to execute
-            atca_delay_ms((command->execution_time_msec) + 1);
-
-            // receive the response
-            if ( (status = atreceive(discoverIface, &(packet.data[0]), &(packet.rxsize) )) != ATCA_SUCCESS)
-            {
-                continue;
-            }
-
-            if ( (status = isATCAError(packet.data)) != ATCA_SUCCESS)
-            {
-                continue;
-            }
-
-            // determine device type from common info and dev rev response byte strings
-            for (i = 0; i < (int)sizeof(revs508) / 4; i++)
-            {
-                if (memcmp(&packet.data[1], &revs508[i], 4) == 0)
-                {
-                    discoverCfg.devtype = ATECC508A;
-                    break;
-                }
-            }
-
-            for (i = 0; i < (int)sizeof(revs204) / 4; i++)
-            {
-                if (memcmp(&packet.data[1], &revs204[i], 4) == 0)
-                {
-                    discoverCfg.devtype = ATSHA204A;
-                    break;
-                }
-            }
-
-            for (i = 0; i < (int)sizeof(revs108) / 4; i++)
-            {
-                if (memcmp(&packet.data[1], &revs108[i], 4) == 0)
-                {
-                    discoverCfg.devtype = ATECC108A;
-                    break;
-                }
-            }
-
-            atca_delay_ms(15);
-            // now the device type is known, so update the caller's cfg array element with it
-            head->devtype = discoverCfg.devtype;
-            head++;
-        }
-
-        hal_i2c_idle(discoverIface);
-    }
-
-    //hal_i2c_release(&hal);
-
-    return ATCA_SUCCESS;
-}
-
-/**
- * \brief
- * hal_i2c_init manages requests to initialize a physical interface. It manages use counts so when an interface
- * has released the physical layer, it will disable the interface for some other use.
- * You can have multiple ATCAIFace instances using the same bus, and you can have multiple ATCAIFace instances on
- * multiple i2c buses, so hal_i2c_init manages these things and ATCAIFace is abstracted from the physical details.
- */
-
-/**
- * \brief initialize an I2C interface using given config
- *
- * \param[in] hal - opaque ptr to HAL data
- * \param[in] cfg - interface configuration
- *
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-ATCA_STATUS hal_i2c_init(void *hal, ATCAIfaceCfg *cfg)
-{
-    // set to default i2c bus
-    if (cfg->atcai2c.bus > MAX_I2C_BUSES - 1)
-    {
-        cfg->atcai2c.bus = 0;
-    }
-    int bus = cfg->atcai2c.bus; // 0-based logical bus number
-    ATCAHAL_t *phal = (ATCAHAL_t*)hal;
-
-    if (i2c_bus_ref_ct == 0)    // power up state, no i2c buses will have been used
-
-    {
-        for (int i = 0; i < MAX_I2C_BUSES; i++)
-        {
-            i2c_hal_data[i] = NULL;
-        }
-    }
-
-    i2c_bus_ref_ct++;   // total across buses
-
-    if (bus >= 0 && bus < MAX_I2C_BUSES)
-    {
-        // if this is the first time this bus and interface has been created, do the physical work of enabling it
-        if (i2c_hal_data[bus] == NULL)
-        {
-            i2c_hal_data[bus] = malloc(sizeof(ATCAI2CMaster_t));
-            i2c_hal_data[bus]->ref_ct = 1;  // buses are shared, this is the first instance
-
-            switch (bus)
-            {
-            case 0:
-                i2c_hal_data[bus]->twi_id = ID_TWI0;
-                i2c_hal_data[bus]->twi_master_instance = TWI0;
-                break;
-            case 1:
-                i2c_hal_data[bus]->twi_id = ID_TWI1;
-                i2c_hal_data[bus]->twi_master_instance = TWI1;
-                // configure TWI1 pins
-                gpio_configure_pin(PIO_PB4_IDX, (PIO_PERIPH_A | PIO_PULLUP));
-                gpio_configure_pin(PIO_PB5_IDX, (PIO_PERIPH_A | PIO_PULLUP));
-                // disable JTAG
-                MATRIX->CCFG_SYSIO |= (1 << 4) | (1 << 5);
-                break;
-            }
-
-            pmc_enable_periph_clk(i2c_hal_data[bus]->twi_id);
-
-            opt_twi_master.master_clk = sysclk_get_cpu_hz();
-            opt_twi_master.speed = cfg->atcai2c.baud;
-            opt_twi_master.smbus = 0;
-
-            twi_master_init(i2c_hal_data[bus]->twi_master_instance, &opt_twi_master);
-
-            // store this for use during the release phase
-            i2c_hal_data[bus]->bus_index = bus;
-        }
-        else
-        {
-            // otherwise, another interface already initialized the bus, so this interface will share it and any different
-            // cfg parameters will be ignored...first one to initialize this sets the configuration
-            i2c_hal_data[bus]->ref_ct++;
-        }
-
-        phal->hal_data = i2c_hal_data[bus];
-
-        return ATCA_SUCCESS;
-    }
-
-    return ATCA_COMM_FAIL;
-}
-
-/**
- * \brief HAL implementation of I2C post init
- *
- * \param[in] iface  instance
- *
- * \return ATCA_SUCCESS
- */
-ATCA_STATUS hal_i2c_post_init(ATCAIface iface)
-{
-    return ATCA_SUCCESS;
-}
-
-/**
- * \brief HAL implementation of I2C send over ASF
- *
- * \param[in] iface     instance
- * \param[in] txdata    pointer to space to bytes to send
- * \param[in] txlength  number of bytes to send
- *
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-ATCA_STATUS hal_i2c_send(ATCAIface iface, uint8_t *txdata, int txlength)
-{
-#ifdef DEBUG_HAL
-    printf("hal_i2c_send()\r\n");
-
-    printf("\r\nCommand Packet (size:0x%.8x)\r\n", (uint32_t)txlength);
-    printf("Count  : %.2x\r\n", txdata[1]);
-    printf("Opcode : %.2x\r\n", txdata[2]);
-    printf("Param1 : %.2x\r\n", txdata[3]);
-    printf("Param2 : "); print_array(&txdata[4], 2);
-    if (txdata[1] > 7)
-    {
-        printf("Data   : "); print_array(&txdata[6], txdata[1] - 7);
-    }
-    printf("CRC    : "); print_array(&txdata[txdata[1] - 1], 2);
-    printf("\r\n");
-#endif
-
-    ATCAIfaceCfg *cfg = atgetifacecfg(iface);
-    // set to default i2c bus
-    if (cfg->atcai2c.bus > MAX_I2C_BUSES - 1)
-    {
-        cfg->atcai2c.bus = 0;
-    }
-    int bus = cfg->atcai2c.bus;
-
-    txdata[0] = 0x03;   // insert the Word Address Value, Command token
-    txlength++;         // account for word address value byte.
-
-    twi_package_t packet = {
-        .chip           = cfg->atcai2c.slave_address >> 1,
-        .addr           = { 0 },
-        .addr_length    = 0,
-        .buffer         = (void*)txdata,
-        .length         = (uint32_t)txlength //(uint32_t)txdata[1]
-    };
-
-    // for this implementation of I2C with CryptoAuth chips, txdata is assumed to have ATCAPacket format
-
-    // other device types that don't require i/o tokens on the front end of a command need a different hal_i2c_send and wire it up instead of this one
-    // this covers devices such as ATSHA204A and ATECCx08A that require a word address value pre-pended to the packet
-
-    if (twi_master_write(i2c_hal_data[bus]->twi_master_instance, &packet) != TWI_SUCCESS)
-    {
-        return ATCA_COMM_FAIL;
-    }
-
-    return ATCA_SUCCESS;
-}
-
-/**
- * \brief HAL implementation of I2C receive function for ASF I2C
- *
- * \param[in] iface     instance
- * \param[out] rxdata    pointer to space to receive the data
- * \param[in] rxlength  ptr to expected number of receive bytes to request
- *
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-ATCA_STATUS hal_i2c_receive(ATCAIface iface, uint8_t *rxdata, uint16_t *rxlength)
-{
-#ifdef DEBUG_HAL
-    printf("hal_i2c_receive()\r\n");
-#endif
-
-    ATCAIfaceCfg *cfg = atgetifacecfg(iface);
-    // set to default i2c bus
-    if (cfg->atcai2c.bus > MAX_I2C_BUSES - 1)
-    {
-        cfg->atcai2c.bus = 0;
-    }
-    int bus = cfg->atcai2c.bus;
-    int retries = cfg->rx_retries;
-    uint32_t status = !TWI_SUCCESS;
-
-    twi_package_t packet = {
-        .chip           = cfg->atcai2c.slave_address >> 1,
-        .addr           = { 0 },
-        .addr_length    = 0,
-        .buffer         = (void*)rxdata,
-        .length         = (uint32_t)*rxlength
-    };
-
-    while (retries-- > 0 && status != TWI_SUCCESS)
-    {
-        status = twi_master_read(i2c_hal_data[bus]->twi_master_instance, &packet);
-    }
-    if (status != TWI_SUCCESS)
-    {
-        return ATCA_COMM_FAIL;
-    }
-
-#ifdef DEBUG_HAL
-    printf("\r\nResponse Packet (size:0x%.4x)\r\n", rxlength);
-    printf("Count  : %.2x\r\n", rxdata[0]);
-    if (rxdata[0] > 3)
-    {
-        printf("Data   : "); print_array(&rxdata[1], rxdata[0] - 3);
-        printf("CRC    : "); print_array(&rxdata[rxdata[0] - 2], 2);
-    }
-    printf("\r\n");
-#endif
-
-    return ATCA_SUCCESS;
-}
-
-/**
- * \brief method to change the bus speed of I2C
- *
- * \param[in] iface  interface on which to change bus speed
- * \param[in] speed  baud rate (typically 100000 or 400000)
- */
-void change_i2c_speed(ATCAIface iface, uint32_t speed)
-{
-    ATCAIfaceCfg *cfg = atgetifacecfg(iface);
-
-    // set to default i2c bus
-    if (cfg->atcai2c.bus > MAX_I2C_BUSES - 1)
-    {
-        cfg->atcai2c.bus = 0;
-    }
-    int bus = cfg->atcai2c.bus;
-
-    pmc_enable_periph_clk(i2c_hal_data[bus]->twi_id);
-
-    opt_twi_master.master_clk = sysclk_get_cpu_hz();
-    opt_twi_master.speed      = speed;
-    opt_twi_master.smbus      = 0;
-
-    twi_master_init(i2c_hal_data[bus]->twi_master_instance, &opt_twi_master);
-}
-
-/**
- * \brief wake up CryptoAuth device using I2C bus
- *
- * \param[in] iface  interface to logical device to wakeup
- *
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-ATCA_STATUS hal_i2c_wake(ATCAIface iface)
-{
-    ATCAIfaceCfg *cfg = atgetifacecfg(iface);
-
-    // set to default i2c bus
-    if (cfg->atcai2c.bus > MAX_I2C_BUSES - 1)
-    {
-        cfg->atcai2c.bus = 0;
-    }
-    int bus = cfg->atcai2c.bus;
-    int retries = cfg->rx_retries;
-    uint32_t bdrt = cfg->atcai2c.baud;
-    int status = !TWI_SUCCESS;
-    uint8_t data[4], expected[4] = { 0x04, 0x11, 0x33, 0x43 };
-
-    // if not already at 100kHz, change it
-    if (bdrt != 100000)
-    {
-        change_i2c_speed(iface, 100000);
-    }
-
-    // Send 0x00 as wake pulse
-    twi_write_byte(i2c_hal_data[bus]->twi_master_instance, 0x00);
-
-    // rounded up to the nearest ms
-    atca_delay_ms(((uint32_t)cfg->wake_delay + (1000 - 1)) / 1000);   // wait tWHI + tWLO which is configured based on device type and configuration structure
-
-    twi_package_t packet = {
-        .chip           = cfg->atcai2c.slave_address >> 1,
-        .addr           = { 0 },
-        .addr_length    = 0,
-        .buffer         = (void*)data,
-        .length         = 4
-    };
-
-    // if necessary, revert baud rate to what came in.
-    if (bdrt != 100000)
-    {
-        change_i2c_speed(iface, bdrt);
-    }
-
-    while (retries-- > 0 && status != TWI_SUCCESS)
-    {
-        status = twi_master_read(i2c_hal_data[bus]->twi_master_instance, &packet);
-    }
-    if (status != TWI_SUCCESS)
-    {
-        return ATCA_COMM_FAIL;
-    }
-
-    if (memcmp(data, expected, 4) == 0)
-    {
-        return ATCA_SUCCESS;
-    }
-
-    return ATCA_COMM_FAIL;
-}
-
-/**
- * \brief idle CryptoAuth device using I2C bus
- *
- * \param[in] iface  interface to logical device to idle
- *
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-ATCA_STATUS hal_i2c_idle(ATCAIface iface)
-{
-    ATCAIfaceCfg *cfg = atgetifacecfg(iface);
-
-    // set to default i2c bus
-    if (cfg->atcai2c.bus > MAX_I2C_BUSES - 1)
-    {
-        cfg->atcai2c.bus = 0;
-    }
-    int bus = cfg->atcai2c.bus;
-    uint8_t data[4];
-
-    data[0] = 0x02; // idle word address value
-
-    twi_package_t packet = {
-        .chip           = cfg->atcai2c.slave_address >> 1,
-        .addr           = { 0 },
-        .addr_length    = 0,
-        .buffer         = (void*)data,
-        .length         = 1
-    };
-
-    if (twi_master_write(i2c_hal_data[bus]->twi_master_instance, &packet) != TWI_SUCCESS)
-    {
-        return ATCA_COMM_FAIL;
-    }
-
-    return ATCA_SUCCESS;
-}
-
-/**
- * \brief sleep CryptoAuth device using I2C bus
- *
- * \param[in] iface  interface to logical device to sleep
- *
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-ATCA_STATUS hal_i2c_sleep(ATCAIface iface)
-{
-    ATCAIfaceCfg *cfg = atgetifacecfg(iface);
-
-    // set to default i2c bus
-    if (cfg->atcai2c.bus > MAX_I2C_BUSES - 1)
-    {
-        cfg->atcai2c.bus = 0;
-    }
-    int bus = cfg->atcai2c.bus;
-    uint8_t data[4];
-
-    data[0] = 0x01; // sleep word address value
-
-    twi_package_t packet = {
-        .chip           = cfg->atcai2c.slave_address >> 1,
-        .addr           = { 0 },
-        .addr_length    = 0,
-        .buffer         = (void*)data,
-        .length         = 1
-    };
-
-    if (twi_master_write(i2c_hal_data[bus]->twi_master_instance, &packet) != TWI_SUCCESS)
-    {
-        return ATCA_COMM_FAIL;
-    }
-
-    return ATCA_SUCCESS;
-}
-
-/**
- * \brief manages reference count on given bus and releases resource if no more refences exist
- *
- * \param[in] hal_data - opaque pointer to hal data structure - known only to the HAL implementation
- *
- * \return ATCA_SUCCESS
- */
-ATCA_STATUS hal_i2c_release(void *hal_data)
-{
-    ATCAI2CMaster_t *hal = (ATCAI2CMaster_t*)hal_data;
-
-    // set to default i2c bus
-    if (hal->bus_index > MAX_I2C_BUSES - 1)
-    {
-        hal->bus_index = 0;
-    }
-
-    i2c_bus_ref_ct--;  // track total i2c bus interface instances for consistency checking and debugging
-
-    // if the use count for this bus has gone to 0 references, disable it.  protect against an unbracketed release
-    if (hal && --(hal->ref_ct) <= 0 && i2c_hal_data[hal->bus_index] != NULL)
-    {
-        twi_reset(hal->twi_master_instance);
-        free(i2c_hal_data[hal->bus_index]);
-        i2c_hal_data[hal->bus_index] = NULL;
-    }
-
-    return ATCA_SUCCESS;
-}
-
-/** @} */
diff --git a/lib/hal/hal_sam4s_i2c_asf.h b/lib/hal/hal_sam4s_i2c_asf.h
deleted file mode 100644
index dea016a08be9..000000000000
--- a/lib/hal/hal_sam4s_i2c_asf.h
+++ /dev/null
@@ -1,67 +0,0 @@
-/**
- * \file
- * \brief ATCA Hardware abstraction layer for SAM4S I2C over ASF drivers.
- *
- * Prerequisite: add "TWI - Two-Wire Interface (Common API) (service)" module to application in Atmel Studio
- *
- * \copyright (c) 2017 Microchip Technology Inc. and its subsidiaries.
- *            You may use this software and any derivatives exclusively with
- *            Microchip products.
- *
- * \page License
- *
- * (c) 2017 Microchip Technology Inc. and its subsidiaries. You may use this
- * software and any derivatives exclusively with Microchip products.
- *
- * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
- * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
- * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
- * PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
- * WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
- *
- * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
- * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
- * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
- * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
- * FULLEST EXTENT ALLOWED BY LAW, MICROCHIPS TOTAL LIABILITY ON ALL CLAIMS IN
- * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
- * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
- *
- * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
- * TERMS.
- */
-
-#ifndef HAL_SAM4S_I2C_ASF_H_
-#define HAL_SAM4S_I2C_ASF_H_
-
-#include <asf.h>
-
-
-/**
- * \defgroup hal_ Hardware abstraction layer (hal_)
- *
- * \brief
- * These methods define the hardware abstraction layer for communicating with a CryptoAuth device
- * using I2C driver of ASF.
- *
-   @{ */
-
-#define MAX_I2C_BUSES   2   // SAM4S has 2 TWI
-
-/**
- * \brief this is the hal_data for ATCA HAL
- */
-typedef struct atcaI2Cmaster
-{
-    uint32_t twi_id;
-    Twi *    twi_master_instance;
-    int      ref_ct;
-    // for conveniences during interface release phase
-    int bus_index;
-} ATCAI2CMaster_t;
-
-void change_i2c_speed(ATCAIface iface, uint32_t speed);
-
-/** @} */
-
-#endif  /* HAL_SAM4S_I2C_ASF_H_ */
\ No newline at end of file
diff --git a/lib/hal/hal_sam4s_timer_asf.c b/lib/hal/hal_sam4s_timer_asf.c
deleted file mode 100644
index c3c937c25252..000000000000
--- a/lib/hal/hal_sam4s_timer_asf.c
+++ /dev/null
@@ -1,86 +0,0 @@
-/**
- * \file
- * \brief ATCA Hardware abstraction layer for SAM4S I2C over ASF drivers.
- *
- * Prerequisite: add "Delay routines (service)" module to application in Atmel Studio
- *
- * \copyright (c) 2017 Microchip Technology Inc. and its subsidiaries.
- *            You may use this software and any derivatives exclusively with
- *            Microchip products.
- *
- * \page License
- *
- * (c) 2017 Microchip Technology Inc. and its subsidiaries. You may use this
- * software and any derivatives exclusively with Microchip products.
- *
- * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
- * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
- * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
- * PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
- * WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
- *
- * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
- * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
- * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
- * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
- * FULLEST EXTENT ALLOWED BY LAW, MICROCHIPS TOTAL LIABILITY ON ALL CLAIMS IN
- * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
- * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
- *
- * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
- * TERMS.
- */
-
-#include <asf.h>
-#include <delay.h>
-#include "atca_hal.h"
-
-
-/* ASF already have delay_us and delay_ms - see delay.h */
-
-/**
- * \defgroup hal_ Hardware abstraction layer (hal_)
- *
- * \brief
- * These methods define the hardware abstraction layer for communicating with a CryptoAuth device
- *
-   @{ */
-
-/**
- * \brief This function delays for a number of microseconds.
- *
- * \param[in] delay number of 0.001 milliseconds to delay
- */
-void atca_delay_us(uint32_t delay)
-{
-    // use ASF supplied delay
-    delay_us(delay);
-}
-
-/**
- * \brief This function delays for a number of tens of microseconds.
- *
- * \param[in] delay number of 0.01 milliseconds to delay
- */
-void atca_delay_10us(uint32_t delay)
-{
-    // use ASF supplied delay
-    delay_us(delay * 10);
-
-}
-
-/**
- * \brief This function delays for a number of milliseconds.
- *
- *        You can override this function if you like to do
- *        something else in your system while delaying.
- *
- * \param[in] delay number of milliseconds to delay
- */
-void atca_delay_ms(uint32_t delay)
-{
-    // use ASF supplied delay
-    delay_ms(delay);
-}
-
-/** @} */
diff --git a/lib/hal/hal_samb11_i2c_asf.c b/lib/hal/hal_samb11_i2c_asf.c
deleted file mode 100644
index aa12364e62c7..000000000000
--- a/lib/hal/hal_samb11_i2c_asf.c
+++ /dev/null
@@ -1,485 +0,0 @@
-/**
- * \file
- * \brief ATCA Hardware abstraction layer for SAMB11 I2C over ASF drivers.
- *
- * This code is structured in two parts.  Part 1 is the connection of the ATCA HAL API to the physical I2C
- * implementation. Part 2 is the ASF I2C primitives to set up the interface.
- *
- * Prerequisite: add I2C Master Polled support to application in Atmel Studio
- *
- * \copyright (c) 2017 Microchip Technology Inc. and its subsidiaries.
- *            You may use this software and any derivatives exclusively with
- *            Microchip products.
- *
- * \page License
- *
- * (c) 2017 Microchip Technology Inc. and its subsidiaries. You may use this
- * software and any derivatives exclusively with Microchip products.
- *
- * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
- * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
- * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
- * PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
- * WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
- *
- * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
- * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
- * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
- * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
- * FULLEST EXTENT ALLOWED BY LAW, MICROCHIPS TOTAL LIABILITY ON ALL CLAIMS IN
- * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
- * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
- *
- * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
- * TERMS.
- */
-
-#include <asf.h>
-#include <string.h>
-#include <stdio.h>
-
-#include "atca_hal.h"
-#include "hal_samb11_i2c_asf.h"
-#include "atca_device.h"
-
-/** \defgroup hal_ Hardware abstraction layer (hal_)
- *
- * \brief
- * These methods define the hardware abstraction layer for communicating with a CryptoAuth device
- * using I2C driver of ASF.
- *
-   @{ */
-
-/** \brief logical to physical bus mapping structure */
-ATCAI2CMaster_t *i2c_hal_data[MAX_I2C_BUSES];   // map logical, 0-based bus number to index
-int i2c_bus_ref_ct = 0;                         // total in-use count across buses
-static struct i2c_master_config config_i2c_master;
-
-/** \brief discover i2c buses available for this hardware
- * this maintains a list of logical to physical bus mappings freeing the application
- * of the a-priori knowledge
- * \param[in] i2c_buses - an array of logical bus numbers
- * \param[in] max_buses - maximum number of buses the app wants to attempt to discover
- * \return ATCA_SUCCESS
- */
-
-ATCA_STATUS hal_i2c_discover_buses(int i2c_buses[], int max_buses)
-{
-    i2c_buses[0] = 0;   // b11 bus for xplained pro dev board over EXT1
-    i2c_buses[1] = 1;   // b11 bus for MR510CA
-
-    return ATCA_SUCCESS;
-}
-
-/** \brief discover any CryptoAuth devices on a given logical bus number
- * \param[in]  busNum  logical bus number on which to look for CryptoAuth devices
- * \param[out] cfg     pointer to head of an array of interface config structures which get filled in by this method
- * \param[out] found   number of devices found on this bus
- * \return ATCA_SUCCESS
- */
-
-ATCA_STATUS hal_i2c_discover_devices(int busNum, ATCAIfaceCfg cfg[], int *found)
-{
-    ATCAIfaceCfg *head = cfg;
-    uint8_t slaveAddress = 0x01;
-    ATCADevice device;
-    ATCAIface discoverIface;
-    ATCACommand command;
-    ATCAPacket packet;
-    ATCA_STATUS status;
-    uint8_t revs508[1][4] = { { 0x00, 0x00, 0x50, 0x00 } };
-    uint8_t revs108[1][4] = { { 0x80, 0x00, 0x10, 0x01 } };
-    uint8_t revs204[3][4] = { { 0x00, 0x02, 0x00, 0x08 },
-                              { 0x00, 0x02, 0x00, 0x09 },
-                              { 0x00, 0x04, 0x05, 0x00 } };
-    int i;
-
-
-    /** \brief default configuration, to be reused during discovery process */
-    ATCAIfaceCfg discoverCfg = {
-        .iface_type             = ATCA_I2C_IFACE,
-        .devtype                = ATECC508A,
-        .atcai2c.slave_address  = 0x07,
-        .atcai2c.bus            = busNum,
-        .atcai2c.baud           = 400000,
-        //.atcai2c.baud = 100000,
-        .wake_delay             = 800,
-        .rx_retries             = 3
-    };
-
-    ATCAHAL_t hal;
-
-    hal_i2c_init(&hal, &discoverCfg);
-    device = newATCADevice(&discoverCfg);
-    discoverIface = atGetIFace(device);
-    command = atGetCommands(device);
-
-    for (slaveAddress = 0x07; slaveAddress <= 0x78; slaveAddress++)
-    {
-        discoverCfg.atcai2c.slave_address = slaveAddress << 1;  // turn it into an 8-bit address which is what the rest of the i2c HAL is expecting when a packet is sent
-
-        // wake up device
-        // If it wakes, send it a dev rev command.  Based on that response, determine the device type
-        // BTW - this will wake every cryptoauth device living on the same bus (ecc508a, sha204a)
-
-        if (hal_i2c_wake(discoverIface) == ATCA_SUCCESS)
-        {
-            (*found)++;
-            memcpy( (uint8_t*)head, (uint8_t*)&discoverCfg, sizeof(ATCAIfaceCfg));
-
-            memset(packet.data, 0x00, sizeof(packet.data));
-
-            // build an info command
-            packet.param1 = INFO_MODE_REVISION;
-            packet.param2 = 0;
-
-            // get devrev info and set device type accordingly
-            atInfo(command, &packet);
-            if ((status = atGetExecTime(packet.opcode, command)) != ATCA_SUCCESS)
-            {
-                continue;
-            }
-
-            // send the command
-            if ( (status = atsend(discoverIface, (uint8_t*)&packet, packet.txsize)) != ATCA_SUCCESS)
-            {
-                printf("packet send error\r\n");
-                continue;
-            }
-
-            // delay the appropriate amount of time for command to execute
-            atca_delay_ms((command->execution_time_msec) + 1);
-
-            // receive the response
-            if ( (status = atreceive(discoverIface, &(packet.data[0]), &(packet.rxsize) )) != ATCA_SUCCESS)
-            {
-                continue;
-            }
-
-            if ( (status = isATCAError(packet.data)) != ATCA_SUCCESS)
-            {
-                printf("command response error\r\n");
-                continue;
-            }
-
-            // determine device type from common info and dev rev response byte strings
-            for (i = 0; i < (int)sizeof(revs508) / 4; i++)
-            {
-                if (memcmp(&packet.data[1], &revs508[i], 4) == 0)
-                {
-                    discoverCfg.devtype = ATECC508A;
-                    break;
-                }
-            }
-
-            for (i = 0; i < (int)sizeof(revs204) / 4; i++)
-            {
-                if (memcmp(&packet.data[1], &revs204[i], 4) == 0)
-                {
-                    discoverCfg.devtype = ATSHA204A;
-                    break;
-                }
-            }
-
-            for (i = 0; i < (int)sizeof(revs108) / 4; i++)
-            {
-                if (memcmp(&packet.data[1], &revs108[i], 4) == 0)
-                {
-                    discoverCfg.devtype = ATECC108A;
-                    break;
-                }
-            }
-
-            atca_delay_ms(15);
-            // now the device type is known, so update the caller's cfg array element with it
-            head->devtype = discoverCfg.devtype;
-            head++;
-        }
-
-        hal_i2c_idle(discoverIface);
-    }
-
-    hal_i2c_release(&hal);
-
-    return ATCA_SUCCESS;
-}
-
-/** \brief
-    - this HAL implementation assumes you've included the ASF I2C libraries in your project, otherwise,
-    the HAL layer will not compile because the ASF I2C drivers are a dependency *
- */
-
-/** \brief hal_i2c_init manages requests to initialize a physical interface.  it manages use counts so when an interface
- * has released the physical layer, it will disable the interface for some other use.
- * You can have multiple ATCAIFace instances using the same bus, and you can have multiple ATCAIFace instances on
- * multiple i2c buses, so hal_i2c_init manages these things and ATCAIFace is abstracted from the physical details.
- */
-
-/** \brief initialize an I2C interface using given config
- * \param[in] hal - opaque ptr to HAL data
- * \param[in] cfg - interface configuration
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-ATCA_STATUS hal_i2c_init(void *hal, ATCAIfaceCfg *cfg)
-{
-    int bus = cfg->atcai2c.bus;   // 0-based logical bus number
-    ATCAHAL_t *phal = (ATCAHAL_t*)hal;
-
-    if (i2c_bus_ref_ct == 0)       // power up state, no i2c buses will have been used
-    {
-        for (int i = 0; i < MAX_I2C_BUSES; i++)
-        {
-            i2c_hal_data[i] = NULL;
-        }
-    }
-
-    i2c_bus_ref_ct++;  // total across buses
-
-    if (bus >= 0 && bus < MAX_I2C_BUSES)
-    {
-        // if this is the first time this bus and interface has been created, do the physical work of enabling it
-        if (i2c_hal_data[bus] == NULL)
-        {
-            i2c_hal_data[bus] = malloc(sizeof(ATCAI2CMaster_t) );
-            i2c_hal_data[bus]->ref_ct = 1;  // buses are shared, this is the first instance
-            i2c_master_get_config_defaults(&config_i2c_master);
-
-            switch (bus)
-            {
-            case 0:
-                config_i2c_master.pin_number_pad0 = PIN_LP_GPIO_8;
-                config_i2c_master.pin_number_pad1 = PIN_LP_GPIO_9;
-                config_i2c_master.pinmux_sel_pad0 = PINMUX_LP_GPIO_8_MUX2_I2C0_SDA;
-                config_i2c_master.pinmux_sel_pad1 = PINMUX_LP_GPIO_9_MUX2_I2C0_SCL;
-                i2c_master_init(&(i2c_hal_data[bus]->i2c_master_instance), I2C0, &config_i2c_master);
-                break;
-            case 1:
-                config_i2c_master.pin_number_pad0 = PIN_LP_GPIO_14;
-                config_i2c_master.pin_number_pad1 = PIN_LP_GPIO_15;
-                config_i2c_master.pinmux_sel_pad0 = PINMUX_LP_GPIO_14_MUX4_I2C1_SDA;
-                config_i2c_master.pinmux_sel_pad1 = PINMUX_LP_GPIO_15_MUX4_I2C1_SCL;
-                i2c_master_init(&(i2c_hal_data[bus]->i2c_master_instance), I2C1, &config_i2c_master);
-                break;
-            }
-
-            // store this for use during the release phase
-            i2c_hal_data[bus]->bus_index = bus;
-
-            i2c_enable((i2c_hal_data[bus]->i2c_master_instance).hw);
-        }
-        else
-        {
-            // otherwise, another interface already initialized the bus, so this interface will share it and any different
-            // cfg parameters will be ignored...first one to initialize this sets the configuration
-            i2c_hal_data[bus]->ref_ct++;
-        }
-
-        phal->hal_data = i2c_hal_data[bus];
-
-        return ATCA_SUCCESS;
-    }
-
-    return ATCA_COMM_FAIL;
-}
-
-/** \brief HAL implementation of I2C post init
- * \param[in] iface  instance
- * \return ATCA_SUCCESS
- */
-ATCA_STATUS hal_i2c_post_init(ATCAIface iface)
-{
-    return ATCA_SUCCESS;
-}
-
-/** \brief HAL implementation of I2C send over ASF
- * \param[in] iface     instance
- * \param[in] txdata    pointer to space to bytes to send
- * \param[in] txlength  number of bytes to send
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-
-ATCA_STATUS hal_i2c_send(ATCAIface iface, uint8_t *txdata, int txlength)
-{
-    ATCAIfaceCfg *cfg = atgetifacecfg(iface);
-    int bus = cfg->atcai2c.bus;
-
-    struct i2c_master_packet packet = {
-        .address            = cfg->atcai2c.slave_address >> 1,
-        .data_length        = txlength,
-        .data               = txdata,
-    };
-
-    // for this implementation of I2C with CryptoAuth chips, txdata is assumed to have ATCAPacket format
-
-    // other device types that don't require i/o tokens on the front end of a command need a different hal_i2c_send and wire it up instead of this one
-    // this covers devices such as ATSHA204A and ATECCx08A that require a word address value pre-pended to the packet
-    // txdata[0] is using _reserved byte of the ATCAPacket
-    txdata[0] = 0x03;   // insert the Word Address Value, Command token
-    txlength++;         // account for word address value byte.
-    packet.data_length = txlength;
-
-    if (i2c_master_write_packet_wait(&(i2c_hal_data[bus]->i2c_master_instance), &packet) != STATUS_OK)
-    {
-        return ATCA_COMM_FAIL;
-    }
-
-    return ATCA_SUCCESS;
-}
-
-/** \brief HAL implementation of I2C receive function for ASF I2C
- * \param[in] iface     instance
- * \param[in] rxdata    pointer to space to receive the data
- * \param[in] rxlength  ptr to expected number of receive bytes to request
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-
-ATCA_STATUS hal_i2c_receive(ATCAIface iface, uint8_t *rxdata, uint16_t *rxlength)
-{
-    ATCAIfaceCfg *cfg = atgetifacecfg(iface);
-    int bus = cfg->atcai2c.bus;
-    int retries = cfg->rx_retries;
-    int status = !STATUS_OK;
-
-    struct i2c_master_packet packet = {
-        .address            = cfg->atcai2c.slave_address >> 1,
-        .data_length        = *rxlength,
-        .data               = rxdata,
-    };
-
-    while (retries-- > 0 && status != STATUS_OK)
-    {
-        status = i2c_master_read_packet_wait(&(i2c_hal_data[bus]->i2c_master_instance), &packet);
-    }
-
-    if (status != STATUS_OK)
-    {
-        return ATCA_COMM_FAIL;
-    }
-
-    return ATCA_SUCCESS;
-}
-
-/** \brief wake up CryptoAuth device using I2C bus
- * \param[in] iface  interface to logical device to wakeup
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-
-ATCA_STATUS hal_i2c_wake(ATCAIface iface)
-{
-    ATCAIfaceCfg *cfg = atgetifacecfg(iface);
-    int bus = cfg->atcai2c.bus;
-    int retries = cfg->rx_retries;
-    int status = !STATUS_OK;
-    uint8_t data[4], expected[4] = { 0x04, 0x11, 0x33, 0x43 };
-
-    // Send the wake by writing to an address of 0x00
-    struct i2c_master_packet packet = {
-        .address            = 0x00,
-        .data_length        = 0,
-        .data               = &data[0],
-    };
-
-    // Send the 00 address as the wake pulse
-    i2c_master_write_packet_wait(&(i2c_hal_data[bus]->i2c_master_instance), &packet);       // part will NACK, so don't check for status
-
-    atca_delay_us(cfg->wake_delay);                                                         // wait tWHI + tWLO which is configured based on device type and configuration structure
-
-    packet.address = cfg->atcai2c.slave_address >> 1;
-    packet.data_length = 4;
-    packet.data = data;
-
-    while (retries-- > 0 && status != STATUS_OK)
-    {
-        status = i2c_master_read_packet_wait(&(i2c_hal_data[bus]->i2c_master_instance), &packet);
-    }
-
-
-    if (status != STATUS_OK)
-    {
-        return ATCA_COMM_FAIL;
-    }
-
-    if (memcmp(data, expected, 4) == 0)
-    {
-        return ATCA_SUCCESS;
-    }
-
-    return ATCA_COMM_FAIL;
-}
-
-/** \brief idle CryptoAuth device using I2C bus
- * \param[in] iface  interface to logical device to idle
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-
-ATCA_STATUS hal_i2c_idle(ATCAIface iface)
-{
-    ATCAIfaceCfg *cfg = atgetifacecfg(iface);
-    int bus = cfg->atcai2c.bus;
-    uint8_t data[4];
-
-    struct i2c_master_packet packet = {
-        .address            = cfg->atcai2c.slave_address >> 1,
-        .data_length        = 1,
-        .data               = &data[0],
-    };
-
-    data[0] = 0x02;  // idle word address value
-    if (i2c_master_write_packet_wait(&(i2c_hal_data[bus]->i2c_master_instance), &packet) != STATUS_OK)
-    {
-        return ATCA_COMM_FAIL;
-    }
-
-    return ATCA_SUCCESS;
-
-}
-
-/** \brief sleep CryptoAuth device using I2C bus
- * \param[in] iface  interface to logical device to sleep
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-
-ATCA_STATUS hal_i2c_sleep(ATCAIface iface)
-{
-    ATCAIfaceCfg *cfg = atgetifacecfg(iface);
-    int bus = cfg->atcai2c.bus;
-    uint8_t data[4];
-
-    struct i2c_master_packet packet = {
-        .address            = cfg->atcai2c.slave_address >> 1,
-        .data_length        = 1,
-        .data               = data,
-    };
-
-    data[0] = 0x01;  // sleep word address value
-    if (i2c_master_write_packet_wait(&(i2c_hal_data[bus]->i2c_master_instance), &packet) != STATUS_OK)
-    {
-        return ATCA_COMM_FAIL;
-    }
-
-    return ATCA_SUCCESS;
-}
-
-/** \brief manages reference count on given bus and releases resource if no more references exist
- * \param[in] hal_data - opaque pointer to hal data structure - known only to the HAL implementation
- * \return ATCA_SUCCESS
- */
-
-ATCA_STATUS hal_i2c_release(void *hal_data)
-{
-    ATCAI2CMaster_t *hal = (ATCAI2CMaster_t*)hal_data;
-
-    i2c_bus_ref_ct--;  // track total i2c bus interface instances for consistency checking and debugging
-
-    // if the use count for this bus has gone to 0 references, disable it.  protect against an unbracketed release
-    if (hal && --(hal->ref_ct) <= 0 && i2c_hal_data[hal->bus_index] != NULL)
-    {
-        i2c_master_reset(&(hal->i2c_master_instance));
-        free(i2c_hal_data[hal->bus_index]);
-        i2c_hal_data[hal->bus_index] = NULL;
-    }
-
-    return ATCA_SUCCESS;
-}
-
-/** @} */
diff --git a/lib/hal/hal_samb11_i2c_asf.h b/lib/hal/hal_samb11_i2c_asf.h
deleted file mode 100644
index 0c2243a3c703..000000000000
--- a/lib/hal/hal_samb11_i2c_asf.h
+++ /dev/null
@@ -1,60 +0,0 @@
-/**
- * \file
- * \brief ATCA Hardware abstraction layer for SAMB11 I2C over ASF drivers.
- *
- * Prerequisite: add SERCOM I2C Master Polled support to application in Atmel Studio
- *
- * \copyright (c) 2017 Microchip Technology Inc. and its subsidiaries.
- *            You may use this software and any derivatives exclusively with
- *            Microchip products.
- *
- * \page License
- *
- * (c) 2017 Microchip Technology Inc. and its subsidiaries. You may use this
- * software and any derivatives exclusively with Microchip products.
- *
- * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
- * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
- * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
- * PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
- * WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
- *
- * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
- * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
- * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
- * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
- * FULLEST EXTENT ALLOWED BY LAW, MICROCHIPS TOTAL LIABILITY ON ALL CLAIMS IN
- * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
- * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
- *
- * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
- * TERMS.
- */
-
-#ifndef HAL_SAMB11_I2C_ASF_H_
-#define HAL_SAMB11_I2C_ASF_H_
-
-#include <asf.h>
-
-/** \defgroup hal_ Hardware abstraction layer (hal_)
- *
- * \brief
- * These methods define the hardware abstraction layer for communicating with a CryptoAuth device
- * using I2C driver of ASF.
- *
-   @{ */
-
-#define MAX_I2C_BUSES    2 // SAMB11 has up to 2 I2C address that can be configured as I2C
-
-/** \brief this is the hal_data for ATCA HAL for ASF
- */
-typedef struct atcaI2Cmaster
-{
-    struct i2c_master_module i2c_master_instance;
-    int                      ref_ct;
-    // for conveniences during interface release phase
-    int bus_index;
-} ATCAI2CMaster_t;
-
-/** @} */
-#endif /* HAL_SAMB11_I2C_ASF_H_ */
\ No newline at end of file
diff --git a/lib/hal/hal_samb11_timer_asf.c b/lib/hal/hal_samb11_timer_asf.c
deleted file mode 100644
index dd0a21fea7ee..000000000000
--- a/lib/hal/hal_samb11_timer_asf.c
+++ /dev/null
@@ -1,78 +0,0 @@
-/**
- * \file
- * \brief ATCA Hardware abstraction layer for SAMB11 timer/delay over ASF drivers.
- *
- * \copyright (c) 2017 Microchip Technology Inc. and its subsidiaries.
- *            You may use this software and any derivatives exclusively with
- *            Microchip products.
- *
- * \page License
- *
- * (c) 2017 Microchip Technology Inc. and its subsidiaries. You may use this
- * software and any derivatives exclusively with Microchip products.
- *
- * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
- * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
- * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
- * PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
- * WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
- *
- * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
- * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
- * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
- * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
- * FULLEST EXTENT ALLOWED BY LAW, MICROCHIPS TOTAL LIABILITY ON ALL CLAIMS IN
- * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
- * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
- *
- * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
- * TERMS.
- */
-
-#include <asf.h>
-#include <delay.h>
-#include "atca_hal.h"
-
-/** \defgroup hal_ Hardware abstraction layer (hal_)
- *
- * \brief
- * These methods define the hardware abstraction layer for communicating with a CryptoAuth device
- *
-   @{ */
-
-/** \brief This function delays for a number of microseconds.
- *
- * \param[in] delay number of 0.001 milliseconds to delay
- */
-void atca_delay_us(uint32_t delay)
-{
-    // use ASF supplied delay
-    delay_us(delay);
-}
-
-/** \brief This function delays for a number of tens of microseconds.
- *
- * \param[in] delay number of 0.01 milliseconds to delay
- */
-void atca_delay_10us(uint32_t delay)
-{
-    // use ASF supplied delay
-    delay_us(delay * 10);
-
-}
-
-/** \brief This function delays for a number of milliseconds.
- *
- *         You can override this function if you like to do
- *         something else in your system while delaying.
- * \param[in] delay number of milliseconds to delay
- */
-
-/* ASF already has delay_ms - see delay.h */
-void atca_delay_ms(uint32_t delay)
-{
-    // use ASF supplied delay
-    delay_ms(delay);
-}
-
-/** @} */
diff --git a/lib/hal/hal_samd21_i2c_asf.c b/lib/hal/hal_samd21_i2c_asf.c
deleted file mode 100644
index 841a1fb9125e..000000000000
--- a/lib/hal/hal_samd21_i2c_asf.c
+++ /dev/null
@@ -1,572 +0,0 @@
-/**
- * \file
- * \brief ATCA Hardware abstraction layer for SAMD21 I2C over ASF drivers.
- *
- * This code is structured in two parts.  Part 1 is the connection of the ATCA HAL API to the physical I2C
- * implementation. Part 2 is the ASF I2C primitives to set up the interface.
- *
- * Prerequisite: add SERCOM I2C Master Polled support to application in Atmel Studio
- *
- * \copyright (c) 2017 Microchip Technology Inc. and its subsidiaries.
- *            You may use this software and any derivatives exclusively with
- *            Microchip products.
- *
- * \page License
- *
- * (c) 2017 Microchip Technology Inc. and its subsidiaries. You may use this
- * software and any derivatives exclusively with Microchip products.
- *
- * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
- * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
- * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
- * PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
- * WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
- *
- * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
- * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
- * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
- * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
- * FULLEST EXTENT ALLOWED BY LAW, MICROCHIPS TOTAL LIABILITY ON ALL CLAIMS IN
- * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
- * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
- *
- * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
- * TERMS.
- */
-
-#include <asf.h>
-#include <string.h>
-#include <stdio.h>
-
-#include "atca_hal.h"
-#include "hal_samd21_i2c_asf.h"
-#include "atca_device.h"
-
-/** \defgroup hal_ Hardware abstraction layer (hal_)
- *
- * \brief
- * These methods define the hardware abstraction layer for communicating with a CryptoAuth device
- * using I2C driver of ASF.
- *
-   @{ */
-
-/** \brief logical to physical bus mapping structure */
-ATCAI2CMaster_t *i2c_hal_data[MAX_I2C_BUSES];   // map logical, 0-based bus number to index
-int i2c_bus_ref_ct = 0;                         // total in-use count across buses
-static struct i2c_master_config config_i2c_master;
-
-/** \brief discover i2c buses available for this hardware
- * this maintains a list of logical to physical bus mappings freeing the application
- * of the a-priori knowledge
- * \param[in] i2c_buses - an array of logical bus numbers
- * \param[in] max_buses - maximum number of buses the app wants to attempt to discover
- * \return ATCA_SUCCESS
- */
-
-ATCA_STATUS hal_i2c_discover_buses(int i2c_buses[], int max_buses)
-{
-
-    /* if every SERCOM was a likely candidate bus, then would need to initialize the entire array to all SERCOM n numbers.
-     * As an optimization and making discovery safer, make assumptions about bus-num / SERCOM map based on D21 Xplained Pro board
-     * If you were using a raw D21 on your own board, you would supply your own bus numbers based on your particular hardware configuration.
-     */
-#ifdef __SAMR21G18A__
-    i2c_buses[0] = 1;   // default r21 for xplained pro dev board
-#else
-    i2c_buses[0] = 2;   // default d21 for xplained pro dev board
-#endif
-
-    return ATCA_SUCCESS;
-}
-
-/** \brief discover any CryptoAuth devices on a given logical bus number
- * \param[in]  busNum  logical bus number on which to look for CryptoAuth devices
- * \param[out] cfg     pointer to head of an array of interface config structures which get filled in by this method
- * \param[out] found   number of devices found on this bus
- * \return ATCA_SUCCESS
- */
-
-ATCA_STATUS hal_i2c_discover_devices(int busNum, ATCAIfaceCfg cfg[], int *found)
-{
-    ATCAIfaceCfg *head = cfg;
-    uint8_t slaveAddress = 0x01;
-    ATCADevice device;
-    ATCAIface discoverIface;
-    ATCACommand command;
-    ATCAPacket packet;
-    ATCA_STATUS status;
-    uint8_t revs608[1][4] = { { 0x00, 0x00, 0x60, 0x01 } };
-    uint8_t revs508[1][4] = { { 0x00, 0x00, 0x50, 0x00 } };
-    uint8_t revs108[1][4] = { { 0x80, 0x00, 0x10, 0x01 } };
-    uint8_t revs204[3][4] = { { 0x00, 0x02, 0x00, 0x08 },
-                              { 0x00, 0x02, 0x00, 0x09 },
-                              { 0x00, 0x04, 0x05, 0x00 } };
-    int i;
-
-    /** \brief default configuration, to be reused during discovery process */
-    ATCAIfaceCfg discoverCfg = {
-        .iface_type             = ATCA_I2C_IFACE,
-        .devtype                = ATECC508A,
-        .atcai2c.slave_address  = 0x07,
-        .atcai2c.bus            = busNum,
-        .atcai2c.baud           = 400000,
-        //.atcai2c.baud = 100000,
-        .wake_delay             = 800,
-        .rx_retries             = 3
-    };
-
-    ATCAHAL_t hal;
-
-    hal_i2c_init(&hal, &discoverCfg);
-    device = newATCADevice(&discoverCfg);
-    discoverIface = atGetIFace(device);
-    command = atGetCommands(device);
-
-    // iterate through all addresses on given i2c bus
-    // all valid 7-bit addresses go from 0x07 to 0x78
-    for (slaveAddress = 0x07; slaveAddress <= 0x78; slaveAddress++)
-    {
-        discoverCfg.atcai2c.slave_address = slaveAddress << 1;  // turn it into an 8-bit address which is what the rest of the i2c HAL is expecting when a packet is sent
-
-        // wake up device
-        // If it wakes, send it a dev rev command.  Based on that response, determine the device type
-        // BTW - this will wake every cryptoauth device living on the same bus (ecc508a, sha204a)
-
-        if (hal_i2c_wake(discoverIface) == ATCA_SUCCESS)
-        {
-            (*found)++;
-            memcpy( (uint8_t*)head, (uint8_t*)&discoverCfg, sizeof(ATCAIfaceCfg));
-
-            memset(&packet, 0x00, sizeof(packet));
-
-            // get devrev info and set device type accordingly
-            atInfo(command, &packet);
-
-            if ( (status = atGetExecTime(packet.opcode, command)) != ATCA_SUCCESS)
-            {
-                continue;
-            }
-
-
-            // send the command
-            if ( (status = atsend(discoverIface, (uint8_t*)&packet, packet.txsize)) != ATCA_SUCCESS)
-            {
-                printf("packet send error\r\n");
-                continue;
-            }
-
-            // delay the appropriate amount of time for command to execute
-            atca_delay_ms((command->execution_time_msec) + 1);
-
-            // receive the response
-            if ( (status = atreceive(discoverIface, &(packet.data[0]), &(packet.rxsize) )) != ATCA_SUCCESS)
-            {
-                continue;
-            }
-
-            if ( (status = isATCAError(packet.data)) != ATCA_SUCCESS)
-            {
-                printf("command response error\r\n");
-                continue;
-            }
-
-            // determine device type from common info and dev rev response byte strings
-            for (i = 0; i < (int)sizeof(revs608) / 4; i++)
-            {
-                if (memcmp(&packet.data[1], &revs608[i], 4) == 0)
-                {
-                    discoverCfg.devtype = ATECC608A;
-                    break;
-                }
-            }
-
-            for (i = 0; i < (int)sizeof(revs508) / 4; i++)
-            {
-                if (memcmp(&packet.data[1], &revs508[i], 4) == 0)
-                {
-                    discoverCfg.devtype = ATECC508A;
-                    break;
-                }
-            }
-
-            for (i = 0; i < (int)sizeof(revs204) / 4; i++)
-            {
-                if (memcmp(&packet.data[1], &revs204[i], 4) == 0)
-                {
-                    discoverCfg.devtype = ATSHA204A;
-                    break;
-                }
-            }
-
-            for (i = 0; i < (int)sizeof(revs108) / 4; i++)
-            {
-                if (memcmp(&packet.data[1], &revs108[i], 4) == 0)
-                {
-                    discoverCfg.devtype = ATECC108A;
-                    break;
-                }
-            }
-
-            atca_delay_ms(15);
-            // now the device type is known, so update the caller's cfg array element with it
-            head->devtype = discoverCfg.devtype;
-            head++;
-        }
-
-        hal_i2c_idle(discoverIface);
-    }
-
-    hal_i2c_release(&hal);
-
-    return ATCA_SUCCESS;
-}
-
-/** \brief
-    - this HAL implementation assumes you've included the ASF SERCOM I2C libraries in your project, otherwise,
-    the HAL layer will not compile because the ASF I2C drivers are a dependency *
- */
-
-/** \brief hal_i2c_init manages requests to initialize a physical interface.  it manages use counts so when an interface
- * has released the physical layer, it will disable the interface for some other use.
- * You can have multiple ATCAIFace instances using the same bus, and you can have multiple ATCAIFace instances on
- * multiple i2c buses, so hal_i2c_init manages these things and ATCAIFace is abstracted from the physical details.
- */
-
-/** \brief initialize an I2C interface using given config
- * \param[in] hal - opaque ptr to HAL data
- * \param[in] cfg - interface configuration
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-ATCA_STATUS hal_i2c_init(void *hal, ATCAIfaceCfg *cfg)
-{
-    int bus = cfg->atcai2c.bus;   // 0-based logical bus number
-    ATCAHAL_t *phal = (ATCAHAL_t*)hal;
-
-    if (i2c_bus_ref_ct == 0)       // power up state, no i2c buses will have been used
-    {
-        for (int i = 0; i < MAX_I2C_BUSES; i++)
-        {
-            i2c_hal_data[i] = NULL;
-        }
-    }
-
-    i2c_bus_ref_ct++;  // total across buses
-
-    if (bus >= 0 && bus < MAX_I2C_BUSES)
-    {
-        // if this is the first time this bus and interface has been created, do the physical work of enabling it
-        if (i2c_hal_data[bus] == NULL)
-        {
-            i2c_hal_data[bus] = malloc(sizeof(ATCAI2CMaster_t) );
-            i2c_hal_data[bus]->ref_ct = 1;  // buses are shared, this is the first instance
-            i2c_master_get_config_defaults(&config_i2c_master);
-#ifdef __SAMR21G18A__
-            if (bus == 1)
-            {
-                config_i2c_master.pinmux_pad0 = PINMUX_PA16C_SERCOM1_PAD0;
-                config_i2c_master.pinmux_pad1 = PINMUX_PA17C_SERCOM1_PAD1;
-            }
-#endif
-#ifdef __SAMD21G18A__
-            if (bus == 0)
-            {
-                // This is to support SAMW25 configs, where the WINC1500 is on SERCOM2
-                config_i2c_master.pinmux_pad0 = PINMUX_PA08C_SERCOM0_PAD0;
-                config_i2c_master.pinmux_pad1 = PINMUX_PA09C_SERCOM0_PAD1;
-            }
-#endif
-
-            // config_i2c_master.buffer_timeout = 10000;
-            config_i2c_master.baud_rate = cfg->atcai2c.baud / 1000;
-
-            switch (bus)
-            {
-            case 0: i2c_master_init(&(i2c_hal_data[bus]->i2c_master_instance), SERCOM0, &config_i2c_master); break;
-            case 1: i2c_master_init(&(i2c_hal_data[bus]->i2c_master_instance), SERCOM1, &config_i2c_master); break;
-            case 2: i2c_master_init(&(i2c_hal_data[bus]->i2c_master_instance), SERCOM2, &config_i2c_master); break;
-            case 3: i2c_master_init(&(i2c_hal_data[bus]->i2c_master_instance), SERCOM3, &config_i2c_master); break;
-            case 4: i2c_master_init(&(i2c_hal_data[bus]->i2c_master_instance), SERCOM4, &config_i2c_master); break;
-            case 5: i2c_master_init(&(i2c_hal_data[bus]->i2c_master_instance), SERCOM5, &config_i2c_master); break;
-            }
-
-            // store this for use during the release phase
-            i2c_hal_data[bus]->bus_index = bus;
-            i2c_master_enable(&(i2c_hal_data[bus]->i2c_master_instance));
-        }
-        else
-        {
-            // otherwise, another interface already initialized the bus, so this interface will share it and any different
-            // cfg parameters will be ignored...first one to initialize this sets the configuration
-            i2c_hal_data[bus]->ref_ct++;
-        }
-
-        phal->hal_data = i2c_hal_data[bus];
-
-        return ATCA_SUCCESS;
-    }
-
-    return ATCA_COMM_FAIL;
-}
-
-/** \brief HAL implementation of I2C post init
- * \param[in] iface  instance
- * \return ATCA_SUCCESS
- */
-ATCA_STATUS hal_i2c_post_init(ATCAIface iface)
-{
-    return ATCA_SUCCESS;
-}
-
-/** \brief HAL implementation of I2C send over ASF
- * \param[in] iface     instance
- * \param[in] txdata    pointer to space to bytes to send
- * \param[in] txlength  number of bytes to send
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-
-ATCA_STATUS hal_i2c_send(ATCAIface iface, uint8_t *txdata, int txlength)
-{
-    ATCAIfaceCfg *cfg = atgetifacecfg(iface);
-    int bus = cfg->atcai2c.bus;
-
-    struct i2c_master_packet packet = {
-        .address            = cfg->atcai2c.slave_address >> 1,
-        .data_length        = txlength,
-        .data               = txdata,
-        .ten_bit_address    = false,
-        .high_speed         = false,
-        .hs_master_code     = 0x0,
-    };
-
-    // for this implementation of I2C with CryptoAuth chips, txdata is assumed to have ATCAPacket format
-
-    // other device types that don't require i/o tokens on the front end of a command need a different hal_i2c_send and wire it up instead of this one
-    // this covers devices such as ATSHA204A and ATECCx08A that require a word address value pre-pended to the packet
-    // txdata[0] is using _reserved byte of the ATCAPacket
-    txdata[0] = 0x03;   // insert the Word Address Value, Command token
-    txlength++;         // account for word address value byte.
-    packet.data_length = txlength;
-
-    //	statusCode = i2c_master_write_packet_wait(&i2c_master_instance, &packet);
-    //if ( i2c_master_write_packet_wait_no_stop( &(i2c_hal_data[bus]->i2c_master_instance), &packet) != STATUS_OK)
-    if (i2c_master_write_packet_wait(&(i2c_hal_data[bus]->i2c_master_instance), &packet) != STATUS_OK)
-    {
-        return ATCA_COMM_FAIL;
-    }
-
-    return ATCA_SUCCESS;
-}
-
-/** \brief HAL implementation of I2C receive function for ASF I2C
- * \param[in] iface     instance
- * \param[out] rxdata    pointer to space to receive the data
- * \param[in] rxlength  ptr to expected number of receive bytes to request
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-
-ATCA_STATUS hal_i2c_receive(ATCAIface iface, uint8_t *rxdata, uint16_t *rxlength)
-{
-    ATCAIfaceCfg *cfg = atgetifacecfg(iface);
-    int bus = cfg->atcai2c.bus;
-    int retries = cfg->rx_retries;
-    int status = !STATUS_OK;
-
-    struct i2c_master_packet packet = {
-        .address            = cfg->atcai2c.slave_address >> 1,
-        .data_length        = *rxlength,
-        .data               = rxdata,
-        .ten_bit_address    = false,
-        .high_speed         = false,
-        .hs_master_code     = 0x0,
-    };
-
-    while (retries-- > 0 && status != STATUS_OK)
-    {
-        status = i2c_master_read_packet_wait(&(i2c_hal_data[bus]->i2c_master_instance), &packet);
-    }
-
-    if (status != STATUS_OK)
-    {
-        return ATCA_COMM_FAIL;
-    }
-
-    if (atCheckCrc(packet.data) != ATCA_SUCCESS)
-    {
-        return ATCA_COMM_FAIL;
-    }
-
-    return ATCA_SUCCESS;
-}
-
-/** \brief method to change the bus speec of I2C
- * \param[in] iface  interface on which to change bus speed
- * \param[in] speed  baud rate (typically 100000 or 400000)
- */
-
-void change_i2c_speed(ATCAIface iface, uint32_t speed)
-{
-    ATCAIfaceCfg *cfg = atgetifacecfg(iface);
-    int bus = cfg->atcai2c.bus;
-
-    config_i2c_master.buffer_timeout = 10000;
-    config_i2c_master.baud_rate = speed / 1000;
-
-    i2c_master_disable(&(i2c_hal_data[bus]->i2c_master_instance));
-
-    switch (bus)
-    {
-    case 0: i2c_master_init(&(i2c_hal_data[bus]->i2c_master_instance), SERCOM0, &config_i2c_master); break;
-    case 1: i2c_master_init(&(i2c_hal_data[bus]->i2c_master_instance), SERCOM1, &config_i2c_master); break;
-    case 2: i2c_master_init(&(i2c_hal_data[bus]->i2c_master_instance), SERCOM2, &config_i2c_master); break;
-    case 3: i2c_master_init(&(i2c_hal_data[bus]->i2c_master_instance), SERCOM3, &config_i2c_master); break;
-    case 4: i2c_master_init(&(i2c_hal_data[bus]->i2c_master_instance), SERCOM4, &config_i2c_master); break;
-    case 5: i2c_master_init(&(i2c_hal_data[bus]->i2c_master_instance), SERCOM5, &config_i2c_master); break;
-    }
-
-    i2c_master_enable(&(i2c_hal_data[bus]->i2c_master_instance));
-}
-
-/** \brief wake up CryptoAuth device using I2C bus
- * \param[in] iface  interface to logical device to wakeup
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-
-ATCA_STATUS hal_i2c_wake(ATCAIface iface)
-{
-    ATCAIfaceCfg *cfg = atgetifacecfg(iface);
-    int bus = cfg->atcai2c.bus;
-    int retries = cfg->rx_retries;
-    uint32_t bdrt = cfg->atcai2c.baud;
-    int status = !STATUS_OK;
-    uint8_t data[4], expected[4] = { 0x04, 0x11, 0x33, 0x43 };
-
-    if (bdrt != 100000)    // if not already at 100KHz, change it
-    {
-        change_i2c_speed(iface, 100000);
-    }
-
-    // Send the wake by writing to an address of 0x00
-    struct i2c_master_packet packet = {
-        .address            = 0x00,
-        .data_length        = 0,
-        .data               = &data[0],
-        .ten_bit_address    = false,
-        .high_speed         = false,
-        .hs_master_code     = 0x0,
-    };
-
-    // Send the 00 address as the wake pulse
-    i2c_master_write_packet_wait(&(i2c_hal_data[bus]->i2c_master_instance), &packet);       // part will NACK, so don't check for status
-
-    atca_delay_us(cfg->wake_delay);                                                         // wait tWHI + tWLO which is configured based on device type and configuration structure
-
-    packet.address = cfg->atcai2c.slave_address >> 1;
-    packet.data_length = 4;
-    packet.data = data;
-
-    while (retries-- > 0 && status != STATUS_OK)
-    {
-        status = i2c_master_read_packet_wait(&(i2c_hal_data[bus]->i2c_master_instance), &packet);
-    }
-
-    // if necessary, revert baud rate to what came in.
-    if (bdrt != 100000)
-    {
-        change_i2c_speed(iface, bdrt);
-    }
-
-    if (status != STATUS_OK)
-    {
-        return ATCA_COMM_FAIL;
-    }
-
-    if (memcmp(data, expected, 4) == 0)
-    {
-        return ATCA_SUCCESS;
-    }
-
-    return ATCA_COMM_FAIL;
-}
-
-/** \brief idle CryptoAuth device using I2C bus
- * \param[in] iface  interface to logical device to idle
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-
-ATCA_STATUS hal_i2c_idle(ATCAIface iface)
-{
-    ATCAIfaceCfg *cfg = atgetifacecfg(iface);
-    int bus = cfg->atcai2c.bus;
-    uint8_t data[4];
-
-    struct i2c_master_packet packet = {
-        .address            = cfg->atcai2c.slave_address >> 1,
-        .data_length        = 1,
-        .data               = &data[0],
-        .ten_bit_address    = false,
-        .high_speed         = false,
-        .hs_master_code     = 0x0,
-    };
-
-    data[0] = 0x02;  // idle word address value
-    if (i2c_master_write_packet_wait(&(i2c_hal_data[bus]->i2c_master_instance), &packet) != STATUS_OK)
-    {
-        return ATCA_COMM_FAIL;
-    }
-
-    return ATCA_SUCCESS;
-
-}
-
-/** \brief sleep CryptoAuth device using I2C bus
- * \param[in] iface  interface to logical device to sleep
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-
-ATCA_STATUS hal_i2c_sleep(ATCAIface iface)
-{
-    ATCAIfaceCfg *cfg = atgetifacecfg(iface);
-    int bus = cfg->atcai2c.bus;
-    uint8_t data[4];
-
-    struct i2c_master_packet packet = {
-        .address            = cfg->atcai2c.slave_address >> 1,
-        .data_length        = 1,
-        .data               = &data[0],
-        .ten_bit_address    = false,
-        .high_speed         = false,
-        .hs_master_code     = 0x0,
-    };
-
-    data[0] = 0x01;  // sleep word address value
-    if (i2c_master_write_packet_wait(&(i2c_hal_data[bus]->i2c_master_instance), &packet) != STATUS_OK)
-    {
-        return ATCA_COMM_FAIL;
-    }
-
-    return ATCA_SUCCESS;
-}
-
-/** \brief manages reference count on given bus and releases resource if no more refences exist
- * \param[in] hal_data - opaque pointer to hal data structure - known only to the HAL implementation
- * return ATCA_SUCCESS
- */
-
-ATCA_STATUS hal_i2c_release(void *hal_data)
-{
-    ATCAI2CMaster_t *hal = (ATCAI2CMaster_t*)hal_data;
-
-    i2c_bus_ref_ct--;  // track total i2c bus interface instances for consistency checking and debugging
-
-    // if the use count for this bus has gone to 0 references, disable it.  protect against an unbracketed release
-    if (hal && --(hal->ref_ct) <= 0 && i2c_hal_data[hal->bus_index] != NULL)
-    {
-        i2c_master_reset(&(hal->i2c_master_instance));
-        free(i2c_hal_data[hal->bus_index]);
-        i2c_hal_data[hal->bus_index] = NULL;
-    }
-
-    return ATCA_SUCCESS;
-}
-
-/** @} */
diff --git a/lib/hal/hal_samd21_i2c_asf.h b/lib/hal/hal_samd21_i2c_asf.h
deleted file mode 100644
index b8ff14d0123d..000000000000
--- a/lib/hal/hal_samd21_i2c_asf.h
+++ /dev/null
@@ -1,63 +0,0 @@
-/**
- * \file
- * \brief ATCA Hardware abstraction layer for SAMD21 I2C over ASF drivers.
- *
- * Prerequisite: add SERCOM I2C Master Polled support to application in Atmel Studio
- *
- * \copyright (c) 2017 Microchip Technology Inc. and its subsidiaries.
- *            You may use this software and any derivatives exclusively with
- *            Microchip products.
- *
- * \page License
- *
- * (c) 2017 Microchip Technology Inc. and its subsidiaries. You may use this
- * software and any derivatives exclusively with Microchip products.
- *
- * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
- * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
- * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
- * PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
- * WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
- *
- * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
- * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
- * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
- * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
- * FULLEST EXTENT ALLOWED BY LAW, MICROCHIPS TOTAL LIABILITY ON ALL CLAIMS IN
- * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
- * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
- *
- * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
- * TERMS.
- */
-
-#ifndef HAL_SAMD21_I2C_ASF_H_
-#define HAL_SAMD21_I2C_ASF_H_
-
-#include <asf.h>
-
-/** \defgroup hal_ Hardware abstraction layer (hal_)
- *
- * \brief
- * These methods define the hardware abstraction layer for communicating with a CryptoAuth device
- * using I2C driver of ASF.
- *
-   @{ */
-
-
-#define MAX_I2C_BUSES    6   // SAMD21 has up to 6 SERCOMS that can be configured as I2C
-
-/** \brief this is the hal_data for ATCA HAL for ASF SERCOM
- */
-typedef struct atcaI2Cmaster
-{
-    struct i2c_master_module i2c_master_instance;
-    int                      ref_ct;
-    // for conveniences during interface release phase
-    int bus_index;
-} ATCAI2CMaster_t;
-
-void change_i2c_speed(ATCAIface iface, uint32_t speed);
-
-/** @} */
-#endif /* HAL_SAMD21_I2C_ASF_H_ */
\ No newline at end of file
diff --git a/lib/hal/hal_samd21_i2c_start.c b/lib/hal/hal_samd21_i2c_start.c
deleted file mode 100644
index 5bade0768ef0..000000000000
--- a/lib/hal/hal_samd21_i2c_start.c
+++ /dev/null
@@ -1,545 +0,0 @@
-/**
- * \file
- * \brief ATCA Hardware abstraction layer for SAMD21 I2C over START drivers.
- *
- * This code is structured in two parts.  Part 1 is the connection of the ATCA HAL API to the physical I2C
- * implementation. Part 2 is the START I2C primitives to set up the interface.
- *
- * Prerequisite: add SERCOM I2C Master Polled support to application in Atmel Studio
- *
- * \copyright (c) 2017 Microchip Technology Inc. and its subsidiaries.
- *            You may use this software and any derivatives exclusively with
- *            Microchip products.
- *
- * \page License
- *
- * (c) 2017 Microchip Technology Inc. and its subsidiaries. You may use this
- * software and any derivatives exclusively with Microchip products.
- *
- * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
- * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
- * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
- * PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
- * WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
- *
- * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
- * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
- * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
- * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
- * FULLEST EXTENT ALLOWED BY LAW, MICROCHIPS TOTAL LIABILITY ON ALL CLAIMS IN
- * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
- * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
- *
- * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
- * TERMS.
- */
- #include <string.h>
-#include <stdio.h>
-#include <atmel_start.h>
-#include <hal_gpio.h>
-#include <hal_delay.h>
-#include "atca_hal.h"
-#include "atca_device.h"
-#include "hal_samd21_i2c_start.h"
-#include "peripheral_gclk_config.h"
-
-#include "atca_start_config.h"
-#include "atca_start_iface.h"
-
-/** \defgroup hal_ Hardware abstraction layer (hal_)
- *
- * \brief
- * These methods define the hardware abstraction layer for communicating with a CryptoAuth device
- *
-   @{ */
-
-ATCAI2CMaster_t *i2c_hal_data[MAX_I2C_BUSES];   // map logical, 0-based bus number to index
-int i2c_bus_ref_ct = 0;                         // total in-use count across buses
-
-/* Notes:
-    - this HAL implementation assumes you've included the Atmel START SERCOM I2C libraries in your project, otherwise,
-    the HAL layer will not compile because the START I2C drivers are a dependency *
- */
-
-/** \brief discover i2c buses available for this hardware
- * this maintains a list of logical to physical bus mappings freeing the application
- * of the a-priori knowledge
- * \param[in] i2c_buses - an array of logical bus numbers
- * \param[in] max_buses - maximum number of buses the app wants to attempt to discover
- * \return ATCA_SUCCESS
- */
-
-ATCA_STATUS hal_i2c_discover_buses(int i2c_buses[], int max_buses)
-{
-
-    /* if every SERCOM was a likely candidate bus, then would need to initialize the entire array to all SERCOM n numbers.
-     * As an optimization and making discovery safer, make assumptions about bus-num / SERCOM map based on D21 Xplained Pro board
-     * If you were using a raw D21 on your own board, you would supply your own bus numbers based on your particular hardware configuration.
-     */
-#ifdef __SAMR21G18A__
-    i2c_buses[0] = 1;   // default r21 for xplained pro dev board
-#else
-    i2c_buses[0] = 2;   // default d21 for xplained pro dev board
-#endif
-
-    return ATCA_SUCCESS;
-}
-
-/** \brief discover any CryptoAuth devices on a given logical bus number
- * \param[in]  busNum  logical bus number on which to look for CryptoAuth devices
- * \param[out] cfg     pointer to head of an array of interface config structures which get filled in by this method
- * \param[out] found   number of devices found on this bus
- * \return ATCA_SUCCESS
- */
-
-ATCA_STATUS hal_i2c_discover_devices(int busNum, ATCAIfaceCfg cfg[], int *found)
-{
-    ATCAIfaceCfg *head = cfg;
-    uint8_t slaveAddress = 0x01;
-    ATCADevice device;
-    ATCAIface discoverIface;
-    ATCACommand command;
-    ATCAPacket packet;
-    ATCA_STATUS status;
-    uint8_t revs608[1][4] = { { 0x00, 0x00, 0x60, 0x01 } };
-    uint8_t revs508[1][4] = { { 0x00, 0x00, 0x50, 0x00 } };
-    uint8_t revs108[1][4] = { { 0x80, 0x00, 0x10, 0x01 } };
-    uint8_t revs204[3][4] = { { 0x00, 0x02, 0x00, 0x08 },
-                              { 0x00, 0x02, 0x00, 0x09 },
-                              { 0x00, 0x04, 0x05, 0x00 } };
-    int i;
-
-    /** \brief default configuration, to be reused during discovery process */
-    ATCAIfaceCfg discoverCfg = {
-        .iface_type             = ATCA_I2C_IFACE,
-        .devtype                = ATECC508A,
-        .atcai2c.slave_address  = 0x07,
-        .atcai2c.bus            = busNum,
-        .atcai2c.baud           = 400000,
-        //.atcai2c.baud = 100000,
-        .wake_delay             = 800,
-        .rx_retries             = 3
-    };
-
-    ATCAHAL_t hal;
-
-    hal_i2c_init(&hal, &discoverCfg);
-    device = newATCADevice(&discoverCfg);
-    discoverIface = atGetIFace(device);
-    command = atGetCommands(device);
-
-    // iterate through all addresses on given i2c bus
-    // all valid 7-bit addresses go from 0x07 to 0x78
-    for (slaveAddress = 0x07; slaveAddress <= 0x78; slaveAddress++)
-    {
-        discoverCfg.atcai2c.slave_address = slaveAddress << 1;  // turn it into an 8-bit address which is what the rest of the i2c HAL is expecting when a packet is sent
-
-        // wake up device
-        // If it wakes, send it a dev rev command.  Based on that response, determine the device type
-        // BTW - this will wake every cryptoauth device living on the same bus (ecc508a, sha204a)
-
-        if (hal_i2c_wake(discoverIface) == ATCA_SUCCESS)
-        {
-            (*found)++;
-            memcpy( (uint8_t*)head, (uint8_t*)&discoverCfg, sizeof(ATCAIfaceCfg));
-
-            memset(&packet, 0x00, sizeof(packet));
-
-            // get devrev info and set device type accordingly
-            atInfo(command, &packet);
-            if ((status = atGetExecTime(packet.opcode, command)) != ATCA_SUCCESS)
-            {
-                continue;
-            }
-
-            // send the command
-            if ( (status = atsend(discoverIface, (uint8_t*)&packet, packet.txsize)) != ATCA_SUCCESS)
-            {
-                printf("packet send error\r\n");
-                continue;
-            }
-
-            // delay the appropriate amount of time for command to execute
-            atca_delay_ms((command->execution_time_msec) + 1);
-
-            // receive the response
-            if ( (status = atreceive(discoverIface, &(packet.data[0]), &(packet.rxsize) )) != ATCA_SUCCESS)
-            {
-                continue;
-            }
-
-            if ( (status = isATCAError(packet.data)) != ATCA_SUCCESS)
-            {
-                printf("command response error\r\n");
-                continue;
-            }
-
-            // determine device type from common info and dev rev response byte strings
-
-            for (i = 0; i < (int)sizeof(revs608) / 4; i++)
-            {
-                if (memcmp(&packet.data[1], &revs608[i], 4) == 0)
-                {
-                    discoverCfg.devtype = ATECC608A;
-                    break;
-                }
-            }
-
-            for (i = 0; i < (int)sizeof(revs508) / 4; i++)
-            {
-                if (memcmp(&packet.data[1], &revs508[i], 4) == 0)
-                {
-                    discoverCfg.devtype = ATECC508A;
-                    break;
-                }
-            }
-
-            for (i = 0; i < (int)sizeof(revs204) / 4; i++)
-            {
-                if (memcmp(&packet.data[1], &revs204[i], 4) == 0)
-                {
-                    discoverCfg.devtype = ATSHA204A;
-                    break;
-                }
-            }
-
-            for (i = 0; i < (int)sizeof(revs108) / 4; i++)
-            {
-                if (memcmp(&packet.data[1], &revs108[i], 4) == 0)
-                {
-                    discoverCfg.devtype = ATECC108A;
-                    break;
-                }
-            }
-
-            atca_delay_ms(15);
-            // now the device type is known, so update the caller's cfg array element with it
-            head->devtype = discoverCfg.devtype;
-            head++;
-        }
-
-        hal_i2c_idle(discoverIface);
-    }
-
-    hal_i2c_release(&hal);
-
-    return ATCA_SUCCESS;
-}
-
-
-
-/** \brief
-    - this HAL implementation assumes you've included the START Twi libraries in your project, otherwise,
-    the HAL layer will not compile because the START TWI drivers are a dependency *
- */
-
-/** \brief hal_i2c_init manages requests to initialize a physical interface.  it manages use counts so when an interface
- * has released the physical layer, it will disable the interface for some other use.
- * You can have multiple ATCAIFace instances using the same bus, and you can have multiple ATCAIFace instances on
- * multiple i2c buses, so hal_i2c_init manages these things and ATCAIFace is abstracted from the physical details.
- */
-
-/** \brief initialize an I2C interface using given config
- * \param[in] hal - opaque ptr to HAL data
- * \param[in] cfg - interface configuration
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-
-ATCA_STATUS hal_i2c_init(void *hal, ATCAIfaceCfg *cfg)
-{
-    int bus = cfg->atcai2c.bus; // 0-based logical bus number
-    ATCAHAL_t *phal = (ATCAHAL_t*)hal;
-    uint32_t freq_constant;     // I2C frequency configuration constant in kHz
-
-    if (i2c_bus_ref_ct == 0)    // power up state, no i2c buses will have been used
-    {
-        for (int i = 0; i < MAX_I2C_BUSES; i++)
-        {
-            i2c_hal_data[i] = NULL;
-        }
-    }
-
-    i2c_bus_ref_ct++;  // total across buses
-
-    if (bus >= 0 && bus < MAX_I2C_BUSES)
-    {
-        // if this is the first time this bus and interface has been created, do the physical work of enabling it
-        if (i2c_hal_data[bus] == NULL)
-        {
-            i2c_hal_data[bus] = malloc(sizeof(ATCAI2CMaster_t) );
-            i2c_hal_data[bus]->ref_ct = 1;  // buses are shared, this is the first instance
-
-            // store I2C baudrate in kHz
-            freq_constant = cfg->atcai2c.baud / 1000;
-
-            switch (bus)
-            {
-            case 0: break;
-            case 1: break;
-            case 2: memcpy(&(i2c_hal_data[bus]->i2c_master_instance), &I2C_0, sizeof(struct i2c_m_sync_desc)); break;
-            case 3: break;
-            case 4: break;
-            case 5: break;
-            }
-
-            // store this for use during the release phase
-            i2c_hal_data[bus]->bus_index = bus;
-
-            // set I2C baudrate and enable I2C module
-            i2c_m_sync_set_baudrate(&(i2c_hal_data[bus]->i2c_master_instance), CONF_GCLK_SERCOM2_CORE_FREQUENCY / 1000, freq_constant);
-            i2c_m_sync_enable(&(i2c_hal_data[bus]->i2c_master_instance));
-
-        }
-        else
-        {
-            // otherwise, another interface already initialized the bus, so this interface will share it and any different
-            // cfg parameters will be ignored...first one to initialize this sets the configuration
-            i2c_hal_data[bus]->ref_ct++;
-        }
-        phal->hal_data = i2c_hal_data[bus];
-
-        return ATCA_SUCCESS;
-    }
-
-    return ATCA_COMM_FAIL;
-}
-
-/** \brief HAL implementation of I2C post init
- * \param[in] iface  instance
- * \return ATCA_SUCCESS
- */
-ATCA_STATUS hal_i2c_post_init(ATCAIface iface)
-{
-    return ATCA_SUCCESS;
-}
-
-/** \brief HAL implementation of I2C send over START
- * \param[in] iface     instance
- * \param[in] txdata    pointer to space to bytes to send
- * \param[in] txlength  number of bytes to send
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-
-ATCA_STATUS hal_i2c_send(ATCAIface iface, uint8_t *txdata, int txlength)
-{
-    ATCAIfaceCfg *cfg = atgetifacecfg(iface);
-    int bus = cfg->atcai2c.bus;
-
-    struct _i2c_m_msg packet = {
-        .addr   = cfg->atcai2c.slave_address >> 1,
-        .buffer = txdata,
-        .flags  = I2C_M_SEVEN | I2C_M_STOP,
-    };
-
-    // for this implementation of I2C with CryptoAuth chips, txdata is assumed to have ATCAPacket format
-
-    // other device types that don't require i/o tokens on the front end of a command need a different hal_i2c_send and wire it up instead of this one
-    // this covers devices such as ATSHA204A and ATECCx08A that require a word address value pre-pended to the packet
-    // txdata[0] is using _reserved byte of the ATCAPacket
-    txdata[0] = 0x03;   // insert the Word Address Value, Command token
-    txlength++;         // account for word address value byte.
-    packet.len = txlength;
-
-    if (i2c_m_sync_transfer(&(i2c_hal_data[bus]->i2c_master_instance), &packet) != I2C_OK)
-    {
-        return ATCA_COMM_FAIL;
-    }
-
-    return ATCA_SUCCESS;
-}
-
-/** \brief HAL implementation of I2C receive function for START I2C
- * \param[in] iface     instance
- * \param[out] rxdata    pointer to space to receive the data
- * \param[in] rxlength  ptr to expected number of receive bytes to request
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-
-ATCA_STATUS hal_i2c_receive(ATCAIface iface, uint8_t *rxdata, uint16_t *rxlength)
-{
-    ATCAIfaceCfg *cfg = atgetifacecfg(iface);
-    int bus = cfg->atcai2c.bus;
-    int retries = cfg->rx_retries;
-    int status = !I2C_OK;
-
-    struct _i2c_m_msg packet = {
-        .addr   = cfg->atcai2c.slave_address >> 1,
-        .len    = *rxlength,
-        .buffer = rxdata,
-        .flags  = I2C_M_SEVEN | I2C_M_RD | I2C_M_STOP,
-    };
-
-    while (retries-- > 0 && status != I2C_OK)
-    {
-        status = i2c_m_sync_transfer(&(i2c_hal_data[bus]->i2c_master_instance), &packet);
-    }
-
-    if (status != I2C_OK)
-    {
-        return ATCA_COMM_FAIL;
-    }
-
-    return ATCA_SUCCESS;
-}
-
-/** \brief method to change the bus speec of I2C
- * \param[in] iface  interface on which to change bus speed
- * \param[in] speed  baud rate (typically 100000 or 400000)
- */
-
-void change_i2c_speed(ATCAIface iface, uint32_t speed)
-{
-    ATCAIfaceCfg *cfg = atgetifacecfg(iface);
-    int bus = cfg->atcai2c.bus;
-    uint32_t freq_constant; // I2C frequency configuration constant
-
-    // disable I2C module
-    i2c_m_sync_disable(&(i2c_hal_data[bus]->i2c_master_instance));
-
-    // store I2C baudrate in kHz
-    freq_constant = speed / 1000;
-
-    // set I2C baudrate and enable I2C module
-    i2c_m_sync_set_baudrate(&(i2c_hal_data[bus]->i2c_master_instance), CONF_GCLK_SERCOM2_CORE_FREQUENCY / 1000, freq_constant);
-    i2c_m_sync_enable(&(i2c_hal_data[bus]->i2c_master_instance));
-}
-
-/** \brief wake up CryptoAuth device using I2C bus
- * \param[in] iface  interface to logical device to wakeup
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-
-ATCA_STATUS hal_i2c_wake(ATCAIface iface)
-{
-    ATCAIfaceCfg *cfg = atgetifacecfg(iface);
-    int bus = cfg->atcai2c.bus;
-    int retries = cfg->rx_retries;
-    uint32_t bdrt = cfg->atcai2c.baud;
-    int status = !I2C_OK;
-    uint8_t data[4], expected[4] = { 0x04, 0x11, 0x33, 0x43 };
-
-    if (bdrt != 100000)    // if not already at 100KHz, change it
-    {
-        change_i2c_speed(iface, 100000);
-    }
-
-    // send the wake by writing to an address of 0x00
-    struct _i2c_m_msg packet = {
-        .addr   = 0x00,
-        .len    = 0,
-        .buffer = NULL,
-        .flags  = I2C_M_SEVEN | I2C_M_STOP,
-    };
-
-    // Send the 00 address as the wake pulse
-    status = i2c_m_sync_transfer(&(i2c_hal_data[bus]->i2c_master_instance), &packet);   // part will NACK, so don't check for status
-
-    delay_us(cfg->wake_delay);                                                          // wait tWHI + tWLO which is configured based on device type and configuration structure
-
-    // receive the wake up response
-    packet.addr = cfg->atcai2c.slave_address >> 1;
-    packet.len = 4;
-    packet.buffer = data;
-    packet.flags  = I2C_M_SEVEN | I2C_M_RD | I2C_M_STOP;
-
-    while (retries-- > 0 && status != I2C_OK)
-    {
-        status = i2c_m_sync_transfer(&(i2c_hal_data[bus]->i2c_master_instance), &packet);
-    }
-
-    if (status == I2C_OK)
-    {
-        // if necessary, revert baud rate to what came in.
-        if (bdrt != 100000)
-        {
-            change_i2c_speed(iface, bdrt);
-        }
-        // compare received data with expected value
-        if (memcmp(data, expected, 4) == 0)
-        {
-            return ATCA_SUCCESS;
-        }
-    }
-
-    return ATCA_COMM_FAIL;
-}
-
-/** \brief idle CryptoAuth device using I2C bus
- * \param[in] iface  interface to logical device to idle
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-
-ATCA_STATUS hal_i2c_idle(ATCAIface iface)
-{
-    ATCAIfaceCfg *cfg = atgetifacecfg(iface);
-    int bus = cfg->atcai2c.bus;
-    uint8_t data[4];
-
-    struct _i2c_m_msg packet = {
-        .addr   = cfg->atcai2c.slave_address >> 1,
-        .len    = 1,
-        .buffer = &data[0],
-        .flags  = I2C_M_SEVEN | I2C_M_STOP,
-    };
-
-    data[0] = 0x02;  // idle word address value
-
-    if (i2c_m_sync_transfer(&(i2c_hal_data[bus]->i2c_master_instance), &packet) != I2C_OK)
-    {
-        return ATCA_COMM_FAIL;
-    }
-
-    return ATCA_SUCCESS;
-}
-
-/** \brief sleep CryptoAuth device using I2C bus
- * \param[in] iface  interface to logical device to sleep
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-
-ATCA_STATUS hal_i2c_sleep(ATCAIface iface)
-{
-    ATCAIfaceCfg *cfg = atgetifacecfg(iface);
-    int bus = cfg->atcai2c.bus;
-    uint8_t data[4];
-
-    struct _i2c_m_msg packet = {
-        .addr   = cfg->atcai2c.slave_address >> 1,
-        .len    = 1,
-        .buffer = &data[0],
-        .flags  = I2C_M_SEVEN | I2C_M_STOP,
-    };
-
-    data[0] = 0x01;  // sleep word address value
-
-    if (i2c_m_sync_transfer(&(i2c_hal_data[bus]->i2c_master_instance), &packet) != I2C_OK)
-    {
-        return ATCA_COMM_FAIL;
-    }
-
-    return ATCA_SUCCESS;
-}
-
-/** \brief manages reference count on given bus and releases resource if no more refences exist
- * \param[in] hal_data - opaque pointer to hal data structure - known only to the HAL implementation
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-
-ATCA_STATUS hal_i2c_release(void *hal_data)
-{
-    ATCAI2CMaster_t *hal = (ATCAI2CMaster_t*)hal_data;
-
-    i2c_bus_ref_ct--;  // track total i2c bus interface instances for consistency checking and debugging
-
-    //if the use count for this bus has gone to 0 references, disable it.  protect against an unbracketed release
-    if (hal && --(hal->ref_ct) <= 0 && i2c_hal_data[hal->bus_index] != NULL)
-    {
-        i2c_m_sync_disable(&(hal->i2c_master_instance));
-        free(i2c_hal_data[hal->bus_index]);
-        i2c_hal_data[hal->bus_index] = NULL;
-    }
-
-    return ATCA_SUCCESS;
-}
-
-/** @} */
diff --git a/lib/hal/hal_samd21_i2c_start.h b/lib/hal/hal_samd21_i2c_start.h
deleted file mode 100644
index 08a50093dd9a..000000000000
--- a/lib/hal/hal_samd21_i2c_start.h
+++ /dev/null
@@ -1,64 +0,0 @@
-/**
- * \file
- * \brief ATCA Hardware abstraction layer for SAMD21 I2C over START drivers.
- *
- * Prerequisite: add SERCOM I2C Master Polled support to application in Atmel Studio
- *
- * \copyright (c) 2017 Microchip Technology Inc. and its subsidiaries.
- *            You may use this software and any derivatives exclusively with
- *            Microchip products.
- *
- * \page License
- *
- * (c) 2017 Microchip Technology Inc. and its subsidiaries. You may use this
- * software and any derivatives exclusively with Microchip products.
- *
- * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
- * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
- * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
- * PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
- * WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
- *
- * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
- * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
- * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
- * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
- * FULLEST EXTENT ALLOWED BY LAW, MICROCHIPS TOTAL LIABILITY ON ALL CLAIMS IN
- * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
- * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
- *
- * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
- * TERMS.
- */
-
-#ifndef HAL_SAMD21_I2C_START_H_
-#define HAL_SAMD21_I2C_START_H_
-
-#include "atmel_start.h"
-#include <stdlib.h>
-
-/** \defgroup hal_ Hardware abstraction layer (hal_)
- *
- * \brief
- * These methods define the hardware abstraction layer for communicating with a CryptoAuth device
- *
-   @{ */
-
-
-#define MAX_I2C_BUSES    6   // SAMD21 has up to 6 SERCOMS that can be configured as I2C
-
-/** \brief this is the hal_data for ATCA HAL for Atmel START SERCOM
- */
-typedef struct atcaI2Cmaster
-{
-    struct i2c_m_sync_desc i2c_master_instance;
-    int                    ref_ct;
-    // for conveniences during interface release phase
-    int bus_index;
-} ATCAI2CMaster_t;
-
-void change_i2c_speed(ATCAIface iface, uint32_t speed);
-
-/** @} */
-
-#endif /* HAL_SAMD21_I2C_START_H_ */
diff --git a/lib/hal/hal_samd21_timer_asf.c b/lib/hal/hal_samd21_timer_asf.c
deleted file mode 100644
index ba191e400f3c..000000000000
--- a/lib/hal/hal_samd21_timer_asf.c
+++ /dev/null
@@ -1,79 +0,0 @@
-/**
- * \file
- * \brief ATCA Hardware abstraction layer for SAMD21 timer/delay over ASF drivers.
- *
- * \copyright (c) 2017 Microchip Technology Inc. and its subsidiaries.
- *            You may use this software and any derivatives exclusively with
- *            Microchip products.
- *
- * \page License
- *
- * (c) 2017 Microchip Technology Inc. and its subsidiaries. You may use this
- * software and any derivatives exclusively with Microchip products.
- *
- * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
- * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
- * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
- * PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
- * WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
- *
- * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
- * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
- * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
- * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
- * FULLEST EXTENT ALLOWED BY LAW, MICROCHIPS TOTAL LIABILITY ON ALL CLAIMS IN
- * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
- * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
- *
- * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
- * TERMS.
- */
-
-#include <asf.h>
-#include <delay.h>
-#include "atca_hal.h"
-
-/** \defgroup hal_ Hardware abstraction layer (hal_)
- *
- * \brief
- * These methods define the hardware abstraction layer for communicating with a CryptoAuth device
- *
-   @{ */
-
-
-/** \brief This function delays for a number of microseconds.
- *
- * \param[in] delay number of 0.001 milliseconds to delay
- */
-void atca_delay_us(uint32_t delay)
-{
-    // use ASF supplied delay
-    delay_us(delay);
-}
-
-/** \brief This function delays for a number of tens of microseconds.
- *
- * \param[in] delay number of 0.01 milliseconds to delay
- */
-void atca_delay_10us(uint32_t delay)
-{
-    // use ASF supplied delay
-    delay_us(delay * 10);
-
-}
-
-/** \brief This function delays for a number of milliseconds.
- *
- *         You can override this function if you like to do
- *         something else in your system while delaying.
- * \param[in] delay number of milliseconds to delay
- */
-
-/* ASF already has delay_ms - see delay.h */
-void atca_delay_ms(uint32_t delay)
-{
-    // use ASF supplied delay
-    delay_ms(delay);
-}
-
-/** @} */
diff --git a/lib/hal/hal_samd21_timer_start.c b/lib/hal/hal_samd21_timer_start.c
deleted file mode 100644
index 1204331466ab..000000000000
--- a/lib/hal/hal_samd21_timer_start.c
+++ /dev/null
@@ -1,80 +0,0 @@
-/**
- * \file
- * \brief ATCA Hardware abstraction layer for SAMD21 I2C over START drivers.
- *
- * Prerequisite: add SERCOM I2C Master Polled support to application in Atmel Studio
- *
- * \copyright (c) 2017 Microchip Technology Inc. and its subsidiaries.
- *            You may use this software and any derivatives exclusively with
- *            Microchip products.
- *
- * \page License
- *
- * (c) 2017 Microchip Technology Inc. and its subsidiaries. You may use this
- * software and any derivatives exclusively with Microchip products.
- *
- * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
- * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
- * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
- * PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
- * WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
- *
- * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
- * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
- * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
- * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
- * FULLEST EXTENT ALLOWED BY LAW, MICROCHIPS TOTAL LIABILITY ON ALL CLAIMS IN
- * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
- * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
- *
- * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
- * TERMS.
- */
-
-#include <hal_delay.h>
-#include "atca_hal.h"
-
-/** \defgroup hal_ Hardware abstraction layer (hal_)
- *
- * \brief
- * These methods define the hardware abstraction layer for communicating with a CryptoAuth device
- *
-   @{ */
-
-
-/** \brief This function delays for a number of microseconds.
- *
- * \param[in] delay number of microseconds to delay
- */
-
-void atca_delay_us(uint32_t delay)
-{
-    // use START supplied delay
-    delay_us(delay);
-}
-
-/** \brief This function delays for a number of tens of microseconds.
- *
- * \param[in] delay number of 0.01 milliseconds to delay
- */
-
-void atca_delay_10us(uint32_t delay)
-{
-    // use START supplied delay
-    delay_us(delay * 10);
-}
-
-/** \brief This function delays for a number of milliseconds.
- *
- *         You can override this function if you like to do
- *         something else in your system while delaying.
- * \param[in] delay number of milliseconds to delay
- */
-
-void atca_delay_ms(uint32_t delay)
-{
-    // use START supplied delay
-    delay_ms(delay);
-}
-
-/** @} */
diff --git a/lib/hal/hal_samg55_i2c_asf.c b/lib/hal/hal_samg55_i2c_asf.c
deleted file mode 100644
index 37a7ddd9348d..000000000000
--- a/lib/hal/hal_samg55_i2c_asf.c
+++ /dev/null
@@ -1,661 +0,0 @@
-/**
- * \file
- * \brief ATCA Hardware abstraction layer for SAMG55 I2C over ASF drivers.
- *
- * This code is structured in two parts.  Part 1 is the connection of the ATCA HAL API to the physical I2C
- * implementation. Part 2 is the ASF I2C primitives to set up the interface.
- *
- * Prerequisite: add "TWI - Two-Wire Interface (Common API) (service)" module to application in Atmel Studio
- *
- * \copyright (c) 2017 Microchip Technology Inc. and its subsidiaries.
- *            You may use this software and any derivatives exclusively with
- *            Microchip products.
- *
- * \page License
- *
- * (c) 2017 Microchip Technology Inc. and its subsidiaries. You may use this
- * software and any derivatives exclusively with Microchip products.
- *
- * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
- * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
- * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
- * PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
- * WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
- *
- * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
- * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
- * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
- * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
- * FULLEST EXTENT ALLOWED BY LAW, MICROCHIPS TOTAL LIABILITY ON ALL CLAIMS IN
- * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
- * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
- *
- * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
- * TERMS.
- */
-
-#include <asf.h>
-#include <string.h>
-#include <stdio.h>
-#include "atca_hal.h"
-#include "atca_device.h"
-#include "hal_samg55_i2c_asf.h"
-
-
-//!< Uncomment when debugging
-/*#define DEBUG_HAL*/
-
-/**
- * \defgroup hal_ Hardware abstraction layer (hal_)
- *
- * \brief
- * These methods define the hardware abstraction layer for communicating with a CryptoAuth device
- * using I2C driver of ASF.
- *
-   @{ */
-
-/**
- * \brief
- * Logical to physical bus mapping structure
- */
-ATCAI2CMaster_t *i2c_hal_data[MAX_I2C_BUSES];   // map logical, 0-based bus number to index
-int i2c_bus_ref_ct = 0;                         // total in-use count across buses
-twi_options_t opt_twi_master;
-
-
-#ifdef DEBUG_HAL
-static void print_array(uint8_t *data, uint32_t data_size)
-{
-    uint32_t n;
-
-    for (n = 0; n < data_size; n++)
-    {
-        printf("%.2x ", data[n]);
-        if (((n + 1) % 16) == 0)
-        {
-            printf("\r\n");
-            if ((n + 1) != data_size)
-            {
-                printf("         ");
-            }
-        }
-    }
-    if (data_size % 16 != 0)
-    {
-        printf("\r\n");
-    }
-}
-#endif
-
-/**
- * \brief
- * This HAL implementation assumes you've included the ASF TWI libraries in your project, otherwise,
- * the HAL layer will not compile because the ASF TWI drivers are a dependency
- */
-
-/** \brief discover i2c buses available for this hardware
- * this maintains a list of logical to physical bus mappings freeing the application
- * of the a-priori knowledge
- * \param[in] i2c_buses - an array of logical bus numbers
- * \param[in] max_buses - maximum number of buses the app wants to attempt to discover
- * return ATCA_SUCCESS
- */
-
-ATCA_STATUS hal_i2c_discover_buses(int i2c_buses[], int max_buses)
-{
-    /* logical bus numbers 0-2 map to the samG55 i2c buses:
-     */
-    i2c_buses[0] = 0;
-
-    return ATCA_SUCCESS;
-}
-
-/** \brief discover any CryptoAuth devices on a given logical bus number
- * \param[in] busNum - logical bus number on which to look for CryptoAuth devices
- * \param[out] cfg[] - pointer to head of an array of interface config structures which get filled in by this method
- * \param[out] *found - number of devices found on this bus
- * \return ATCA_SUCCESS
- */
-
-ATCA_STATUS hal_i2c_discover_devices(int busNum, ATCAIfaceCfg cfg[], int *found)
-{
-    ATCAIfaceCfg *head = cfg;
-    uint8_t slaveAddress = 0x01;
-    ATCADevice device;
-    ATCAIface discoverIface;
-    ATCACommand command;
-    ATCAPacket packet;
-    ATCA_STATUS status;
-    uint8_t revs508[1][4] = { { 0x00, 0x00, 0x50, 0x00 } };
-    uint8_t revs108[1][4] = { { 0x80, 0x00, 0x10, 0x01 } };
-    uint8_t revs204[3][4] = { { 0x00, 0x02, 0x00, 0x08 },
-                              { 0x00, 0x02, 0x00, 0x09 },
-                              { 0x00, 0x04, 0x05, 0x00 } };
-    int i;
-
-    /** \brief default configuration, to be reused during discovery process */
-    ATCAIfaceCfg discoverCfg = {
-        .iface_type               = ATCA_I2C_IFACE,
-        .devtype                  = ATECC508A,
-        .atcai2c.slave_address    = 0x07,
-        .atcai2c.bus              = busNum,
-        .atcai2c.baud             = 400000,
-        .wake_delay               = 800,
-        .rx_retries               = 3
-    };
-
-    ATCAHAL_t hal;
-
-    if (busNum < 0)
-    {
-        return ATCA_COMM_FAIL;
-    }
-
-    hal_i2c_init(&hal, &discoverCfg);
-    device = newATCADevice(&discoverCfg);
-    discoverIface = atGetIFace(device);
-    command = atGetCommands(device);
-
-    // iterate through all addresses on given i2c bus
-    // all valid 7-bit addresses go from 0x07 to 0x78
-    for (slaveAddress = 0x07; slaveAddress <= 0x78; slaveAddress++)
-    {
-        discoverCfg.atcai2c.slave_address = slaveAddress << 1; // turn it into an 8-bit address which is what the rest of the i2c HAL is expecting when a packet is sent
-
-        // wake up device
-        // If it wakes, send it a dev rev command.  Based on that response, determine the device type
-        // BTW - this will wake every cryptoauth device living on the same bus (ecc508a, sha204a)
-
-        if (hal_i2c_wake(discoverIface) == ATCA_SUCCESS)
-        {
-            (*found)++;
-            memcpy( (uint8_t*)head, (uint8_t*)&discoverCfg, sizeof(ATCAIfaceCfg));
-
-            memset(packet.data, 0x00, sizeof(packet.data));
-
-            // get devrev info and set device type accordingly
-            atInfo(command, &packet);
-            if ((status = atGetExecTime(packet.opcode, command)) != ATCA_SUCCESS)
-            {
-                continue;
-            }
-
-            // send the command
-            if ( (status = atsend(discoverIface, (uint8_t*)&packet, packet.txsize)) != ATCA_SUCCESS)
-            {
-                printf("packet send error\r\n");
-                continue;
-            }
-
-            // delay the appropriate amount of time for command to execute
-            atca_delay_ms((command->execution_time_msec) + 1);
-
-            // receive the response
-            if ( (status = atreceive(discoverIface, &(packet.data[0]), &(packet.rxsize) )) != ATCA_SUCCESS)
-            {
-                continue;
-            }
-
-            if ( (status = isATCAError(packet.data)) != ATCA_SUCCESS)
-            {
-                continue;
-            }
-
-            // determine device type from common info and dev rev response byte strings
-            for (i = 0; i < (int)sizeof(revs508) / 4; i++)
-            {
-                if (memcmp(&packet.data[1], &revs508[i], 4) == 0)
-                {
-                    discoverCfg.devtype = ATECC508A;
-                    break;
-                }
-            }
-
-            for (i = 0; i < (int)sizeof(revs204) / 4; i++)
-            {
-                if (memcmp(&packet.data[1], &revs204[i], 4) == 0)
-                {
-                    discoverCfg.devtype = ATSHA204A;
-                    break;
-                }
-            }
-
-            for (i = 0; i < (int)sizeof(revs108) / 4; i++)
-            {
-                if (memcmp(&packet.data[1], &revs108[i], 4) == 0)
-                {
-                    discoverCfg.devtype = ATECC108A;
-                    break;
-                }
-            }
-
-            atca_delay_ms(15);
-            // now the device type is known, so update the caller's cfg array element with it
-            head->devtype = discoverCfg.devtype;
-            head++;
-        }
-
-        hal_i2c_idle(discoverIface);
-    }
-
-    hal_i2c_release(&hal);
-
-    return ATCA_SUCCESS;
-}
-
-/**
- * \brief
- * hal_i2c_init manages requests to initialize a physical interface. It manages use counts so when an interface
- * has released the physical layer, it will disable the interface for some other use.
- * You can have multiple ATCAIFace instances using the same bus, and you can have multiple ATCAIFace instances on
- * multiple i2c buses, so hal_i2c_init manages these things and ATCAIFace is abstracted from the physical details.
- */
-
-/**
- * \brief initialize an I2C interface using given config
- *
- * \param[in] hal - opaque ptr to HAL data
- * \param[in] cfg - interface configuration
- *
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-ATCA_STATUS hal_i2c_init(void *hal, ATCAIfaceCfg *cfg)
-{
-    // set to default i2c bus
-    if (cfg->atcai2c.bus > MAX_I2C_BUSES - 1)
-    {
-        cfg->atcai2c.bus = 0;
-    }
-    int bus = cfg->atcai2c.bus; // 0-based logical bus number
-    ATCAHAL_t *phal = (ATCAHAL_t*)hal;
-
-    if (i2c_bus_ref_ct == 0)    // power up state, no i2c buses will have been used
-    {
-        for (int i = 0; i < MAX_I2C_BUSES; i++)
-        {
-            i2c_hal_data[i] = NULL;
-        }
-    }
-
-    i2c_bus_ref_ct++;   // total across buses
-
-    if (bus >= 0 && bus < MAX_I2C_BUSES)
-    {
-        //// if this is the first time this bus and interface has been created, do the physical work of enabling it
-        if (i2c_hal_data[bus] == NULL)
-        {
-            i2c_hal_data[bus] = malloc(sizeof(ATCAI2CMaster_t));
-            i2c_hal_data[bus]->ref_ct = 1;  // buses are shared, this is the first instance
-
-            switch (bus)
-            {
-            case 0:
-                i2c_hal_data[bus]->twi_id = ID_FLEXCOM4;
-                i2c_hal_data[bus]->twi_master_instance = TWI4;
-                break;
-            case 1:
-                i2c_hal_data[bus]->twi_id = FLEXCOM6;
-                i2c_hal_data[bus]->twi_master_instance = TWI6;
-                break;
-            }
-
-            flexcom_enable((Flexcom*)i2c_hal_data[bus]->twi_id);
-            flexcom_set_opmode((Flexcom*)i2c_hal_data[bus]->twi_id, FLEXCOM_TWI);
-
-            opt_twi_master.master_clk = sysclk_get_cpu_hz();
-            opt_twi_master.speed = cfg->atcai2c.baud;
-            opt_twi_master.smbus = 0;
-
-            twi_master_init(i2c_hal_data[bus]->twi_master_instance, &opt_twi_master);
-
-            // store this for use during the release phase
-            i2c_hal_data[bus]->bus_index = bus;
-        }
-        else
-        {
-            // otherwise, another interface already initialized the bus, so this interface will share it and any different
-            // cfg parameters will be ignored...first one to initialize this sets the configuration
-            i2c_hal_data[bus]->ref_ct++;
-        }
-
-        phal->hal_data = i2c_hal_data[bus];
-
-        return ATCA_SUCCESS;
-    }
-
-    return ATCA_COMM_FAIL;
-}
-
-/**
- * \brief HAL implementation of I2C post init
- *
- * \param[in] iface  instance
- *
- * \return ATCA_SUCCESS
- */
-ATCA_STATUS hal_i2c_post_init(ATCAIface iface)
-{
-    return ATCA_SUCCESS;
-}
-
-/**
- * \brief HAL implementation of I2C send over ASF
- *
- * \param[in] iface     instance
- * \param[in] txdata    pointer to space to bytes to send
- * \param[in] txlength  number of bytes to send
- *
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-ATCA_STATUS hal_i2c_send(ATCAIface iface, uint8_t *txdata, int txlength)
-{
-#ifdef DEBUG_HAL
-    printf("hal_i2c_send()\r\n");
-
-    printf("\r\nCommand Packet (size:0x%.8x)\r\n", (uint32_t)txlength);
-    printf("Count  : %.2x\r\n", txdata[1]);
-    printf("Opcode : %.2x\r\n", txdata[2]);
-    printf("Param1 : %.2x\r\n", txdata[3]);
-    printf("Param2 : "); print_array(&txdata[4], 2);
-    if (txdata[1] > 7)
-    {
-        printf("Data   : "); print_array(&txdata[6], txdata[1] - 7);
-    }
-    printf("CRC    : "); print_array(&txdata[txdata[1] - 1], 2);
-    printf("\r\n");
-#endif
-
-    ATCAIfaceCfg *cfg = atgetifacecfg(iface);
-    // set to default i2c bus
-    if (cfg->atcai2c.bus > MAX_I2C_BUSES - 1)
-    {
-        cfg->atcai2c.bus = 0;
-    }
-    int bus = cfg->atcai2c.bus;
-
-    txdata[0] = 0x03;   // insert the Word Address Value, Command token
-    txlength++;         // account for word address value byte.
-
-    twi_packet_t packet = {
-        .chip        = cfg->atcai2c.slave_address >> 1,
-        .addr        = { 0 },
-        .addr_length = 0,
-        .buffer      = txdata,
-        .length      = (uint32_t)txlength //(uint32_t)txdata[1]
-    };
-
-    // for this implementation of I2C with CryptoAuth chips, txdata is assumed to have ATCAPacket format
-
-    // other device types that don't require i/o tokens on the front end of a command need a different hal_i2c_send and wire it up instead of this one
-    // this covers devices such as ATSHA204A and ATECCx08A that require a word address value pre-pended to the packet
-
-    if (twi_master_write(i2c_hal_data[bus]->twi_master_instance, &packet) != TWI_SUCCESS)
-    {
-        return ATCA_COMM_FAIL;
-    }
-
-    return ATCA_SUCCESS;
-}
-
-/**
- * \brief HAL implementation of I2C receive function for ASF I2C
- *
- * \param[in] iface     instance
- * \param[out] rxdata    pointer to space to receive the data
- * \param[in] rxlength  ptr to expected number of receive bytes to request
- *
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-ATCA_STATUS hal_i2c_receive(ATCAIface iface, uint8_t *rxdata, uint16_t *rxlength)
-{
-#ifdef DEBUG_HAL
-    printf("hal_i2c_receive()\r\n");
-#endif
-
-    ATCAIfaceCfg *cfg = atgetifacecfg(iface);
-    // set to default i2c bus
-    if (cfg->atcai2c.bus > MAX_I2C_BUSES - 1)
-    {
-        cfg->atcai2c.bus = 0;
-    }
-    int bus = cfg->atcai2c.bus;
-    int retries = cfg->rx_retries;
-    uint32_t status = !TWI_SUCCESS;
-
-    twi_packet_t packet = {
-        .chip        = cfg->atcai2c.slave_address >> 1,
-        .addr        = { 0 },
-        .addr_length = 0,
-        .buffer      = rxdata,
-        .length      = (uint32_t)*rxlength
-    };
-
-    while (retries-- > 0 && status != TWI_SUCCESS)
-    {
-        status = twi_master_read(i2c_hal_data[bus]->twi_master_instance, &packet);
-    }
-    if (status != TWI_SUCCESS)
-    {
-        if (retries <= 0)
-        {
-            return ATCA_TOO_MANY_COMM_RETRIES;
-        }
-
-        return ATCA_COMM_FAIL;
-    }
-
-#ifdef DEBUG_HAL
-    printf("\r\nResponse Packet (size:0x%.4x)\r\n", rxlength);
-    printf("Count  : %.2x\r\n", rxdata[0]);
-    if (rxdata[0] > 3)
-    {
-        printf("Data   : "); print_array(&rxdata[1], rxdata[0] - 3);
-        printf("CRC    : "); print_array(&rxdata[rxdata[0] - 2], 2);
-    }
-    printf("\r\n");
-#endif
-
-    return ATCA_SUCCESS;
-}
-
-/**
- * \brief method to change the bus speed of I2C
- *
- * \param[in] iface  interface on which to change bus speed
- * \param[in] speed  baud rate (typically 100000 or 400000)
- */
-void change_i2c_speed(ATCAIface iface, uint32_t speed)
-{
-    ATCAIfaceCfg *cfg = atgetifacecfg(iface);
-
-    // set to default i2c bus
-    if (cfg->atcai2c.bus > MAX_I2C_BUSES - 1)
-    {
-        cfg->atcai2c.bus = 0;
-    }
-    int bus = cfg->atcai2c.bus;
-
-    pmc_enable_periph_clk(i2c_hal_data[bus]->twi_id);
-
-    opt_twi_master.master_clk = sysclk_get_cpu_hz();
-    opt_twi_master.speed      = speed;
-    opt_twi_master.smbus      = 0;
-
-    twi_master_init(i2c_hal_data[bus]->twi_master_instance, &opt_twi_master);
-}
-
-/**
- * \brief wake up CryptoAuth device using I2C bus
- *
- * \param[in] iface  interface to logical device to wakeup
- *
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-ATCA_STATUS hal_i2c_wake(ATCAIface iface)
-{
-    ATCAIfaceCfg *cfg = atgetifacecfg(iface);
-
-    //set to default i2c bus
-    if (cfg->atcai2c.bus > MAX_I2C_BUSES - 1)
-    {
-        cfg->atcai2c.bus = 0;
-    }
-    int bus = cfg->atcai2c.bus;
-    int retries = cfg->rx_retries;
-    uint32_t bdrt = cfg->atcai2c.baud;
-    int status = !TWI_SUCCESS;
-    uint8_t data[4], expected[4] = { 0x04, 0x11, 0x33, 0x43 };
-
-    // if not already at 100kHz, change it
-    if (bdrt != 100000)
-    {
-        change_i2c_speed(iface, 100000);
-    }
-
-    // Send 0x00 as wake pulse
-    twi_write_byte(i2c_hal_data[bus]->twi_master_instance, 0x00);
-
-    // rounded up to the nearest ms
-    atca_delay_ms(((uint32_t)cfg->wake_delay + (1000 - 1)) / 1000);   // wait tWHI + tWLO which is configured based on device type and configuration structure
-
-    twi_packet_t packet = {
-        .chip        = cfg->atcai2c.slave_address >> 1,
-        .addr        = { 0 },
-        .addr_length = 0,
-        .buffer      = data,
-        .length      = 4
-    };
-
-    // if necessary, revert baud rate to what came in.
-    if (bdrt != 100000)
-    {
-        change_i2c_speed(iface, bdrt);
-    }
-
-    while (retries-- > 0 && status != TWI_SUCCESS)
-    {
-        status = twi_master_read(i2c_hal_data[bus]->twi_master_instance, &packet);
-    }
-    if (status != TWI_SUCCESS)
-    {
-        if (retries <= 0)
-        {
-            return ATCA_TOO_MANY_COMM_RETRIES;
-        }
-
-        return ATCA_COMM_FAIL;
-    }
-
-    if (memcmp(data, expected, 4) == 0)
-    {
-        return ATCA_SUCCESS;
-    }
-
-    return ATCA_COMM_FAIL;
-}
-
-/**
- * \brief idle CryptoAuth device using I2C bus
- *
- * \param[in] iface  interface to logical device to idle
- *
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-ATCA_STATUS hal_i2c_idle(ATCAIface iface)
-{
-    ATCAIfaceCfg *cfg = atgetifacecfg(iface);
-
-    // set to default i2c bus
-    if (cfg->atcai2c.bus > MAX_I2C_BUSES - 1)
-    {
-        cfg->atcai2c.bus = 0;
-    }
-    int bus = cfg->atcai2c.bus;
-    uint8_t data[4];
-
-    data[0] = 0x02; // idle word address value
-
-    twi_packet_t packet = {
-        .chip        = cfg->atcai2c.slave_address >> 1,
-        .addr        = { 0 },
-        .addr_length = 0,
-        .buffer      = data,
-        .length      = 1
-    };
-
-    if (twi_master_write(i2c_hal_data[bus]->twi_master_instance, &packet) != TWI_SUCCESS)
-    {
-        return ATCA_COMM_FAIL;
-    }
-
-    return ATCA_SUCCESS;
-}
-
-/**
- * \brief sleep CryptoAuth device using I2C bus
- *
- * \param[in] iface  interface to logical device to sleep
- *
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-ATCA_STATUS hal_i2c_sleep(ATCAIface iface)
-{
-    ATCAIfaceCfg *cfg = atgetifacecfg(iface);
-
-    //// set to default i2c bus
-    if (cfg->atcai2c.bus > MAX_I2C_BUSES - 1)
-    {
-        cfg->atcai2c.bus = 0;
-    }
-    int bus = cfg->atcai2c.bus;
-    uint8_t data[4];
-
-    data[0] = 0x01; // sleep word address value
-
-    twi_packet_t packet = {
-        .chip        = cfg->atcai2c.slave_address >> 1,
-        .addr        = { 0 },
-        .addr_length = 0,
-        .buffer      = data,
-        .length      = 1
-    };
-
-    if (twi_master_write(i2c_hal_data[bus]->twi_master_instance, &packet) != TWI_SUCCESS)
-    {
-        return ATCA_COMM_FAIL;
-    }
-
-    return ATCA_SUCCESS;
-}
-
-/**
- * \brief manages reference count on given bus and releases resource if no more refences exist
- *
- * \param[in] hal_data - opaque pointer to hal data structure - known only to the HAL implementation
- *
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-ATCA_STATUS hal_i2c_release(void *hal_data)
-{
-    ATCAI2CMaster_t *hal = (ATCAI2CMaster_t*)hal_data;
-
-    // set to default i2c bus
-    if (hal->bus_index > MAX_I2C_BUSES - 1)
-    {
-        hal->bus_index = 0;
-    }
-
-    i2c_bus_ref_ct--;  // track total i2c bus interface instances for consistency checking and debugging
-
-    // if the use count for this bus has gone to 0 references, disable it.  protect against an unbracketed release
-    if (hal && --(hal->ref_ct) <= 0 && i2c_hal_data[hal->bus_index] != NULL)
-    {
-        twi_reset(hal->twi_master_instance);
-        free(i2c_hal_data[hal->bus_index]);
-        i2c_hal_data[hal->bus_index] = NULL;
-    }
-
-    return ATCA_SUCCESS;
-}
-
-/** @} */
diff --git a/lib/hal/hal_samg55_i2c_asf.h b/lib/hal/hal_samg55_i2c_asf.h
deleted file mode 100644
index a3c545c72d43..000000000000
--- a/lib/hal/hal_samg55_i2c_asf.h
+++ /dev/null
@@ -1,67 +0,0 @@
-/**
- * \file
- * \brief ATCA Hardware abstraction layer for SAMG55 I2C over ASF drivers.
- *
- * Prerequisite: add "TWI - Two-Wire Interface (Common API) (service)" module to application in Atmel Studio
- *
- * \copyright (c) 2017 Microchip Technology Inc. and its subsidiaries.
- *            You may use this software and any derivatives exclusively with
- *            Microchip products.
- *
- * \page License
- *
- * (c) 2017 Microchip Technology Inc. and its subsidiaries. You may use this
- * software and any derivatives exclusively with Microchip products.
- *
- * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
- * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
- * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
- * PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
- * WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
- *
- * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
- * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
- * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
- * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
- * FULLEST EXTENT ALLOWED BY LAW, MICROCHIPS TOTAL LIABILITY ON ALL CLAIMS IN
- * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
- * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
- *
- * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
- * TERMS.
- */
-
-#ifndef HAL_SAMG55_I2C_ASF_H_
-#define HAL_SAMG55_I2C_ASF_H_
-
-#include <asf.h>
-
-
-/**
- * \defgroup hal_ Hardware abstraction layer (hal_)
- *
- * \brief
- * These methods define the hardware abstraction layer for communicating with a CryptoAuth device
- * using I2C driver of ASF.
- *
-   @{ */
-
-#define MAX_I2C_BUSES   2   // SAMG55 has 2 TWI
-
-/**
- * \brief this is the hal_data for ATCA HAL
- */
-typedef struct atcaI2Cmaster
-{
-    uint32_t twi_id;
-    Twi *    twi_master_instance;
-    int      ref_ct;
-    // for conveniences during interface release phase
-    int bus_index;
-} ATCAI2CMaster_t;
-
-void change_i2c_speed(ATCAIface iface, uint32_t speed);
-
-/** @} */
-
-#endif  /* HAL_SAMG55_I2C_ASF_H_ */
\ No newline at end of file
diff --git a/lib/hal/hal_samg55_timer_asf.c b/lib/hal/hal_samg55_timer_asf.c
deleted file mode 100644
index 6b5a27ce1dbf..000000000000
--- a/lib/hal/hal_samg55_timer_asf.c
+++ /dev/null
@@ -1,86 +0,0 @@
-/**
- * \file
- * \brief
- *
- * Prerequisite: add "Delay routines (service)" module to application in Atmel Studio
- *
- * \copyright (c) 2017 Microchip Technology Inc. and its subsidiaries.
- *            You may use this software and any derivatives exclusively with
- *            Microchip products.
- *
- * \page License
- *
- * (c) 2017 Microchip Technology Inc. and its subsidiaries. You may use this
- * software and any derivatives exclusively with Microchip products.
- *
- * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
- * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
- * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
- * PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
- * WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
- *
- * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
- * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
- * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
- * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
- * FULLEST EXTENT ALLOWED BY LAW, MICROCHIPS TOTAL LIABILITY ON ALL CLAIMS IN
- * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
- * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
- *
- * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
- * TERMS.
- */
-
-#include <asf.h>
-#include <delay.h>
-#include "atca_hal.h"
-
-
-/* ASF already have delay_us and delay_ms - see delay.h */
-
-/**
- * \defgroup hal_ Hardware abstraction layer (hal_)
- *
- * \brief
- * These methods define the hardware abstraction layer for communicating with a CryptoAuth device
- *
-   @{ */
-
-/**
- * \brief This function delays for a number of microseconds.
- *
- * \param[in] delay number of 0.001 milliseconds to delay
- */
-void atca_delay_us(uint32_t delay)
-{
-    // use ASF supplied delay
-    delay_us(delay);
-}
-
-/**
- * \brief This function delays for a number of tens of microseconds.
- *
- * \param[in] delay number of 0.01 milliseconds to delay
- */
-void atca_delay_10us(uint32_t delay)
-{
-    // use ASF supplied delay
-    delay_us(delay * 10);
-
-}
-
-/**
- * \brief This function delays for a number of milliseconds.
- *
- *        You can override this function if you like to do
- *        something else in your system while delaying.
- *
- * \param[in] delay number of milliseconds to delay
- */
-void atca_delay_ms(uint32_t delay)
-{
-    // use ASF supplied delay
-    delay_ms(delay);
-}
-
-/** @} */
diff --git a/lib/hal/hal_samv71_i2c_asf.c b/lib/hal/hal_samv71_i2c_asf.c
deleted file mode 100644
index 7da38807d998..000000000000
--- a/lib/hal/hal_samv71_i2c_asf.c
+++ /dev/null
@@ -1,583 +0,0 @@
-/**
- * \file
- * \brief ATCA Hardware abstraction layer for SAMV71 I2C over ASF drivers.
- *
- * This code is structured in two parts.  Part 1 is the connection of the ATCA HAL API to the physical I2C
- * implementation. Part 2 is the ASF I2C primitives to set up the interface.
- *
- * Prerequisite: add SERCOM I2C Master Polled support to application in Atmel Studio
- *
- * \copyright (c) 2017 Microchip Technology Inc. and its subsidiaries.
- *            You may use this software and any derivatives exclusively with
- *            Microchip products.
- *
- * \page License
- *
- * (c) 2017 Microchip Technology Inc. and its subsidiaries. You may use this
- * software and any derivatives exclusively with Microchip products.
- *
- * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
- * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
- * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
- * PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
- * WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
- *
- * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
- * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
- * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
- * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
- * FULLEST EXTENT ALLOWED BY LAW, MICROCHIPS TOTAL LIABILITY ON ALL CLAIMS IN
- * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
- * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
- *
- * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
- * TERMS.
- */
-
-#include <asf.h>
-#include <string.h>
-#include <stdio.h>
-
-#include "atca_hal.h"
-#include "hal_samv71_i2c_asf.h"
-#include "atca_device.h"
-
-/** \defgroup hal_ Hardware abstraction layer (hal_)
- *
- * \brief
- * These methods define the hardware abstraction layer for communicating with a CryptoAuth device
- * using I2C driver of ASF.
- *
-   @{ */
-
-/** \brief logical to physical bus mapping structure */
-ATCAI2CMaster_t *i2c_hal_data[MAX_I2C_BUSES];   // map logical, 0-based bus number to index
-int i2c_bus_ref_ct = 0;                         // total in-use count across buses
-
-/** \brief discover i2c buses available for this hardware
- * this maintains a list of logical to physical bus mappings freeing the application
- * of the a-priori knowledge
- * \param[in] i2c_buses - an array of logical bus numbers
- * \param[in] max_buses - maximum number of buses the app wants to attempt to discover
- * \return ATCA_SUCCESS
- */
-
-ATCA_STATUS hal_i2c_discover_buses(int i2c_buses[], int max_buses)
-{
-    /* logical bus numbers 0-2 map to the V71 i2c buses:
-       ID_TWIHS0
-       ID_TWIHS1
-       ID_TWIHS2
-
-       until ASF driver supports timeouts, only the TWIHS0 bus will respond on the SAMV71 Xplained Pro board
-       otherwise, driver hangs on waiting for txready.
-       for( i = 0; i < MAX_I2C_BUSES && i < max_buses; i++ )
-        i2c_buses[i] = i;
-     */
-    i2c_buses[0] = 0;
-#if MAX_I2C_BUSES == 3
-    i2c_buses[1] = -1;
-    i2c_buses[2] = -1;
-#endif
-    return ATCA_SUCCESS;
-}
-
-/** \brief discover any CryptoAuth devices on a given logical bus number
- * \param[in]  bus_num  Logical bus number on which to look for CryptoAuth devices
- * \param[out] cfg      Pointer to head of an array of interface config structures which get filled in by this method
- * \param[out] found    Number of devices found on this bus
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-ATCA_STATUS hal_i2c_discover_devices(int bus_num, ATCAIfaceCfg cfg[], int *found)
-{
-    ATCAIfaceCfg *head = cfg;
-    uint8_t slave_address = 0x01;
-    ATCADevice device;
-    ATCAIface discover_iface;
-    ATCACommand command;
-    ATCAPacket packet;
-    ATCA_STATUS status;
-    uint8_t revs608[1][4] = { { 0x00, 0x00, 0x60, 0x01 } };
-    uint8_t revs508[1][4] = { { 0x00, 0x00, 0x50, 0x00 } };
-    uint8_t revs108[1][4] = { { 0x80, 0x00, 0x10, 0x01 } };
-    uint8_t revs204[3][4] = { { 0x00, 0x02, 0x00, 0x08 },
-                              { 0x00, 0x02, 0x00, 0x09 },
-                              { 0x00, 0x04, 0x05, 0x00 } };
-    int i;
-
-    /** \brief default configuration, to be reused during discovery process */
-    ATCAIfaceCfg discoverCfg = {
-        .iface_type             = ATCA_I2C_IFACE,
-        .devtype                = ATECC508A,
-        .atcai2c.slave_address  = 0x07,
-        .atcai2c.bus            = bus_num,
-        .atcai2c.baud           = 400000,
-        .wake_delay             = 800,
-        .rx_retries             = 3
-    };
-
-    ATCAHAL_t hal;
-
-    if (bus_num < 0)
-    {
-        return ATCA_COMM_FAIL;
-    }
-
-    hal_i2c_init(&hal, &discoverCfg);
-    device = newATCADevice(&discoverCfg);
-    discover_iface = atGetIFace(device);
-    command = atGetCommands(device);
-
-    // iterate through all addresses on given i2c bus
-    // all valid 7-bit addresses go from 0x07 to 0x78
-    for (slave_address = 0x07; slave_address <= 0x78; slave_address++)
-    {
-        discoverCfg.atcai2c.slave_address = slave_address << 1;  // turn it into an 8-bit address which is what the rest of the i2c HAL is expecting when a packet is sent
-
-        // wake up device
-        // If it wakes, send it a dev rev command.  Based on that response, determine the device type
-        // BTW - this will wake every cryptoauth device living on the same bus (ecc508a, sha204a)
-
-        if (hal_i2c_wake(discover_iface) == ATCA_SUCCESS)
-        {
-            (*found)++;
-            memcpy( (uint8_t*)head, (uint8_t*)&discoverCfg, sizeof(ATCAIfaceCfg));
-
-            memset(&packet, 0x00, sizeof(packet));
-
-            // get devrev info and set device type accordingly
-            atInfo(command, &packet);
-            if ((status = atGetExecTime(packet.opcode, command)) != ATCA_SUCCESS)
-            {
-                continue;
-            }
-
-            // send the command
-            if ( (status = atsend(discover_iface, (uint8_t*)&packet, packet.txsize)) != ATCA_SUCCESS)
-            {
-                printf("packet send error\r\n");
-                continue;
-            }
-
-            // delay the appropriate amount of time for command to execute
-            atca_delay_ms((command->execution_time_msec) + 1);
-
-            // receive the response
-            if ( (status = atreceive(discover_iface, &(packet.data[0]), &(packet.rxsize) )) != ATCA_SUCCESS)
-            {
-                continue;
-            }
-
-            if ( (status = isATCAError(packet.data)) != ATCA_SUCCESS)
-            {
-                continue;
-            }
-
-            // determine device type from common info and dev rev response byte strings
-            for (i = 0; i < (int)sizeof(revs608) / 4; i++)
-            {
-                if (memcmp(&packet.data[1], &revs608[i], 4) == 0)
-                {
-                    discoverCfg.devtype = ATECC608A;
-                    break;
-                }
-            }
-
-            for (i = 0; i < (int)sizeof(revs508) / 4; i++)
-            {
-                if (memcmp(&packet.data[1], &revs508[i], 4) == 0)
-                {
-                    discoverCfg.devtype = ATECC508A;
-                    break;
-                }
-            }
-
-            for (i = 0; i < (int)sizeof(revs204) / 4; i++)
-            {
-                if (memcmp(&packet.data[1], &revs204[i], 4) == 0)
-                {
-                    discoverCfg.devtype = ATSHA204A;
-                    break;
-                }
-            }
-
-            for (i = 0; i < (int)sizeof(revs108) / 4; i++)
-            {
-                if (memcmp(&packet.data[1], &revs108[i], 4) == 0)
-                {
-                    discoverCfg.devtype = ATECC108A;
-                    break;
-                }
-            }
-
-            atca_delay_ms(15);
-            // now the device type is known, so update the caller's cfg array element with it
-            head->devtype = discoverCfg.devtype;
-            head++;
-        }
-
-        hal_i2c_idle(discover_iface);
-    }
-
-    // hal_i2c_release(&hal);
-
-    return ATCA_SUCCESS;
-}
-
-/** \brief
-    - this HAL implementation assumes you've included the ASF Twi libraries in your project, otherwise,
-    the HAL layer will not compile because the ASF TWI drivers are a dependency *
- */
-
-/** \brief hal_i2c_init manages requests to initialize a physical interface.  it manages use counts so when an interface
- * has released the physical layer, it will disable the interface for some other use.
- * You can have multiple ATCAIFace instances using the same bus, and you can have multiple ATCAIFace instances on
- * multiple i2c buses, so hal_i2c_init manages these things and ATCAIFace is abstracted from the physical details.
- */
-
-/** \brief initialize an I2C interface using given config
- * \param[in] hal - opaque ptr to HAL data
- * \param[in] cfg - interface configuration
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-ATCA_STATUS hal_i2c_init(void *hal, ATCAIfaceCfg *cfg)
-{
-    int bus = cfg->atcai2c.bus;   // 0-based logical bus number
-    ATCAHAL_t *phal = (ATCAHAL_t*)hal;
-    twihs_options_t twi_options;
-
-    if (i2c_bus_ref_ct == 0)       // power up state, no i2c buses will have been used
-    {
-        for (int i = 0; i < MAX_I2C_BUSES; i++)
-        {
-            i2c_hal_data[i] = NULL;
-        }
-    }
-
-    i2c_bus_ref_ct++;  // total across buses
-
-    if (bus >= 0 && bus < MAX_I2C_BUSES)
-    {
-        // if this is the first time this bus and interface has been created, do the physical work of enabling it
-        if (i2c_hal_data[bus] == NULL)
-        {
-            i2c_hal_data[bus] = malloc(sizeof(ATCAI2CMaster_t) );
-            i2c_hal_data[bus]->ref_ct = 1;  // buses are shared, this is the first instance
-
-            /* Configure the options of TWI driver */
-            twi_options.master_clk = sysclk_get_cpu_hz() / CONFIG_SYSCLK_DIV;
-            twi_options.speed = cfg->atcai2c.baud;
-
-            switch (bus)
-            {
-            case 0: /* Enable the peripheral clock for TWI */
-                pmc_enable_periph_clk(ID_TWIHS0);
-                if (twihs_master_init(TWIHS0, &twi_options) != TWIHS_SUCCESS)
-                {
-                    return ATCA_COMM_FAIL;
-                }
-                i2c_hal_data[bus]->twi_module = (uint32_t)TWIHS0;
-                break;
-
-            case 1: /* Enable the peripheral clock for TWI */
-                pmc_enable_periph_clk(ID_TWIHS1);
-                if (twihs_master_init(TWIHS1, &twi_options) != TWIHS_SUCCESS)
-                {
-                    return ATCA_COMM_FAIL;
-                }
-                i2c_hal_data[bus]->twi_module = (uint32_t)TWIHS1;
-                break;
-
-            case 2: /* Enable the peripheral clock for TWI */
-                pmc_enable_periph_clk(ID_TWIHS2);
-                if (twihs_master_init(TWIHS2, &twi_options) != TWIHS_SUCCESS)
-                {
-                    return ATCA_COMM_FAIL;
-                }
-                i2c_hal_data[bus]->twi_module = (uint32_t)TWIHS2;
-                break;
-            }
-
-            // store this for use during the release phase
-            i2c_hal_data[bus]->bus_index = bus;
-        }
-        else
-        {
-            // otherwise, another interface already initialized the bus, so this interface will share it and any different
-            // cfg parameters will be ignored...first one to initialize this sets the configuration
-            i2c_hal_data[bus]->ref_ct++;
-        }
-
-        phal->hal_data = i2c_hal_data[bus];
-
-        return ATCA_SUCCESS;
-    }
-
-    return ATCA_COMM_FAIL;
-}
-
-/** \brief HAL implementation of I2C post init
- * \param[in] iface  instance
- * \return ATCA_SUCCESS
- */
-ATCA_STATUS hal_i2c_post_init(ATCAIface iface)
-{
-    return ATCA_SUCCESS;
-}
-
-
-/** \brief HAL implementation of I2C send over ASF
- * \param[in] iface     instance
- * \param[in] txdata    pointer to space to bytes to send
- * \param[in] txlength  number of bytes to send
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-
-ATCA_STATUS hal_i2c_send(ATCAIface iface, uint8_t *txdata, int txlength)
-{
-    ATCAIfaceCfg *cfg = atgetifacecfg(iface);
-    int bus = cfg->atcai2c.bus;
-    Twihs *twihs_device = (Twihs*)(i2c_hal_data[bus]->twi_module);
-
-    twihs_packet_t packet = {
-        .addr[0]        = 0,
-        .addr[1]        = 0,
-        .addr_length    = 0,                              //very important, since cryptoauthdevices do not require addressing;
-        .chip           = cfg->atcai2c.slave_address >> 1,
-        .buffer         = txdata,
-    };
-
-    // for this implementation of I2C with CryptoAuth chips, txdata is assumed to have ATCAPacket format
-
-    // other device types that don't require i/o tokens on the front end of a command need a different hal_i2c_send and wire it up instead of this one
-    // this covers devices such as ATSHA204A and ATECCx08A that require a word address value pre-pended to the packet
-    // txdata[0] is using _reserved byte of the ATCAPacket
-    txdata[0] = 0x03;   // insert the Word Address Value, Command token
-    txlength++;         // account for word address value byte.
-    packet.length = txlength;
-
-    if (twihs_master_write(twihs_device, &packet) != STATUS_OK)
-    {
-        return ATCA_COMM_FAIL;
-    }
-
-    return ATCA_SUCCESS;
-}
-
-/** \brief HAL implementation of I2C receive function for ASF I2C
- * \param[in] iface     instance
- * \param[out] rxdata    pointer to space to receive the data
- * \param[in] rxlength  ptr to expected number of receive bytes to request
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-
-ATCA_STATUS hal_i2c_receive(ATCAIface iface, uint8_t *rxdata, uint16_t *rxlength)
-{
-    ATCAIfaceCfg *cfg = atgetifacecfg(iface);
-    int bus = cfg->atcai2c.bus;
-    int retries = cfg->rx_retries;
-    int status = !STATUS_OK;
-    Twihs *twihs_device = (Twihs*)(i2c_hal_data[bus]->twi_module);
-
-    twihs_packet_t packet = {
-        .chip   = cfg->atcai2c.slave_address >> 1, // use 7-bit address
-        .buffer = rxdata,
-        .length = *rxlength
-    };
-
-    while (retries-- > 0 && status != STATUS_OK)
-    {
-        if (twihs_master_read(twihs_device, &packet) != TWIHS_SUCCESS)
-        {
-            status = ATCA_COMM_FAIL;
-        }
-        else
-        {
-            status = ATCA_SUCCESS;
-        }
-    }
-
-    if (status != STATUS_OK)
-    {
-        return ATCA_COMM_FAIL;
-    }
-
-    return ATCA_SUCCESS;
-}
-
-/** \brief method to change the bus speed of I2C
- * \param[in] iface  interface on which to change bus speed
- * \param[in] speed  baud rate (typically 100000 or 400000)
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-
-ATCA_STATUS change_i2c_speed(ATCAIface iface, uint32_t speed)
-{
-    ATCAIfaceCfg *cfg = atgetifacecfg(iface);
-    int bus = cfg->atcai2c.bus;
-    Twihs *twihs_device = (Twihs*)(i2c_hal_data[bus]->twi_module);
-
-    // if necessary, revert baud rate to what came in.
-    if (twihs_set_speed(twihs_device, speed, sysclk_get_cpu_hz() / CONFIG_SYSCLK_DIV) == FAIL)
-    {
-        return ATCA_COMM_FAIL;
-    }
-
-    return ATCA_SUCCESS;
-}
-
-/** \brief wake up CryptoAuth device using I2C bus
- * \param[in] iface  interface to logical device to wakeup
- * \return ATCA_SUCCESS on success, otherwise an error code.
-
- */
-
-ATCA_STATUS hal_i2c_wake(ATCAIface iface)
-{
-    ATCAIfaceCfg *cfg = atgetifacecfg(iface);
-    int bus = cfg->atcai2c.bus;
-    uint16_t rxlength;
-    uint32_t bdrt = cfg->atcai2c.baud;
-    int status = !STATUS_OK;
-    uint8_t data[4], expected[4] = { 0x04, 0x11, 0x33, 0x43 };
-    Twihs *twihs_device = (Twihs*)(i2c_hal_data[bus]->twi_module);
-
-    if (bdrt != 100000)    // if not already at 100KHz, change it
-
-    {
-        if (twihs_set_speed(twihs_device, 100000, sysclk_get_cpu_hz() / CONFIG_SYSCLK_DIV) == FAIL)
-        {
-            return ATCA_COMM_FAIL;
-        }
-    }
-
-    twihs_packet_t packet = {
-        .addr[0]        = 0,
-        .addr[1]        = 0,
-        .addr_length    = 0,                              //very important, since cryptoauthdevices do not require addressing;
-        .chip           = cfg->atcai2c.slave_address >> 1,
-        .buffer         =  &data[0],
-        .length         = 1
-    };
-
-    twihs_master_write(twihs_device, &packet);
-
-    atca_delay_us(cfg->wake_delay);   // wait tWHI + tWLO which is configured based on device type and configuration structure
-
-    // look for wake response
-    rxlength = 4;
-    memset(data, 0x00, rxlength);
-    status = hal_i2c_receive(iface, data, &rxlength);
-
-    // if necessary, revert baud rate to what came in.
-    if (bdrt != 100000)
-    {
-        if (twihs_set_speed(twihs_device, bdrt, sysclk_get_cpu_hz() / CONFIG_SYSCLK_DIV) == FAIL)
-        {
-            return ATCA_COMM_FAIL;
-        }
-    }
-
-    if (status != STATUS_OK)
-    {
-        return ATCA_COMM_FAIL;
-    }
-
-    if (memcmp(data, expected, 4) == 0)
-    {
-        return ATCA_SUCCESS;
-    }
-
-    return ATCA_COMM_FAIL;
-}
-
-
-/** \brief idle CryptoAuth device using I2C bus
- * \param[in] iface  interface to logical device to idle
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-
-ATCA_STATUS hal_i2c_idle(ATCAIface iface)
-{
-    ATCAIfaceCfg *cfg = atgetifacecfg(iface);
-    int bus = cfg->atcai2c.bus;
-    uint8_t data[4];
-    Twihs *twihs_device = (Twihs*)(i2c_hal_data[bus]->twi_module);
-
-    data[0] = 0x02;  // idle word address value
-
-    twihs_packet_t packet = {
-        .addr[0]        = 0,
-        .addr[1]        = 0,
-        .addr_length    = 0,                              //very important, since cryptoauthdevices do not require addressing;
-        .chip           = cfg->atcai2c.slave_address >> 1,
-        .buffer         = data,
-    };
-
-    packet.length = 1;
-
-    if (twihs_master_write(twihs_device, &packet) != STATUS_OK)
-    {
-        return ATCA_COMM_FAIL;
-    }
-
-    return ATCA_SUCCESS;
-}
-
-/** \brief sleep CryptoAuth device using I2C bus
- * \param[in] iface  interface to logical device to sleep
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-
-ATCA_STATUS hal_i2c_sleep(ATCAIface iface)
-{
-    ATCAIfaceCfg *cfg = atgetifacecfg(iface);
-    int bus = cfg->atcai2c.bus;
-    uint8_t data[4];
-    Twihs *twihs_device = (Twihs*)(i2c_hal_data[bus]->twi_module);
-
-    data[0] = 0x01;  // sleep word address value
-
-    twihs_packet_t packet = {
-        .addr[0]        = 0,
-        .addr[1]        = 0,
-        .addr_length    = 0,                              //very important, since cryptoauthdevices do not require addressing;
-        .chip           = cfg->atcai2c.slave_address >> 1,
-        .buffer         = data,
-    };
-
-    packet.length = 1;
-
-    if (twihs_master_write(twihs_device, &packet) != STATUS_OK)
-    {
-        return ATCA_COMM_FAIL;
-    }
-
-    return ATCA_SUCCESS;
-}
-
-/** \brief manages reference count on given bus and releases resource if no more refences exist
- * \param[in] hal_data - opaque pointer to hal data structure - known only to the HAL implementation
- * \return ATCA_SUCCESS
- */
-
-ATCA_STATUS hal_i2c_release(void *hal_data)
-{
-    ATCAI2CMaster_t *hal = (ATCAI2CMaster_t*)hal_data;
-    int bus = hal->bus_index;
-    Twihs *twihs_device = (Twihs*)(i2c_hal_data[bus]->twi_module);
-
-    i2c_bus_ref_ct--;  // track total i2c bus interface instances for consistency checking and debugging
-
-    // if the use count for this bus has gone to 0 references, disable it.  protect against an unbracketed release
-    if (hal && --(hal->ref_ct) <= 0 && i2c_hal_data[bus] != NULL)
-    {
-        twihs_disable_master_mode(twihs_device);
-        free(i2c_hal_data[hal->bus_index]);
-        i2c_hal_data[hal->bus_index] = NULL;
-    }
-
-    return ATCA_SUCCESS;
-}
-
-/** @} */
diff --git a/lib/hal/hal_samv71_i2c_asf.h b/lib/hal/hal_samv71_i2c_asf.h
deleted file mode 100644
index 7efcb52b8b17..000000000000
--- a/lib/hal/hal_samv71_i2c_asf.h
+++ /dev/null
@@ -1,63 +0,0 @@
-/**
- * \file
- * \brief ATCA Hardware abstraction layer for SAMV71 I2C over ASF drivers.
- *
- * Prerequisite: add SERCOM I2C Master Polled support to application in Atmel Studio
- *
- * \copyright (c) 2017 Microchip Technology Inc. and its subsidiaries.
- *            You may use this software and any derivatives exclusively with
- *            Microchip products.
- *
- * \page License
- *
- * (c) 2017 Microchip Technology Inc. and its subsidiaries. You may use this
- * software and any derivatives exclusively with Microchip products.
- *
- * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
- * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
- * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
- * PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
- * WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
- *
- * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
- * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
- * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
- * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
- * FULLEST EXTENT ALLOWED BY LAW, MICROCHIPS TOTAL LIABILITY ON ALL CLAIMS IN
- * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
- * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
- *
- * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
- * TERMS.
- */
-
-#ifndef HAL_SAMV71_I2C_ASF_H_
-#define HAL_SAMV71_I2C_ASF_H_
-
-#include <asf.h>
-
-/** \defgroup hal_ Hardware abstraction layer (hal_)
- *
- * \brief
- * These methods define the hardware abstraction layer for communicating with a CryptoAuth device
- * using I2C driver of ASF.
- *
-   @{ */
-
-
-#define MAX_I2C_BUSES    3
-
-/** \brief this is the hal_data for ATCA HAL for ASF SERCOM
- */
-typedef struct atcaI2Cmaster
-{
-    int ref_ct;
-    // for conveniences during interface release phase
-    int      bus_index;
-    uint32_t twi_module;
-} ATCAI2CMaster_t;
-
-ATCA_STATUS change_i2c_speed(ATCAIface iface, uint32_t speed);
-
-/** @} */
-#endif /* HAL_SAMD21_I2C_ASF_H_ */
\ No newline at end of file
diff --git a/lib/hal/hal_samv71_timer_asf.c b/lib/hal/hal_samv71_timer_asf.c
deleted file mode 100644
index 1090a2d26f70..000000000000
--- a/lib/hal/hal_samv71_timer_asf.c
+++ /dev/null
@@ -1,79 +0,0 @@
-/**
- * \file
- * \brief ATCA Hardware abstraction layer for SAMD21 timer/delay over ASF drivers.
- *
- * \copyright (c) 2017 Microchip Technology Inc. and its subsidiaries.
- *            You may use this software and any derivatives exclusively with
- *            Microchip products.
- *
- * \page License
- *
- * (c) 2017 Microchip Technology Inc. and its subsidiaries. You may use this
- * software and any derivatives exclusively with Microchip products.
- *
- * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
- * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
- * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
- * PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
- * WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
- *
- * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
- * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
- * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
- * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
- * FULLEST EXTENT ALLOWED BY LAW, MICROCHIPS TOTAL LIABILITY ON ALL CLAIMS IN
- * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
- * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
- *
- * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
- * TERMS.
- */
-
-#include <asf.h>
-#include <delay.h>
-#include "atca_hal.h"
-
-/** \defgroup hal_ Hardware abstraction layer (hal_)
- *
- * \brief
- * These methods define the hardware abstraction layer for communicating with a CryptoAuth device
- *
-   @{ */
-
-
-/** \brief This function delays for a number of  microseconds.
- *
- * \param[in] delay number of 0.001 milliseconds to delay
- */
-void atca_delay_us(uint32_t delay)
-{
-    // use ASF supplied delay
-    delay_us(delay);
-}
-
-/** \brief This function delays for a number of tens of microseconds.
- *
- * \param[in] delay number of 0.01 milliseconds to delay
- */
-void atca_delay_10us(uint32_t delay)
-{
-    // use ASF supplied delay
-    delay_us(delay * 10);
-
-}
-
-/** \brief This function delays for a number of milliseconds.
- *
- *         You can override this function if you like to do
- *         something else in your system while delaying.
- * \param[in] delay number of milliseconds to delay
- */
-
-/* ASF already has delay_ms - see delay.h */
-void atca_delay_ms(uint32_t delay)
-{
-    // use ASF supplied delay
-    delay_ms(delay);
-}
-
-/** @} */
diff --git a/lib/hal/hal_swi_bitbang.c b/lib/hal/hal_swi_bitbang.c
deleted file mode 100644
index 412b393d9bd0..000000000000
--- a/lib/hal/hal_swi_bitbang.c
+++ /dev/null
@@ -1,347 +0,0 @@
-/**
- * \file
- * \brief ATCA Hardware abstraction layer for SWI bit banging.
- *
- * \copyright (c) 2017 Microchip Technology Inc. and its subsidiaries.
- *            You may use this software and any derivatives exclusively with
- *            Microchip products.
- *
- * \page License
- *
- * (c) 2017 Microchip Technology Inc. and its subsidiaries. You may use this
- * software and any derivatives exclusively with Microchip products.
- *
- * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
- * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
- * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
- * PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
- * WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
- *
- * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
- * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
- * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
- * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
- * FULLEST EXTENT ALLOWED BY LAW, MICROCHIPS TOTAL LIABILITY ON ALL CLAIMS IN
- * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
- * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
- *
- * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
- * TERMS.
- */
-
-#include <asf.h>
-#include <string.h>
-#include <stdio.h>
-#include "atca_hal.h"
-#include "hal_swi_bitbang.h"
-#include "atca_device.h"
-
-
-/**
- * \defgroup hal_ Hardware abstraction layer (hal_)
- *
- * \brief These methods define the hardware abstraction layer for
- *        communicating with a CryptoAuth device using SWI bit banging.
-   @{ */
-
-/**
- * \brief Logical to physical bus mapping structure.
- */
-ATCASWIMaster_t *swi_hal_data[MAX_SWI_BUSES];   //!< map logical, 0-based bus number to index
-int swi_bus_ref_ct = 0;                         //!< total in-use count across buses
-
-/** \brief discover swi buses available for this hardware
- * this maintains a list of logical to physical bus mappings freeing the application.This function is currently not supported.
- * of the a-priori knowledge
- * \param[in] swi_buses - an array of logical bus numbers
- * \param[in] max_buses - maximum number of buses the app wants to attempt to discover
- * \return ATCA_UNIMPLEMENTED
- */
-ATCA_STATUS hal_swi_discover_buses(int swi_buses[], int max_buses)
-{
-
-    return ATCA_UNIMPLEMENTED;
-
-}
-
-/** \brief discover any CryptoAuth devices on a given logical bus number.This function is curently not supported.
- * \param[in] busNum - logical bus number on which to look for CryptoAuth devices
- * \param[out] cfg[] - pointer to head of an array of interface config structures which get filled in by this method
- * \param[out] *found - number of devices found on this bus
- * \return ATCA_UNIMPLEMENTED
- */
-
-ATCA_STATUS hal_swi_discover_devices(int busNum, ATCAIfaceCfg cfg[], int *found)
-{
-    return ATCA_UNIMPLEMENTED;
-
-}
-
-
-
-/**
- * \brief hal_swi_init manages requests to initialize a physical
- *        interface. It manages use counts so when an interface has
- *        released the physical layer, it will disable the interface for
- *        some other use. You can have multiple ATCAIFace instances using
- *        the same bus, and you can have multiple ATCAIFace instances on
- *        multiple swi buses, so hal_swi_init manages these things and
- *        ATCAIFace is abstracted from the physical details.
- */
-
-/**
- * \brief Initialize an SWI interface using given config.
- *
- * \param[in] hal  opaque pointer to HAL data
- * \param[in] cfg  interface configuration
- *
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-ATCA_STATUS hal_swi_init(void *hal, ATCAIfaceCfg *cfg)
-{
-    ATCAHAL_t *phal = (ATCAHAL_t*)hal;
-
-    int bus = cfg->atcaswi.bus; //!< 0-based logical bus number
-
-    if (swi_bus_ref_ct == 0)    //!< power up state, no swi buses will have been used
-
-    {
-        for (int i = 0; i < MAX_SWI_BUSES; i++)
-        {
-            swi_hal_data[i] = NULL;
-        }
-    }
-    swi_bus_ref_ct++; //!< total across buses
-
-    if (bus >= 0 && bus < MAX_SWI_BUSES)
-    {
-        //! if this is the first time this bus and interface has been created, do the physical work of enabling it
-        if (swi_hal_data[bus] == NULL)
-        {
-            swi_hal_data[bus] = malloc(sizeof(ATCASWIMaster_t));
-
-            //! assign GPIO pin
-            swi_hal_data[bus]->pin_sda = swi_buses_default.pin_sda[bus];
-
-            swi_set_pin(swi_hal_data[bus]->pin_sda);
-            swi_enable();
-
-            //! store this for use during the release phase
-            swi_hal_data[bus]->bus_index = bus;
-        }
-        else
-        {
-            //! otherwise, another interface already initialized the bus, any different
-            //! cfg parameters will be ignored...first one to initialize this sets the configuration
-        }
-
-        phal->hal_data = swi_hal_data[bus];
-
-        return ATCA_SUCCESS;
-    }
-
-    return ATCA_COMM_FAIL;
-}
-
-/**
- * \brief HAL implementation of SWI post init.
- *
- * \param[in] iface  ATCAIface instance
- *
- * \return ATCA_SUCCESS
- */
-ATCA_STATUS hal_swi_post_init(ATCAIface iface)
-{
-    return ATCA_SUCCESS;
-}
-
-/**
- * \brief Send byte(s) via SWI.
- *
- * \param[in] iface     interface of the logical device to send data to
- * \param[in] txdata    pointer to bytes to send
- * \param[in] txlength  number of bytes to send
- * \return ATCA_SUCCESS
- */
-ATCA_STATUS hal_swi_send(ATCAIface iface, uint8_t *txdata, int txlength)
-{
-    ATCAIfaceCfg *cfg = atgetifacecfg(iface);
-
-    int bus     = cfg->atcaswi.bus;
-
-    //! Skip the Word Address data as SWI doesn't use it
-    txdata++;
-
-    //! Set SWI pin
-    swi_set_pin(swi_hal_data[bus]->pin_sda);
-
-    //! Send Command Flag
-    swi_send_byte(SWI_FLAG_CMD);
-
-    //! Send the remaining bytes
-    swi_send_bytes(txlength, txdata);
-
-    return ATCA_SUCCESS;
-}
-
-/**
- * \brief Receive byte(s) via SWI.
- *
- * \param[in]  iface     interface of the logical device to receive data
- *                      from
- * \param[out] rxdata    pointer to where bytes will be received
- * \param[in]  rxlength  pointer to expected number of receive bytes to
- *                      request
- *
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-ATCA_STATUS hal_swi_receive(ATCAIface iface, uint8_t *rxdata, uint16_t *rxlength)
-{
-    ATCAIfaceCfg *cfg = atgetifacecfg(iface);
-
-    ATCA_STATUS status = ATCA_RX_TIMEOUT;
-
-    int bus     = cfg->atcaswi.bus;
-    int retries = cfg->rx_retries;
-    uint16_t count;
-
-    //! Set SWI pin
-    swi_set_pin(swi_hal_data[bus]->pin_sda);
-
-    while (retries-- > 0 && status != ATCA_SUCCESS)
-    {
-        swi_send_byte(SWI_FLAG_TX);
-
-        status = swi_receive_bytes(*rxlength, rxdata);
-        if (status == ATCA_RX_FAIL)
-        {
-            count = rxdata[0];
-            if ((count < ATCA_RSP_SIZE_MIN) || (count > *rxlength))
-            {
-                status = ATCA_INVALID_SIZE;
-                break;
-            }
-            else
-            {
-                status = ATCA_SUCCESS;
-            }
-        }
-        else if (status == ATCA_RX_TIMEOUT)
-        {
-            status = ATCA_RX_NO_RESPONSE;
-        }
-    }
-
-    return status;
-}
-
-/**
- * \brief Send Wake flag via SWI.
- *
- * \param[in] iface  interface of the logical device to wake up
- *
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-ATCA_STATUS hal_swi_wake(ATCAIface iface)
-{
-    ATCAIfaceCfg *cfg = atgetifacecfg(iface);
-
-    ATCA_STATUS status = ATCA_WAKE_FAILED;
-
-    int bus     = cfg->atcaswi.bus;
-    uint8_t response[4] = { 0x00, 0x00, 0x00, 0x00 };
-    uint8_t expected_response[4] = { 0x04, 0x11, 0x33, 0x43 };
-    uint16_t rxlength  = sizeof(response);
-
-    //! Set SWI pin
-    swi_set_pin(swi_hal_data[bus]->pin_sda);
-
-    //! Generate Wake Token
-    swi_send_wake_token();
-
-    //! Wait tWHI + tWLO
-    atca_delay_us(cfg->wake_delay);
-
-    status = hal_swi_receive(iface, response, &rxlength);
-    if (status == ATCA_SUCCESS)
-    {
-        //! Compare response with expected_response
-        if (memcmp(response, expected_response, 4) != 0)
-        {
-            status = ATCA_WAKE_FAILED;
-        }
-    }
-
-    return status;
-}
-
-/**
- * \brief Send Idle flag via SWI.
- *
- * \param[in] iface  interface of the logical device to idle
- *
- * \return ATCA_SUCCES
- */
-ATCA_STATUS hal_swi_idle(ATCAIface iface)
-{
-    ATCAIfaceCfg *cfg = atgetifacecfg(iface);
-
-    int bus     = cfg->atcaswi.bus;
-
-    //! Set SWI pin
-    swi_set_pin(swi_hal_data[bus]->pin_sda);
-
-    swi_send_byte(SWI_FLAG_IDLE);
-
-    return ATCA_SUCCESS;
-}
-
-/**
- * \brief Send Sleep flag via SWI.
- *
- * \param[in] iface  interface of the logical device to sleep
- *
- * \return ATCA_SUCCESS
- */
-ATCA_STATUS hal_swi_sleep(ATCAIface iface)
-{
-    ATCAIfaceCfg *cfg = atgetifacecfg(iface);
-
-    int bus     = cfg->atcaswi.bus;
-
-    //! Set SWI pin
-    swi_set_pin(swi_hal_data[bus]->pin_sda);
-
-    swi_send_byte(SWI_FLAG_SLEEP);
-
-    return ATCA_SUCCESS;
-}
-
-/**
- * \brief Manages reference count on given bus and releases resource if
- *        no more reference(s) exist.
- *
- * \param[in] hal_data  opaque pointer to hal data structure - known only
- *                      to the HAL implementation
- *
- * \return ATCA_SUCCESS
- */
-ATCA_STATUS hal_swi_release(void *hal_data)
-{
-    ATCASWIMaster_t *hal = (ATCASWIMaster_t*)hal_data;
-
-    swi_bus_ref_ct--; //!< track total SWI instances
-
-    //! if the use count for this bus has gone to 0 references, disable it.  protect against an unbracketed release
-    if (hal && swi_hal_data[hal->bus_index] != NULL)
-    {
-        swi_set_pin(swi_hal_data[hal->bus_index]->pin_sda);
-        swi_disable();
-        free(swi_hal_data[hal->bus_index]);
-        swi_hal_data[hal->bus_index] = NULL;
-    }
-
-    return ATCA_SUCCESS;
-}
-
-/** @} */
\ No newline at end of file
diff --git a/lib/hal/hal_swi_bitbang.h b/lib/hal/hal_swi_bitbang.h
deleted file mode 100644
index b981a6fc99ff..000000000000
--- a/lib/hal/hal_swi_bitbang.h
+++ /dev/null
@@ -1,76 +0,0 @@
-/**
- * \file
- * \brief ATCA Hardware abstraction layer for SWI bit banging.
- *
- * \copyright (c) 2017 Microchip Technology Inc. and its subsidiaries.
- *            You may use this software and any derivatives exclusively with
- *            Microchip products.
- *
- * \page License
- *
- * (c) 2017 Microchip Technology Inc. and its subsidiaries. You may use this
- * software and any derivatives exclusively with Microchip products.
- *
- * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
- * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
- * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
- * PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
- * WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
- *
- * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
- * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
- * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
- * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
- * FULLEST EXTENT ALLOWED BY LAW, MICROCHIPS TOTAL LIABILITY ON ALL CLAIMS IN
- * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
- * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
- *
- * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
- * TERMS.
- */
-
-#ifndef HAL_SWI_BITBANG_H_
-#define HAL_SWI_BITBANG_H_
-
-
-#if     BOARD == AT88CK9000
-#include "swi_bitbang_at88ck9000.h"
-#endif
-
-#if    (SAMD21 == 1)
-#include "swi_bitbang_samd21.h"
-#endif
-
-
-
-/**
- * \defgroup hal_ Hardware abstraction layer (hal_)
- *
- * \brief These methods define the hardware abstraction layer for
- *        communicating with a CryptoAuth device using SWI bit banging.
-   @{ */
-
-/**
- * \brief This enumeration lists flags for SWI.
- */
-enum swi_flag
-{
-    SWI_FLAG_CMD   = (uint8_t)0x77,     //!< flag preceding a command
-    SWI_FLAG_TX    = (uint8_t)0x88,     //!< flag requesting a response
-    SWI_FLAG_IDLE  = (uint8_t)0xBB,     //!< flag requesting to go into Idle mode
-    SWI_FLAG_SLEEP = (uint8_t)0xCC      //!< flag requesting to go into Sleep mode
-};
-
-/**
- * \brief This is the hal_data for ATCA HAL.
- */
-typedef struct atcaSWImaster
-{
-    uint8_t pin_sda;
-    //! for conveniences during interface release phase
-    int bus_index;
-} ATCASWIMaster_t;
-
-/** @} */
-
-#endif /* HAL_SWI_BITBANG_H_ */
\ No newline at end of file
diff --git a/lib/hal/hal_swi_uart.c b/lib/hal/hal_swi_uart.c
deleted file mode 100644
index f379d9abcd5e..000000000000
--- a/lib/hal/hal_swi_uart.c
+++ /dev/null
@@ -1,527 +0,0 @@
-/**
- * \file
- * \brief ATCA Hardware abstraction layer for SWI over UART drivers.
- *
- * \copyright (c) 2017 Microchip Technology Inc. and its subsidiaries.
- *            You may use this software and any derivatives exclusively with
- *            Microchip products.
- *
- * \page License
- *
- * (c) 2017 Microchip Technology Inc. and its subsidiaries. You may use this
- * software and any derivatives exclusively with Microchip products.
- *
- * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
- * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
- * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
- * PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
- * WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
- *
- * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
- * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
- * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
- * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
- * FULLEST EXTENT ALLOWED BY LAW, MICROCHIPS TOTAL LIABILITY ON ALL CLAIMS IN
- * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
- * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
- *
- * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
- * TERMS.
- */
-
-#include <string.h>
-#include <stdio.h>
-#include "atca_hal.h"
-#include "hal_swi_uart.h"
-#include "atca_device.h"
-
-/** \defgroup hal_ Hardware abstraction layer (hal_)
- *
- * \brief
- * These methods define the hardware abstraction layer for communicating with a CryptoAuth device
- * using SWI Interface.
- *
-   @{ */
-
-/** \brief logical to physical bus mapping structure */
-ATCASWIMaster_t *swi_hal_data[MAX_SWI_BUSES];   // map logical, 0-based bus number to index
-int swi_bus_ref_ct = 0;                         // total in-use count across buses
-
-#ifdef DEBUG_HAL
-static void print_array(uint8_t *data, uint32_t data_size)
-{
-    //	printf("%.4x\r\n", data_size);
-
-    uint32_t n;
-
-    for (n = 0; n < data_size; n++)
-    {
-        printf("%.2x ", data[n]);
-        if (((n + 1) % 16) == 0)
-        {
-            printf("\r\n");
-            if ((n + 1) != data_size)
-            {
-                printf("         ");
-            }
-        }
-    }
-    if (data_size % 16 != 0)
-    {
-        printf("\r\n");
-    }
-}
-#endif
-
-
-/** \brief discover swi buses available for this hardware
- * this maintains a list of logical to physical bus mappings freeing the application
- * of the a-priori knowledge
- * \param[in] swi_buses - an array of logical bus numbers
- * \param[in] max_buses - maximum number of buses the app wants to attempt to discover
- * \return ATCA_SUCCESS
- */
-
-ATCA_STATUS hal_swi_discover_buses(int swi_buses[], int max_buses)
-{
-    swi_uart_discover_buses(swi_buses, max_buses);
-
-    return ATCA_SUCCESS;
-}
-
-/** \brief discover any CryptoAuth devices on a given logical bus number
- * \param[in] busNum - logical bus number on which to look for CryptoAuth devices
- * \param[out] cfg[] - pointer to head of an array of interface config structures which get filled in by this method
- * \param[out] *found - number of devices found on this bus
- * \return ATCA_SUCCESS
- */
-
-ATCA_STATUS hal_swi_discover_devices(int busNum, ATCAIfaceCfg cfg[], int *found)
-{
-    ATCAIfaceCfg *head = cfg;
-    ATCADevice device;
-    ATCAIface discoverIface;
-    ATCACommand command;
-    ATCAPacket packet;
-    ATCA_STATUS status;
-    uint8_t revs508[1][4] = { { 0x00, 0x00, 0x50, 0x00 } };
-    uint8_t revs108[1][4] = { { 0x80, 0x00, 0x10, 0x01 } };
-    uint8_t revs204[3][4] = { { 0x00, 0x02, 0x00, 0x08 },
-                              { 0x00, 0x02, 0x00, 0x09 },
-                              { 0x00, 0x04, 0x05, 0x00 } };
-    unsigned int i;
-
-    /** \brief default configuration, to be reused during discovery process */
-    ATCAIfaceCfg discoverCfg = {
-        .iface_type     = ATCA_SWI_IFACE,
-        .devtype        = ATECC508A,
-        .atcaswi.bus    = busNum,
-        .wake_delay     = 800,
-        .rx_retries     = 3
-    };
-
-    // build an info command
-    packet.param1 = INFO_MODE_REVISION;
-    packet.param2 = 0;
-
-    device = newATCADevice(&discoverCfg);
-    discoverIface = atGetIFace(device);
-    command = atGetCommands(device);
-
-    // wake up device
-    // If it wakes, send it a dev rev command.  Based on that response, determine the device type
-    // BTW - this will wake every cryptoauth device living on the same bus (ecc508a, sha204a)
-
-    if (hal_swi_wake(discoverIface) == ATCA_SUCCESS)
-    {
-        (*found)++;
-        memcpy( (uint8_t*)head, (uint8_t*)&discoverCfg, sizeof(ATCAIfaceCfg));
-
-        memset(packet.data, 0x00, sizeof(packet.data));
-
-        // get devrev info and set device type accordingly
-        atInfo(command, &packet);
-        if ((status = atGetExecTime(packet.opcode, command)) != ATCA_SUCCESS)
-        {
-            return status;
-        }
-
-        // send the command
-        if ( (status = atsend(discoverIface, (uint8_t*)&packet, packet.txsize)) != ATCA_SUCCESS)
-        {
-            printf("packet send error\r\n");
-        }
-
-        // delay the appropriate amount of time for command to execute
-        atca_delay_ms((command->execution_time_msec) + 1);
-
-        // receive the response
-        if ( (status = atreceive(discoverIface, &(packet.data[0]), &(packet.rxsize) )) != ATCA_SUCCESS)
-        {
-        }
-
-        if ( (status = isATCAError(packet.data)) != ATCA_SUCCESS)
-        {
-            printf("command response error\r\n");
-        }
-
-        // determine device type from common info and dev rev response byte strings
-        for (i = 0; i < sizeof(revs508) / 4; i++)
-        {
-            if (memcmp(&packet.data[1], &revs508[i], 4) == 0)
-            {
-                discoverCfg.devtype = ATECC508A;
-                break;
-            }
-        }
-
-        for (i = 0; i < sizeof(revs204) / 4; i++)
-        {
-            if (memcmp(&packet.data[1], &revs204[i], 4) == 0)
-            {
-                discoverCfg.devtype = ATSHA204A;
-                break;
-            }
-        }
-
-        for (i = 0; i < sizeof(revs108) / 4; i++)
-        {
-            if (memcmp(&packet.data[1], &revs108[i], 4) == 0)
-            {
-                discoverCfg.devtype = ATECC108A;
-                break;
-            }
-        }
-
-        atca_delay_ms(15);
-        // now the device type is known, so update the caller's cfg array element with it
-        head->devtype = discoverCfg.devtype;
-
-        hal_swi_idle(discoverIface);
-    }
-
-    deleteATCADevice(&device);
-
-    return ATCA_SUCCESS;
-}
-
-/** \brief hal_swi_init manages requests to initialize a physical interface.  it manages use counts so when an interface
- * has released the physical layer, it will disable the interface for some other use.
- * You can have multiple ATCAIFace instances using the same bus, and you can have multiple ATCAIFace instances on
- * multiple swi buses, so hal_swi_init manages these things and ATCAIFace is abstracted from the physical details.
- */
-
-/** \brief initialize an SWI interface using given config
- * \param[in] hal - opaque ptr to HAL data
- * \param[in] cfg - interface configuration
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-
-ATCA_STATUS hal_swi_init(void *hal, ATCAIfaceCfg *cfg)
-{
-    int bus = cfg->atcaswi.bus;   // 0-based logical bus number
-    ATCAHAL_t *phal = (ATCAHAL_t*)hal;
-
-    if (swi_bus_ref_ct == 0)       // power up state, no swi buses will have been used
-    {
-        for (int i = 0; i < MAX_SWI_BUSES; i++)
-        {
-            swi_hal_data[i] = NULL;
-        }
-        swi_bus_ref_ct++;  // total across buses become 1
-    }
-
-    if (bus >= 0 && bus < MAX_SWI_BUSES)
-    {
-        // if this is the first time this bus and interface has been created, do the physical work of enabling it
-        if (swi_hal_data[bus] == NULL)
-        {
-            swi_hal_data[bus] = malloc(sizeof(ATCASWIMaster_t) );
-            // store this for use during the release phase
-            swi_hal_data[bus]->bus_index = bus;
-            // initialize  UART module for SWI interface
-            swi_uart_init(swi_hal_data[bus]);
-        }
-        else
-        {
-            // otherwise, another interface already initialized the bus, any different
-            // cfg parameters will be ignored...first one to initialize this sets the configuration
-        }
-        phal->hal_data = swi_hal_data[bus];
-
-        return ATCA_SUCCESS;
-    }
-    return ATCA_COMM_FAIL;
-}
-
-/** \brief HAL implementation of SWI post init
- * \param[in] iface  instance
- * \return ATCA_SUCCESS
- */
-
-ATCA_STATUS hal_swi_post_init(ATCAIface iface)
-{
-    return ATCA_SUCCESS;
-}
-
-/** \brief HAL implementation of SWI send one byte over UART
- * \param[in] iface  instance
- * \param[in] data   bytes to send
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-
-ATCA_STATUS hal_swi_send_flag(ATCAIface iface, uint8_t data)
-{
-    ATCA_STATUS status = ATCA_SUCCESS;
-    ATCAIfaceCfg *cfg = atgetifacecfg(iface);
-    int bus = cfg->atcaswi.bus;
-    uint8_t bit_mask, bit_data;
-
-    for (bit_mask = 1; bit_mask > 0; bit_mask <<= 1)
-    {
-        // Send one byte that represent one bit, 0x7F for one or 0x7D for zero
-        // The LSB (least significant bit) is sent first.
-        bit_data = (bit_mask & data) ? 0x7F : 0x7D;
-        status |= swi_uart_send_byte(swi_hal_data[bus], bit_data);
-
-    }
-    if (status != ATCA_SUCCESS)
-    {
-        return ATCA_COMM_FAIL;
-    }
-    else
-    {
-        return ATCA_SUCCESS;
-    }
-}
-
-/** \brief HAL implementation of SWI send command over UART
- * \param[in] iface     instance
- * \param[in] txdata    pointer to space to bytes to send
- * \param[in] txlength  number of bytes to send
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-
-ATCA_STATUS hal_swi_send(ATCAIface iface, uint8_t *txdata, int txlength)
-{
-
-#ifdef DEBUG_HAL
-    printf("hal_swi_send()\r\n");
-
-    printf("\r\nCommand Packet (size:0x%.4x)\r\n", txlength);
-    printf("Count  : %.2x\r\n", txdata[1]);
-    printf("Opcode : %.2x\r\n", txdata[2]);
-    printf("Param1 : %.2x\r\n", txdata[3]);
-    printf("Param2 : "); print_array(&txdata[4], 2);
-    if (txdata[1] > 7)
-    {
-        printf("Data   : "); print_array(&txdata[6], txdata[1] - 7);
-    }
-    printf("CRC    : "); print_array(&txdata[txdata[1] - 1], 2);
-    printf("\r\n");
-#endif
-    ATCA_STATUS status = ATCA_SUCCESS;
-    ATCAIfaceCfg *cfg = atgetifacecfg(iface);
-    int bus = cfg->atcaswi.bus;
-    uint8_t i, bit_mask, bit_data;
-
-    //Skip the Word Address data as SWI doesn't use it
-    txdata++;
-
-    status = hal_swi_send_flag(iface, SWI_FLAG_CMD);
-    if (status == ATCA_SUCCESS)
-    {
-        for (i = 0; i < txlength; i++)
-        {
-            for (bit_mask = 1; bit_mask > 0; bit_mask <<= 1)
-            {
-                // Send one byte that represent one bit, 0x7F for one or 0x7D for zero
-                // The LSB (least significant bit) is sent first.
-                bit_data = (bit_mask & *txdata) ? 0x7F : 0x7D;
-                status = swi_uart_send_byte(swi_hal_data[bus], bit_data);
-                if (status != ATCA_SUCCESS)
-                {
-                    return ATCA_COMM_FAIL;
-                }
-            }
-            txdata++;
-        }
-        return ATCA_SUCCESS;
-    }
-    return ATCA_COMM_FAIL;
-}
-
-/** \brief HAL implementation of SWI receive function over UART
- * \param[in]  iface     instance
- * \param[out] rxdata    pointer to space to receive the data
- * \param[in]  rxlength  ptr to expected number of receive bytes to request
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-
-ATCA_STATUS hal_swi_receive(ATCAIface iface, uint8_t *rxdata, uint16_t *rxlength)
-{
-#ifdef DEBUG_HAL
-    printf("hal_swi_receive()\r\n");
-#endif
-    ATCA_STATUS status = ATCA_COMM_FAIL;
-    ATCAIfaceCfg *cfg = atgetifacecfg(iface);
-    int bus = cfg->atcaswi.bus;
-    int retries = cfg->rx_retries;
-    uint8_t bit_mask, *head_buff, bit_data;
-    uint16_t i = 0;
-
-    while ((status != ATCA_SUCCESS) && (retries >= 0x00))
-    {
-        retries--;
-        head_buff = rxdata;
-
-        status = hal_swi_send_flag(iface, SWI_FLAG_TX);
-
-        // Set SWI to receive mode.
-        swi_uart_mode(swi_hal_data[bus], RECEIVE_MODE);
-#ifdef SAMD21_ASF
-        RX_DELAY
-#else
-        atca_delay_us(RX_DELAY); // Must be configured to sync with response from device
-#endif
-        if (status == ATCA_SUCCESS)
-        {
-            for (i = 0; i < *rxlength; i++)
-            {
-                *head_buff = 0x00;
-                for (bit_mask = 1; bit_mask > 0; bit_mask <<= 1)
-                {
-                    bit_data = 0;
-                    status = swi_uart_receive_byte(swi_hal_data[bus], &bit_data);
-                    if ((i == 0) && (bit_mask == 1) && (status != ATCA_SUCCESS))
-                    {
-                        break;
-                    }
-                    // Sometimes bit data from device is stretched
-                    // When the device sends a "one" bit, it is read as 0x7E or 0x7F.
-                    // When the device sends a "zero" bit, it is read as 0x7A, 0x7B, or 7D.
-                    if ((bit_data ^ 0x7F) < 2)
-                    {
-                        // Received "one" bit.
-                        *head_buff |= bit_mask;
-                    }
-                }
-                if ((i == 0) && (bit_mask == 1) && (status != ATCA_SUCCESS))
-                {
-                    break;
-                }
-                head_buff++;
-            }
-            // Set SWI to transmit mode.
-            swi_uart_mode(swi_hal_data[bus], TRANSMIT_MODE);
-            atca_delay_us(TX_DELAY); // Must be configured to sync with response from device
-        }
-        // The Response shorter than expected
-        if ((i >= 4) && (status == ATCA_TIMEOUT))
-        {
-            status = ATCA_SUCCESS;
-        }
-    }
-#ifdef DEBUG_HAL
-    printf("\r\nResponse Packet (size:0x%.4x)\r\n", *rxlength);
-    printf("Count  : %.2x\r\n", rxdata[0]);
-    if (rxdata[0] > 3)
-    {
-        printf("Data   : "); print_array(&rxdata[1], rxdata[0] - 3);
-        printf("CRC    : "); print_array(&rxdata[rxdata[0] - 2], 2);
-    }
-    printf("\r\n");
-#endif
-    return status;
-}
-
-
-/** \brief wake up CryptoAuth device using SWI interface
- * \param[in] iface  interface to logical device to wakeup
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-
-ATCA_STATUS hal_swi_wake(ATCAIface iface)
-{
-#ifdef DEBUG_HAL
-    printf("hal_swi_wake()\r\n");
-#endif
-    ATCA_STATUS status = ATCA_COMM_FAIL;
-    ATCAIfaceCfg *cfg = atgetifacecfg(iface);
-    int bus = cfg->atcaswi.bus;
-    int retries = cfg->rx_retries;
-    uint16_t datalength = 4;
-    uint8_t data[4] = { 0x00, 0x00, 0x00, 0x00 }, expected[4] = { 0x04, 0x11, 0x33, 0x43 };
-
-    while ((status != ATCA_SUCCESS) && (retries >= 0x00))
-    {
-        retries--;
-        // Change baudrate to 115200 to get low signal more than 60us
-        swi_uart_setbaud(swi_hal_data[bus], 115200);
-        // Send byte 0x00
-        status = swi_uart_send_byte(swi_hal_data[bus], SWI_WAKE_TOKEN);
-        // Change baudrate back to 230400
-        swi_uart_setbaud(swi_hal_data[bus], 230400);
-    }
-
-    if (!status)
-    {
-        atca_delay_us(cfg->wake_delay);  // wait tWHI + tWLO which is configured based on device type and configuration structure
-        status = hal_swi_receive(iface, data, &datalength);
-    }
-
-    if ((retries == 0x00) && (status != ATCA_SUCCESS) )
-    {
-        return ATCA_TIMEOUT;
-    }
-
-    if (memcmp(data, expected, 4) == 0)
-    {
-        return ATCA_SUCCESS;
-    }
-
-    return ATCA_COMM_FAIL;
-}
-
-/** \brief idle CryptoAuth device using SWI interface
- * \param[in] iface  interface to logical device to idle
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-
-ATCA_STATUS hal_swi_idle(ATCAIface iface)
-{
-    return hal_swi_send_flag(iface, SWI_FLAG_IDLE);
-}
-
-/** \brief sleep CryptoAuth device using SWI interface
- * \param[in] iface  interface to logical device to sleep
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-
-ATCA_STATUS hal_swi_sleep(ATCAIface iface)
-{
-    return hal_swi_send_flag(iface, SWI_FLAG_SLEEP);
-}
-
-/** \brief manages reference count on given bus and releases resource if no more refences exist
- * \param[in] hal_data - opaque pointer to hal data structure - known only to the HAL implementation
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-
-ATCA_STATUS hal_swi_release(void *hal_data)
-{
-    ATCASWIMaster_t *hal = (ATCASWIMaster_t*)hal_data;
-
-    swi_bus_ref_ct--;  // track total SWI instances
-
-    // if the use count for this bus has gone to 0 references, disable it.  protect against an unbracketed release
-    if (hal && swi_hal_data[hal->bus_index] != NULL)
-    {
-        swi_uart_deinit(swi_hal_data[hal->bus_index]);
-        free(swi_hal_data[hal->bus_index]);
-        swi_hal_data[hal->bus_index] = NULL;
-    }
-    return ATCA_SUCCESS;
-}
-
-/** @} */
diff --git a/lib/hal/hal_swi_uart.h b/lib/hal/hal_swi_uart.h
deleted file mode 100644
index 75274a7d4f2e..000000000000
--- a/lib/hal/hal_swi_uart.h
+++ /dev/null
@@ -1,62 +0,0 @@
-/**
- * \file
- * \brief ATCA Hardware abstraction layer for SWI over UART drivers.
- *
- * \copyright (c) 2017 Microchip Technology Inc. and its subsidiaries.
- *            You may use this software and any derivatives exclusively with
- *            Microchip products.
- *
- * \page License
- *
- * (c) 2017 Microchip Technology Inc. and its subsidiaries. You may use this
- * software and any derivatives exclusively with Microchip products.
- *
- * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
- * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
- * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
- * PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
- * WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
- *
- * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
- * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
- * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
- * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
- * FULLEST EXTENT ALLOWED BY LAW, MICROCHIPS TOTAL LIABILITY ON ALL CLAIMS IN
- * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
- * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
- *
- * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
- * TERMS.
- */
-
-#ifndef HAL_SWI_UART_H_
-#define HAL_SWI_UART_H_
-
-#ifdef SAMD21_START
-    #include "swi_uart_samd21_start.h"
-#elif defined (SAMD21_ASF)
-    #include "swi_uart_samd21_asf.h"
-#elif defined (XMEGA_ASF)
-    #include "swi_uart_xmega_a3bu_asf.h"
-#elif defined (AT90USB_ASF)
-    #include "swi_uart_at90usb1287_asf.h"
-#endif
-
-
-/** \defgroup hal_ Hardware abstraction layer (hal_)
- *
- * \brief
- * These methods define the hardware abstraction layer for communicating with a CryptoAuth device
- * using SWI interface.
- *
-   @{ */
-#define SWI_WAKE_TOKEN   ((uint8_t)0x00)    //!< flag preceding a command
-#define SWI_FLAG_CMD     ((uint8_t)0x77)    //!< flag preceding a command
-#define SWI_FLAG_TX      ((uint8_t)0x88)    //!< flag requesting a response
-#define SWI_FLAG_IDLE    ((uint8_t)0xBB)    //!< flag requesting to go into Idle mode
-#define SWI_FLAG_SLEEP   ((uint8_t)0xCC)    //!< flag requesting to go into Sleep mode
-
-ATCA_STATUS hal_swi_send_flag(ATCAIface iface, uint8_t flag);
-
-/** @} */
-#endif /* HAL_SWI_UART_H_ */
\ No newline at end of file
diff --git a/lib/hal/hal_win_kit_cdc.c b/lib/hal/hal_win_kit_cdc.c
deleted file mode 100644
index be3664f3df3b..000000000000
--- a/lib/hal/hal_win_kit_cdc.c
+++ /dev/null
@@ -1,556 +0,0 @@
-/**
- * \file
- * \brief ATCA Hardware abstraction layer for Windows using kit protocol over a USB CDC device.
- *
- * \copyright (c) 2017 Microchip Technology Inc. and its subsidiaries.
- *            You may use this software and any derivatives exclusively with
- *            Microchip products.
- *
- * \page License
- *
- * (c) 2017 Microchip Technology Inc. and its subsidiaries. You may use this
- * software and any derivatives exclusively with Microchip products.
- *
- * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
- * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
- * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
- * PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
- * WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
- *
- * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
- * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
- * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
- * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
- * FULLEST EXTENT ALLOWED BY LAW, MICROCHIPS TOTAL LIABILITY ON ALL CLAIMS IN
- * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
- * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
- *
- * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
- * TERMS.
- */
-
-//#include "atca_basic.h"
-#include "atca_hal.h"
-#include "kit_phy.h"
-#include "hal_win_kit_cdc.h"
-#include "kit_protocol.h"
-
-#include <SetupAPI.h>
-#include <stdlib.h>
-#include <tchar.h>
-#include <stdio.h>
-
-
-// File scope globals
-atcacdc_t _gCdc;
-
-
-
-/** \brief HAL implementation of Kit USB CDC init
- *  \param[in] hal pointer to HAL specific data that is maintained by this HAL
- *  \param[in] cfg pointer to HAL specific configuration data that is used to initialize this HAL
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-ATCA_STATUS hal_kit_cdc_init(void* hal, ATCAIfaceCfg* cfg)
-{
-    ATCA_STATUS status = ATCA_SUCCESS;
-    ATCAHAL_t *phal = NULL;
-    GUID *pcdc_guid = NULL;
-    HDEVINFO dev_info;
-    SP_DEVINFO_DATA dev_data;
-    DWORD device_index = 0;
-    DWORD required_size = 0;
-    HKEY reg_key;
-    DWORD reg_type = 0;
-    TCHAR reg_data[256];
-    TCHAR cdc_data[256];
-    BOOL result = FALSE;
-    LONG reg_result = 0;
-    DCB dcb_settings;
-    COMMTIMEOUTS comm_timeouts;
-    int i = 0;
-    int index = 0;
-
-    // Check the input variables
-    if ((hal == NULL) || (cfg == NULL))
-    {
-        return ATCA_BAD_PARAM;
-    }
-
-    // Cast the hal to the ATCAHAL_t strucure
-    phal = (ATCAHAL_t*)hal;
-
-    // Initialize the _gCdc structure
-    memset(&_gCdc, 0, sizeof(_gCdc));
-    for (i = 0; i < CDC_DEVICES_MAX; i++)
-    {
-        _gCdc.kits[i].read_handle = INVALID_HANDLE_VALUE;
-        _gCdc.kits[i].write_handle = INVALID_HANDLE_VALUE;
-    }
-
-    _gCdc.num_kits_found = 0;
-
-    // Get the number of available GUIDs
-    result = SetupDiClassGuidsFromName(_T("Ports"), NULL, 0, &required_size);
-    if (required_size == 0)
-    {
-        return ATCA_COMM_FAIL;
-    }
-
-    // Allocated the memory the GUID list
-    pcdc_guid = malloc(required_size * sizeof(GUID));
-
-    // Get the number of available GUIDs
-    result = SetupDiClassGuidsFromName(_T("Ports"), pcdc_guid, required_size, &required_size);
-    if (result == TRUE)
-    {
-        //Query the devices
-        dev_info = SetupDiGetClassDevs(pcdc_guid, NULL, NULL, DIGCF_PRESENT);
-        if (dev_info != INVALID_HANDLE_VALUE)
-        {
-            // Initialize the dev_data object
-            memset(&dev_data, 0, sizeof(SP_DEVINFO_DATA));
-            dev_data.cbSize = sizeof(SP_DEVINFO_DATA);
-
-            while (SetupDiEnumDeviceInfo(dev_info, device_index, &dev_data))
-            {
-                // Get the USB CDC friendly name
-                required_size = sizeof(reg_data);
-                result = SetupDiGetDeviceRegistryProperty(dev_info, &dev_data, SPDRP_FRIENDLYNAME, &reg_type,
-                                                          (PBYTE)reg_data, required_size, &required_size);
-                if (result == TRUE)
-                {
-                    // Determine if this is the correct kit USB CDC device
-                    if ((_tcsstr(reg_data, _T("AT90USB"))) ||
-                        (_tcsstr(reg_data, _T("XPLAINED"))) ||
-                        (_tcsstr(reg_data, _T("Class ASF"))))
-                    {
-                        // Get the registry key for the kit USB CDC device
-                        reg_key = SetupDiOpenDevRegKey(dev_info, &dev_data, DICS_FLAG_GLOBAL,
-                                                       0, DIREG_DEV, KEY_QUERY_VALUE);
-                        if (reg_key != INVALID_HANDLE_VALUE)
-                        {
-                            // Get the port used with this kit USB CDC device
-                            required_size = sizeof(reg_data);
-                            reg_result = RegQueryValueEx(reg_key, _T("PortName"), NULL, NULL,
-                                                         (LPBYTE)reg_data, &required_size);
-                            if (reg_result == ERROR_SUCCESS)
-                            {
-                                _sntprintf_s(cdc_data, sizeof(cdc_data) / sizeof(cdc_data[0]), _TRUNCATE, _T("\\\\.\\%s"), reg_data);
-
-                                // Open the kit USB device for reading and writing
-                                if (_gCdc.kits[index].read_handle != INVALID_HANDLE_VALUE)
-                                {
-                                    CloseHandle(_gCdc.kits[index].read_handle);
-                                }
-                                _gCdc.kits[index].read_handle  = INVALID_HANDLE_VALUE;
-                                _gCdc.kits[index].write_handle = INVALID_HANDLE_VALUE;
-
-                                _gCdc.kits[index].read_handle = CreateFile(cdc_data,
-                                                                           GENERIC_READ | GENERIC_WRITE,
-                                                                           0,
-                                                                           NULL,
-                                                                           OPEN_EXISTING,
-                                                                           FILE_ATTRIBUTE_NORMAL,
-                                                                           NULL);
-                                _gCdc.kits[index].write_handle = _gCdc.kits[index].read_handle;
-
-                                if (_gCdc.kits[index].read_handle != INVALID_HANDLE_VALUE)
-                                {
-                                    // Get the comm settings
-                                    dcb_settings.DCBlength = sizeof(DCB);
-                                    result = GetCommState(_gCdc.kits[index].read_handle, &dcb_settings);
-                                    if (result == FALSE)
-                                    {
-                                        continue;
-                                    }
-
-                                    // Set the comm settings
-                                    dcb_settings.BaudRate = cfg->atcauart.baud;
-                                    dcb_settings.ByteSize = cfg->atcauart.wordsize;
-                                    dcb_settings.StopBits = cfg->atcauart.stopbits;
-
-                                    switch (cfg->atcauart.parity)
-                                    {
-                                    case 0:  dcb_settings.Parity = EVENPARITY;
-                                    case 1:  dcb_settings.Parity = ODDPARITY;
-                                    case 2:  dcb_settings.Parity = NOPARITY;
-                                    default: dcb_settings.Parity = NOPARITY;
-                                    }
-
-                                    result = SetCommState(_gCdc.kits[index].read_handle, &dcb_settings);
-                                    if (result == FALSE)
-                                    {
-                                        continue;
-                                    }
-
-                                    // Set the comm timeout settings
-                                    comm_timeouts.ReadIntervalTimeout = 3;
-                                    comm_timeouts.ReadTotalTimeoutMultiplier = 3;
-                                    comm_timeouts.ReadTotalTimeoutConstant = 2;
-                                    comm_timeouts.WriteTotalTimeoutMultiplier = 3;
-                                    comm_timeouts.WriteTotalTimeoutConstant = 2;
-
-                                    SetCommTimeouts(_gCdc.kits[index].read_handle, &comm_timeouts);
-                                }
-
-                                // Increment the opened kit USB device index
-                                index++;
-                            }
-
-                            // Close the registry key
-                            RegCloseKey(reg_key);
-                        }
-                    }
-                }
-
-                // Break the while loop, if the maximum number of supported
-                // kit USB devices have been found
-                if (index == CDC_DEVICES_MAX)
-                {
-                    break;
-                }
-
-                // Increment the device member index
-                device_index++;
-            }
-        }
-
-        // Delete device info now that we're done
-        SetupDiDestroyDeviceInfoList(dev_info);
-    }
-
-    // Free allocated memory
-    free(pcdc_guid);
-
-    // Save the results of this discovery of HID
-    if (index > 0)
-    {
-        _gCdc.num_kits_found = index;
-        phal->hal_data = &_gCdc;
-        return status;
-    }
-    return ATCA_NO_DEVICES;
-}
-
-/** \brief discover all CDC kits available.This function is currently not implemented.
- * this maintains a list of logical to physical bus mappings freeing the application
- * of the a-priori knowledge
- * \param[in] i2c_buses - an array of logical bus numbers
- * \param[in] max_buses - maximum number of buses the app wants to attempt to discover
- * \return ATCA_UNIMPLEMENTED
- */
-
-ATCA_STATUS hal_cdc_discover_buses(int i2c_buses[], int max_buses)
-{
-    // TODO: This should be set to the com port index(s)
-    return ATCA_UNIMPLEMENTED;
-}
-
-/** \brief discover any CryptoAuth devices on a given logical bus number.This function is currently not implemented.
- * \param[in] busNum - logical bus number on which to look for CryptoAuth devices
- * \param[out] cfg[] - pointer to head of an array of interface config structures which get filled in by this method
- * \param[out] *found - number of devices found on this bus
- * \return ATCA_UNIMPLEMENTED
- */
-ATCA_STATUS hal_cdc_discover_devices(int busNum, ATCAIfaceCfg cfg[], int *found)
-{
-    // TODO: Add kitg protocol calls to discover all devices
-    return ATCA_UNIMPLEMENTED;
-}
-
-
-/** \brief HAL implementation of Kit USB CDC post init
- *  \param[in] iface instance
- *  \return ATCA_SUCCESS on success, otherwise an error code.
- */
-ATCA_STATUS hal_kit_cdc_post_init(ATCAIface iface)
-{
-    ATCA_STATUS status = ATCA_SUCCESS;
-    atcacdc_t* pHalDat = atgetifacehaldat(iface);
-    ATCAIfaceCfg *pCfg = atgetifacecfg(iface);
-    int i = 0;
-
-    do
-    {
-        // Check the pointers
-        if (pHalDat == NULL || pCfg == NULL)
-        {
-            status = ATCA_BAD_PARAM;
-            BREAK(status, "NULL pointers in hal_kit_cdc_post_init");
-        }
-        // Init all kit USB devices
-        for (i = 0; i < pHalDat->num_kits_found; i++)
-        {
-            // Set the port
-            pCfg->atcauart.port = i;
-            // Perform the kit protocol init
-            status = kit_init(iface);
-            if (status != ATCA_SUCCESS)
-            {
-                BREAK(status, "kit_init() Failed");
-            }
-        }
-    }
-    while (0);
-    return status;
-}
-
-/** \brief HAL implementation of kit protocol send .It is called by the top layer.
- *  \param[in] iface     instance
- *  \param[in] txdata    pointer to bytes to send
- *  \param[in] txlength  number of bytes to send
- *  \return ATCA_SUCCESS on success, otherwise an error code.
- */
-ATCA_STATUS kit_phy_send(ATCAIface iface, const char* txdata, int txlength)
-{
-    ATCA_STATUS status = ATCA_SUCCESS;
-    ATCAIfaceCfg *cfg = atgetifacecfg(iface);
-    int cdcid = cfg->atcauart.port;
-    atcacdc_t* pCdc = (atcacdc_t*)atgetifacehaldat(iface);
-    uint8_t buffer[CDC_BUFFER_MAX];
-    DWORD bytes_to_send = 0;
-    DWORD bytes_left = 0;
-    DWORD bytes_sent = 0;
-    BOOL result = FALSE;
-
-    if ((txdata == NULL) || (pCdc == NULL))
-    {
-        return ATCA_BAD_PARAM;
-    }
-
-    if (pCdc->kits[cdcid].write_handle == INVALID_HANDLE_VALUE)
-    {
-        return ATCA_COMM_FAIL;
-    }
-
-    bytes_left = txlength;
-
-    while (bytes_left > 0)
-    {
-        memset(buffer, 0, CDC_BUFFER_MAX);
-
-        if (bytes_left >= CDC_BUFFER_MAX)
-        {
-            bytes_to_send = CDC_BUFFER_MAX;
-        }
-        else
-        {
-            bytes_to_send = bytes_left;
-        }
-
-        memcpy(&buffer[0], &txdata[(txlength - bytes_left)], bytes_to_send);
-
-        result = WriteFile(pCdc->kits[cdcid].write_handle, buffer, bytes_to_send, &bytes_sent, NULL);
-        if (result == FALSE)
-        {
-            return ATCA_TX_FAIL;
-        }
-
-        bytes_left -= bytes_sent;
-    }
-    return status;
-}
-
-
-/** \brief HAL implementation of kit protocol receive data.It is called by the top layer.
- * \param[in]    iface   instance
- * \param[out]   rxdata  pointer to space to receive the data
- * \param[inout] rxsize  ptr to expected number of receive bytes to request
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-ATCA_STATUS kit_phy_receive(ATCAIface iface, char* rxdata, int* rxsize)
-{
-    ATCAIfaceCfg *cfg = atgetifacecfg(iface);
-    int cdcid = cfg->atcauart.port;
-    atcacdc_t* pCdc = (atcacdc_t*)atgetifacehaldat(iface);
-    uint8_t buffer[CDC_BUFFER_MAX] = { 0 };
-    BOOL continue_read = TRUE;
-    DWORD bytes_read = 0;
-    DWORD total_bytes = 0;
-    BOOL result = true;
-    uint8_t* location = NULL;
-    int bytes_remain = 0;
-    int bytes_to_copy = 0;
-    int size_adjust = 0;
-
-    // Verify the input variables
-    if ((rxdata == NULL) || (rxsize == NULL) || (pCdc == NULL))
-    {
-        return ATCA_BAD_PARAM;
-    }
-
-    if (pCdc->kits[cdcid].read_handle == INVALID_HANDLE_VALUE)
-    {
-        return ATCA_COMM_FAIL;
-    }
-
-    DWORD start_time_ms = GetTickCount();
-    while (continue_read == true)
-    {
-        // If the CDC port disappears while trying to read, ReadFile will continue to report
-        // success and return 0 bytes. Same as when we're waiting for a reply. This lets the
-        // operation timeout.
-        if (GetTickCount() - start_time_ms > 3000)
-        {
-            // Close handles to force a quicker failure.
-            CloseHandle(pCdc->kits[cdcid].read_handle);
-            pCdc->kits[cdcid].read_handle = INVALID_HANDLE_VALUE;
-            pCdc->kits[cdcid].write_handle = INVALID_HANDLE_VALUE;
-            return ATCA_COMM_FAIL;
-        }
-
-        result = ReadFile(pCdc->kits[cdcid].read_handle, buffer, CDC_BUFFER_MAX, &bytes_read, NULL);
-        if (result == FALSE)
-        {
-            return ATCA_RX_FAIL;
-        }
-
-        // Find the location of the '\n' character in read buffer
-        // todo: generalize this read...  it only applies if there is an ascii protocol with an <eom> of \n and if the <eom> exists
-        location = strchr((char*)&buffer[0], '\n');
-        if (location == NULL)
-        {
-            // Copy all of the bytes
-            bytes_to_copy = bytes_read;
-        }
-        else
-        {
-            // Copy only the bytes remaining in the read buffer to the <eom>
-            bytes_to_copy = (int)(location - (char*)buffer);
-
-            // The response has been received, stop receiving more data
-            continue_read = false;
-        }
-        // Protect rxdata from overwriting, this will have the result of truncating the returned bytes
-        // Remaining space in rxdata
-        bytes_remain = (*rxsize - total_bytes);
-        // Use the minimum between number of bytes read and remaining space
-        bytes_to_copy = min(bytes_remain, bytes_to_copy);
-
-        // Copy the received data
-        memcpy(&rxdata[total_bytes], &buffer[0], bytes_to_copy);
-        total_bytes += bytes_to_copy - size_adjust;
-    }
-    *rxsize = total_bytes;
-    return ATCA_SUCCESS;
-}
-
-/** \brief Number of USB CDC devices found
- *  \param[out] num_found Number of USB CDC devices found returned here
- *  \return ATCA_SUCCESS
- */
-ATCA_STATUS hal_kit_phy_num_found(int8_t* num_found)
-{
-    *num_found = _gCdc.num_kits_found;
-    return ATCA_SUCCESS;
-}
-
-/** \brief HAL implementation of kit protocol send over USB CDC
- *  \param[in] iface instance
- *  \param[in] txdata pointer to bytes to send
- *  \param[in] txlength number of bytes to send
- *  \return ATCA_SUCCESS on success, otherwise an error code.
- */
-ATCA_STATUS hal_kit_cdc_send(ATCAIface iface, uint8_t* txdata, int txlength)
-{
-    // Call the hal_kit_send() function that will call hal_phy_send() implemented below
-    return kit_send(iface, txdata, txlength);
-}
-
-/** \brief HAL implementation of kit protocol receive over USB CDC
- * \param[in]    iface   instance
- * \param[in]    rxdata  pointer to space to receive the data
- * \param[inout] rxsize  ptr to expected number of receive bytes to request
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-ATCA_STATUS hal_kit_cdc_receive(ATCAIface iface, uint8_t* rxdata, uint16_t* rxsize)
-{
-    // Call the hal_kit_receive() function that will call hal_phy_receive() implemented below
-    return kit_receive(iface, rxdata, rxsize);
-}
-
-/** \brief Call the wake for kit protocol over USB CDC
- * \param[in] iface ATCAIface instance that is the interface object to send the bytes over
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-ATCA_STATUS hal_kit_cdc_wake(ATCAIface iface)
-{
-    // Call the hal_kit_wake() function that will call hal_phy_send() and hal_phy_receive()
-    return kit_wake(iface);
-}
-
-/** \brief Call the idle for kit protocol over USB CDC
- * \param[in] iface ATCAIface instance that is the interface object to send the bytes over
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-ATCA_STATUS hal_kit_cdc_idle(ATCAIface iface)
-{
-    // Call the hal_kit_idle() function that will call hal_phy_send() and hal_phy_receive()
-    return kit_idle(iface);
-}
-
-/** \brief Call the sleep for kit protocol over USB CDC
- * \param[in] iface ATCAIface instance that is the interface object to send the bytes over
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-ATCA_STATUS hal_kit_cdc_sleep(ATCAIface iface)
-{
-    // Call the hal_kit_sleep() function that will call hal_phy_send() and hal_phy_receive()
-    return kit_sleep(iface);
-}
-
-/** \brief Close the physical port for CDC
- * \param[in] hal_data The hardware abstraction data specific to this HAL
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-ATCA_STATUS hal_kit_cdc_release(void* hal_data)
-{
-    int i = 0;
-    atcacdc_t* phaldat = (atcacdc_t*)hal_data;
-
-    if ((hal_data == NULL))
-    {
-        return ATCA_BAD_PARAM;
-    }
-
-    // Close all kit USB devices
-    for (i = 0; i < phaldat->num_kits_found; i++)
-    {
-        if (phaldat->kits[i].read_handle != INVALID_HANDLE_VALUE)
-        {
-            CloseHandle(phaldat->kits[i].read_handle);
-            phaldat->kits[i].read_handle  = INVALID_HANDLE_VALUE;
-            phaldat->kits[i].write_handle = INVALID_HANDLE_VALUE;
-        }
-    }
-    return ATCA_SUCCESS;
-}
-
-/** \brief discover cdc buses available for this hardware
- * this maintains a list of logical to physical bus mappings freeing the application
- * of the a-priori knowledge.This function is currently not implemented.
- * \param[in] cdc_buses - an array of logical bus numbers
- * \param[in] max_buses - maximum number of buses the app wants to attempt to discover
- * \return ATCA_UNIMPLEMENTED
- */
-
-ATCA_STATUS hal_kit_cdc_discover_buses(int cdc_buses[], int max_buses)
-{
-    // TODO: Implement
-    return ATCA_UNIMPLEMENTED;
-}
-
-
-/** \brief discover any CryptoAuth devices on a given logical bus number
- * \param[in] busNum - logical bus number on which to look for CryptoAuth devices
- * \param[out] cfg[] - pointer to head of an array of interface config structures which get filled in by this method
- * \param[out] *found - number of devices found on this bus
- * \return ATCA_UNIMPLEMENTED
- */
-ATCA_STATUS hal_kit_cdc_discover_devices(int busNum, ATCAIfaceCfg *cfg, int *found)
-{
-    // TODO: Implement
-    *found = 0;
-    return ATCA_UNIMPLEMENTED;
-}
\ No newline at end of file
diff --git a/lib/hal/hal_win_kit_cdc.h b/lib/hal/hal_win_kit_cdc.h
deleted file mode 100644
index 8970d54965e2..000000000000
--- a/lib/hal/hal_win_kit_cdc.h
+++ /dev/null
@@ -1,58 +0,0 @@
-/**
- * \file
- * \brief ATCA Hardware abstraction layer for Windows using kit protocol over a USB CDC device.
- *
- * \copyright (c) 2017 Microchip Technology Inc. and its subsidiaries.
- *            You may use this software and any derivatives exclusively with
- *            Microchip products.
- *
- * \page License
- *
- * (c) 2017 Microchip Technology Inc. and its subsidiaries. You may use this
- * software and any derivatives exclusively with Microchip products.
- *
- * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
- * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
- * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
- * PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
- * WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
- *
- * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
- * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
- * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
- * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
- * FULLEST EXTENT ALLOWED BY LAW, MICROCHIPS TOTAL LIABILITY ON ALL CLAIMS IN
- * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
- * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
- *
- * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
- * TERMS.
- */
-
-#ifndef HAL_WIN_KIT_CDC_H_
-#define HAL_WIN_KIT_CDC_H_
-
-#include <Windows.h>
-
-// Kit USB defines
-#define CDC_DEVICES_MAX     10      //! Maximum number of supported Kit USB devices
-#define CDC_BUFFER_MAX      1024    //! Maximum number of bytes read per port read
-
-
-// Each device that is found will have a read handle and a write handle
-typedef struct cdc_device
-{
-    HANDLE read_handle;         //! The kit USB read file handle
-    HANDLE write_handle;        //! The kit USB write file handle
-} cdc_device_t;
-
-
-// A structure to hold CDC information
-typedef struct atcacdc
-{
-    cdc_device_t kits[CDC_DEVICES_MAX];
-    int8_t       num_kits_found;
-} atcacdc_t;
-
-#endif /* HAL_WIN_KIT_CDC_H_ */
-
diff --git a/lib/hal/hal_win_kit_hid.c b/lib/hal/hal_win_kit_hid.c
deleted file mode 100644
index 44b52120bbee..000000000000
--- a/lib/hal/hal_win_kit_hid.c
+++ /dev/null
@@ -1,469 +0,0 @@
-/**
- * \file
- * \brief ATCA Hardware abstraction layer for Windows using kit protocol over a USB HID device.
- *
- * \copyright (c) 2017 Microchip Technology Inc. and its subsidiaries.
- *            You may use this software and any derivatives exclusively with
- *            Microchip products.
- *
- * \page License
- *
- * (c) 2017 Microchip Technology Inc. and its subsidiaries. You may use this
- * software and any derivatives exclusively with Microchip products.
- *
- * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
- * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
- * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
- * PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
- * WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
- *
- * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
- * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
- * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
- * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
- * FULLEST EXTENT ALLOWED BY LAW, MICROCHIPS TOTAL LIABILITY ON ALL CLAIMS IN
- * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
- * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
- *
- * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
- * TERMS.
- */
-
-#include "atca_hal.h"
-#include "hal_win_kit_hid.h"
-#include "kit_protocol.h"
-#include "kit_phy.h"
-#include <SetupAPI.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <tchar.h>
-
-/** \defgroup hal_ Hardware abstraction layer (hal_)
- *
- * \brief
- * These methods define the hardware abstraction layer for communicating with a CryptoAuth device
- *
-   @{ */
-
-// File scope globals
-atcahid_t _gHid;
-
-// The HID GUID filter
-#define HID_GUID    { 0x4d1e55b2, 0xf16f, 0x11cf, 0x88, 0xcb, 0x00, 0x11, 0x11, 0x00, 0x00, 0x30 }
-
-
-
-/** \brief HAL implementation of Kit USB HID init
- *  \param[in] hal pointer to HAL specific data that is maintained by this HAL
- *  \param[in] cfg pointer to HAL specific configuration data that is used to initialize this HAL
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-ATCA_STATUS hal_kit_hid_init(void* hal, ATCAIfaceCfg* cfg)
-{
-    ATCA_STATUS status = ATCA_SUCCESS;
-    ATCAHAL_t *phal = NULL;
-    GUID hid_guid = HID_GUID;
-    HDEVINFO dev_info;
-    SP_DEVICE_INTERFACE_DATA dev_data;
-    PSP_DEVICE_INTERFACE_DETAIL_DATA dev_detail_data;
-    DWORD required_size = 0;
-    BOOL result = FALSE;
-    DWORD device_index = 0;
-    int i = 0;
-    int index = 0;
-    TCHAR hid_filter[32];
-
-    // Check the input variables
-    if ((hal == NULL) || (cfg == NULL))
-    {
-        return ATCA_BAD_PARAM;
-    }
-
-    // Cast the hal to the ATCAHAL_t strucure
-    phal = (ATCAHAL_t*)hal;
-
-    // Initialize the _gHid structure
-    memset(&_gHid, 0, sizeof(_gHid));
-    for (i = 0; i < HID_DEVICES_MAX; i++)
-    {
-        _gHid.kits[i].read_handle = INVALID_HANDLE_VALUE;
-        _gHid.kits[i].write_handle = INVALID_HANDLE_VALUE;
-    }
-
-    _gHid.num_kits_found = 0;
-
-    // Initialize the GUID
-//	UuidFromString(cfg->atcahid.guid, &hid_guid);
-
-    // Query the devices
-    dev_info = SetupDiGetClassDevs(&hid_guid, NULL, NULL, (DIGCF_PRESENT | DIGCF_DEVICEINTERFACE));
-    if (dev_info == INVALID_HANDLE_VALUE)
-    {
-        return ATCA_COMM_FAIL;
-    }
-
-    // Initialize the dev_data object
-    memset(&dev_data, 0, sizeof(SP_DEVICE_INTERFACE_DATA));
-    dev_data.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);
-
-    // Construct the filter string
-    memset(hid_filter, 0, sizeof(hid_filter));
-    _stprintf(hid_filter, _T("vid_%04x&pid_%04x"), cfg->atcahid.vid, cfg->atcahid.pid);
-
-    // Find the Atmel kit USB devices
-    while (SetupDiEnumDeviceInterfaces(dev_info, NULL, &hid_guid, device_index, &dev_data))
-    {
-        // Get the required buffer size of the detailed data
-        SetupDiGetDeviceInterfaceDetail(dev_info, &dev_data, NULL, 0, &required_size, NULL);
-
-        // Allocate the required space for the detailed interface data
-        dev_detail_data = (PSP_DEVICE_INTERFACE_DETAIL_DATA)malloc(required_size);
-
-        // Retrieve the detailed interface data
-        dev_detail_data->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);
-        result = SetupDiGetDeviceInterfaceDetail(dev_info, &dev_data, dev_detail_data,
-                                                 required_size, &required_size, NULL);
-
-        // Determine if this is the correct kit USB device
-
-        if (_tcsstr(dev_detail_data->DevicePath, hid_filter) != NULL)
-        {
-            // Open the kit USB device for reading and writing
-            if (_gHid.kits[index].read_handle != INVALID_HANDLE_VALUE)
-            {
-                CloseHandle(_gHid.kits[index].read_handle);
-            }
-            if (_gHid.kits[index].write_handle != INVALID_HANDLE_VALUE)
-            {
-                CloseHandle(_gHid.kits[index].write_handle);
-            }
-
-            _gHid.kits[index].read_handle = CreateFile(dev_detail_data->DevicePath,
-                                                       GENERIC_READ,
-                                                       (FILE_SHARE_READ | FILE_SHARE_WRITE),
-                                                       NULL,
-                                                       OPEN_EXISTING,
-                                                       0,
-                                                       NULL);
-            _gHid.kits[index].write_handle = CreateFile(dev_detail_data->DevicePath,
-                                                        GENERIC_WRITE,
-                                                        (FILE_SHARE_READ | FILE_SHARE_WRITE),
-                                                        NULL,
-                                                        OPEN_EXISTING,
-                                                        0,
-                                                        NULL);
-
-            // Increment the opened kit USB device index
-            index++;
-        }
-        // Deallocate the required space for the detailed interface data
-        free(dev_detail_data);
-
-        // Break the while loop, if the maximum number of supported
-        // kit USB devices have been found
-        if (index == HID_DEVICES_MAX)
-        {
-            break;
-        }
-
-        // Increment the device member index
-        device_index++;
-    }
-
-    // Delete device info now that we're done
-    SetupDiDestroyDeviceInfoList(dev_info);
-
-    // Save the results of this discovery of HID
-    if (index > 0)
-    {
-        _gHid.num_kits_found = index;
-        phal->hal_data = &_gHid;
-    }
-    return status;
-}
-
-
-/** \brief discover all HID kits available.This function is currently not implemented.
- * this maintains a list of logical to physical bus mappings freeing the application
- * of the a-priori knowledge
- * \param[in] cdc_buses  an array of logical bus numbers
- * \param[in] max_buses  maximum number of buses the app wants to attempt to discover
- * \return ATCA_UNIMPLEMENTED
- */
-ATCA_STATUS hal_kit_hid_discover_buses(int cdc_buses[], int max_buses)
-{
-    // TODO: This should be set to the com port index(s)
-    return ATCA_UNIMPLEMENTED;
-}
-
-/** \brief discover any CryptoAuth devices on a given logical bus number.This function is currently not implemented.
- * \param[in] busNum - logical bus number on which to look for CryptoAuth devices
- * \param[out] cfg[] - pointer to head of an array of interface config structures which get filled in by this method
- * \param[out] *found - number of devices found on this bus
- * \return ATCA_UNIMPLEMENTED
- */
-ATCA_STATUS hal_kit_hid_discover_devices(int busNum, ATCAIfaceCfg cfg[], int *found)
-{
-    // TODO: Add kitg protocol calls to discover all devices
-    return ATCA_UNIMPLEMENTED;
-}
-
-/** \brief HAL implementation of Kit HID post init
- *  \param[in] iface  instance
- *  \return ATCA_SUCCESS on success, otherwise an error code.
- */
-ATCA_STATUS hal_kit_hid_post_init(ATCAIface iface)
-{
-    ATCA_STATUS status = ATCA_SUCCESS;
-    atcahid_t* pHid = atgetifacehaldat(iface);
-    ATCAIfaceCfg *pCfg = atgetifacecfg(iface);
-    int i = 0;
-
-    do
-    {
-        // Check the pointers
-        if (pHid == NULL || pCfg == NULL)
-        {
-            status = ATCA_BAD_PARAM;
-            BREAK(status, "NULL pointers in hal_kit_hid_post_init");
-        }
-        // Init all kit USB HID devices
-        for (i = 0; i < pHid->num_kits_found; i++)
-        {
-            // Perform the kit protocol init
-            status = kit_init(iface);
-            if (status != ATCA_SUCCESS)
-            {
-                BREAK(status, "kit_init() Failed");
-            }
-        }
-
-    }
-    while (0);
-    return status;
-}
-
-/** \brief HAL implementation of kit protocol send .It is called by the top layer.
- *  \param[in] iface     instance
- *  \param[in] txdata    pointer to bytes to send
- *  \param[in] txlength  number of bytes to send
- *  \return ATCA_SUCCESS on success, otherwise an error code.
- */
-ATCA_STATUS kit_phy_send(ATCAIface iface, const char* txdata, int txlength)
-{
-    ATCA_STATUS status = ATCA_SUCCESS;
-    ATCAIfaceCfg *cfg = atgetifacecfg(iface);
-    int hidid = cfg->atcahid.idx;
-    atcahid_t* pHid = (atcahid_t*)atgetifacehaldat(iface);
-    uint8_t buffer[HID_PACKET_MAX];
-    DWORD bytes_to_send = 0;
-    DWORD bytes_left = 0;
-    DWORD bytes_sent = 0;
-    BOOL result = FALSE;
-
-    if ((txdata == NULL) || (pHid == NULL))
-    {
-        return ATCA_BAD_PARAM;
-    }
-
-    if (pHid->kits[hidid].write_handle == INVALID_HANDLE_VALUE)
-    {
-        return ATCA_COMM_FAIL;
-    }
-
-    bytes_left = txlength;
-
-    while (bytes_left > 0)
-    {
-        memset(buffer, 0, (HID_PACKET_MAX));
-
-        if (bytes_left >= cfg->atcahid.packetsize)
-        {
-            bytes_to_send = cfg->atcahid.packetsize;
-        }
-        else
-        {
-            bytes_to_send = bytes_left;
-        }
-
-        memcpy(&buffer[1], &txdata[(txlength - bytes_left)], bytes_to_send);
-
-        result = WriteFile(pHid->kits[hidid].write_handle, buffer, (cfg->atcahid.packetsize + 1), &bytes_sent, NULL);
-        if (result == FALSE)
-        {
-            return ATCA_TX_FAIL;
-        }
-
-        bytes_left -= bytes_to_send;
-    }
-    return status;
-}
-
-/** \brief HAL implementation of kit protocol receive data.It is called by the top layer.
- * \param[in]    iface   instance
- * \param[out]   rxdata  pointer to space to receive the data
- * \param[inout] rxsize  ptr to expected number of receive bytes to request
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-ATCA_STATUS kit_phy_receive(ATCAIface iface, char* rxdata, int* rxsize)
-{
-    ATCAIfaceCfg *cfg = atgetifacecfg(iface);
-    int hidid = cfg->atcahid.idx;
-    atcahid_t* pHid = (atcahid_t*)atgetifacehaldat(iface);
-    uint8_t buffer[HID_PACKET_MAX] = { 0 };
-    BOOL continue_read = TRUE;
-    DWORD bytes_read = 0;
-    DWORD total_bytes = 0;
-    BOOL result = true;
-    char* location = NULL;
-    int bytes_remain = 0;
-    int bytes_to_cpy = 0;
-    int size_adjust = 0;
-
-    // Verify the input variables
-    if ((rxdata == NULL) || (rxsize == NULL) || (pHid == NULL))
-    {
-        return ATCA_BAD_PARAM;
-    }
-
-    if (pHid->kits[hidid].read_handle == INVALID_HANDLE_VALUE)
-    {
-        return ATCA_COMM_FAIL;
-    }
-
-    while (continue_read == true)
-    {
-        result = ReadFile(pHid->kits[hidid].read_handle, buffer, (cfg->atcahid.packetsize + 1), &bytes_read, NULL);
-        if (result == false)
-        {
-            return ATCA_RX_FAIL;
-        }
-        // Find the location of the '\n' character in read buffer
-        // todo: generalize this read...  it only applies if there is an ascii protocol with an <eom> of \n and if the <eom> exists
-        location = strchr((char*)&buffer[1], '\n');
-        if (location == NULL)
-        {
-            // Copy all of the bytes
-            bytes_to_cpy = bytes_read;
-            // An extra byte is prepended to HID communication
-            size_adjust = 1;
-        }
-        else
-        {
-            // Copy only the bytes remaining in the read buffer to the <eom>
-            bytes_to_cpy = (uint8_t)(location - (char*)buffer);
-            size_adjust = 0;
-            // The response has been received, stop receiving more data
-            continue_read = false;
-        }
-        // Protect rxdata from overwriting, this will have the result of truncating the returned bytes
-        // Remaining space in rxdata
-        bytes_remain = (*rxsize - total_bytes);
-        // Use the minimum between number of bytes read and remaining space
-        bytes_to_cpy = min(bytes_remain, bytes_to_cpy);
-
-        // Copy the received data
-        memcpy(&rxdata[total_bytes], &buffer[1], bytes_to_cpy);
-        total_bytes += bytes_to_cpy - size_adjust;
-    }
-    *rxsize = total_bytes;
-    return ATCA_SUCCESS;
-}
-
-/** \brief Number of USB HID devices found
- *  \param[out] num_found
- *  \return SUCCESS
- */
-ATCA_STATUS kit_phy_num_found(int8_t* num_found)
-{
-    *num_found = _gHid.num_kits_found;
-    return ATCA_SUCCESS;
-}
-
-/** \brief HAL implementation of kit protocol send over USB HID
- *  \param[in] iface     instance
- *  \param[in] txdata    pointer to bytes to send
- *  \param[in] txlength  number of bytes to send
- *  \return ATCA_SUCCESS on success, otherwise an error code.
- */
-ATCA_STATUS hal_kit_hid_send(ATCAIface iface, uint8_t* txdata, int txlength)
-{
-    // Call the kit_send() function that will call phy_send() implemented below
-    return kit_send(iface, txdata, txlength);
-}
-
-/** \brief HAL implementation of send over USB HID
- * \param[in]    iface   instance
- * \param[in]    rxdata  pointer to space to receive the data
- * \param[inout] rxsize  ptr to expected number of receive bytes to request
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-ATCA_STATUS hal_kit_hid_receive(ATCAIface iface, uint8_t* rxdata, uint16_t* rxsize)
-{
-    // Call the kit_receive() function that will call phy_receive() implemented below
-    return kit_receive(iface, rxdata, rxsize);
-}
-
-/** \brief Call the wake for kit protocol over USB HID
- * \param[in] iface  ATCAIface instance that is the interface object to send the bytes over
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-ATCA_STATUS hal_kit_hid_wake(ATCAIface iface)
-{
-    // Call the kit_wake() function that will call phy_send() and phy_receive()
-    return kit_wake(iface);
-}
-
-/** \brief Call the idle for kit protocol over USB HID
- * \param[in] iface  ATCAIface instance that is the interface object to send the bytes over
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-ATCA_STATUS hal_kit_hid_idle(ATCAIface iface)
-{
-    // Call the kit_idle() function that will call phy_send() and phy_receive()
-    return kit_idle(iface);
-}
-
-/** \brief Call the sleep for kit protocol over USB HID
- * \param[in] iface  ATCAIface instance that is the interface object to send the bytes over
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-ATCA_STATUS hal_kit_hid_sleep(ATCAIface iface)
-{
-    // Call the kit_sleep() function that will call phy_send() and phy_receive()
-    return kit_sleep(iface);
-}
-
-/** \brief Close the physical port for HID
- * \param[in] hal_data  The hardware abstraction data specific to this HAL
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-ATCA_STATUS hal_kit_hid_release(void* hal_data)
-{
-    int i = 0;
-    atcahid_t* phaldat = (atcahid_t*)hal_data;
-
-    if ((hal_data == NULL))
-    {
-        return ATCA_BAD_PARAM;
-    }
-
-    // Close all kit USB devices
-    for (i = 0; i < phaldat->num_kits_found; i++)
-    {
-        if (phaldat->kits[i].read_handle != INVALID_HANDLE_VALUE)
-        {
-            CloseHandle(phaldat->kits[i].read_handle);
-            phaldat->kits[i].read_handle = INVALID_HANDLE_VALUE;
-        }
-
-        if (phaldat->kits[i].write_handle != INVALID_HANDLE_VALUE)
-        {
-            CloseHandle(phaldat->kits[i].write_handle);
-            phaldat->kits[i].write_handle = INVALID_HANDLE_VALUE;
-        }
-    }
-    return ATCA_SUCCESS;
-}
-
-/** @} */
diff --git a/lib/hal/hal_win_kit_hid.h b/lib/hal/hal_win_kit_hid.h
deleted file mode 100644
index e3523272d33a..000000000000
--- a/lib/hal/hal_win_kit_hid.h
+++ /dev/null
@@ -1,64 +0,0 @@
-/**
- * \file
- * \brief ATCA Hardware abstraction layer for Windows using kit protocol over a USB HID device.
- *
- * \copyright (c) 2017 Microchip Technology Inc. and its subsidiaries.
- *            You may use this software and any derivatives exclusively with
- *            Microchip products.
- *
- * \page License
- *
- * (c) 2017 Microchip Technology Inc. and its subsidiaries. You may use this
- * software and any derivatives exclusively with Microchip products.
- *
- * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
- * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
- * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
- * PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
- * WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
- *
- * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
- * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
- * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
- * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
- * FULLEST EXTENT ALLOWED BY LAW, MICROCHIPS TOTAL LIABILITY ON ALL CLAIMS IN
- * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
- * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
- *
- * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
- * TERMS.
- */
-
-#ifndef HAL_WIN_KIT_HID_H_
-#define HAL_WIN_KIT_HID_H_
-
-#include <Windows.h>
-
-/** \defgroup hal_ Hardware abstraction layer (hal_)
- *
- * \brief
- * These methods define the hardware abstraction layer for communicating with a CryptoAuth device
- *
-   @{ */
-
-// Kit USB defines
-#define HID_DEVICES_MAX     10      //! Maximum number of supported Kit USB devices
-#define HID_PACKET_MAX      512     //! Maximum number of bytes for a HID send/receive packet (typically 64)
-
-// Each device that is found will have a read handle and a write handle
-typedef struct hid_device
-{
-    HANDLE read_handle;         //! The kit USB read file handle
-    HANDLE write_handle;        //! The kit USB write file handle
-} hid_device_t;
-
-
-// A structure to hold HID information
-typedef struct atcahid
-{
-    hid_device_t kits[HID_DEVICES_MAX];
-    int8_t       num_kits_found;
-} atcahid_t;
-
-/** @} */
-#endif /* HAL_WIN_KIT_HID_H_ */
\ No newline at end of file
diff --git a/lib/hal/hal_win_timer.c b/lib/hal/hal_win_timer.c
deleted file mode 100644
index 71c431b4354b..000000000000
--- a/lib/hal/hal_win_timer.c
+++ /dev/null
@@ -1,86 +0,0 @@
-/**
- * \file
- * \brief ATCA Hardware abstraction layer for windows timer functions.
- *
- * \copyright (c) 2017 Microchip Technology Inc. and its subsidiaries.
- *            You may use this software and any derivatives exclusively with
- *            Microchip products.
- *
- * \page License
- *
- * (c) 2017 Microchip Technology Inc. and its subsidiaries. You may use this
- * software and any derivatives exclusively with Microchip products.
- *
- * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
- * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
- * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
- * PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
- * WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
- *
- * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
- * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
- * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
- * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
- * FULLEST EXTENT ALLOWED BY LAW, MICROCHIPS TOTAL LIABILITY ON ALL CLAIMS IN
- * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
- * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
- *
- * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
- * TERMS.
- */
-
-#include <windows.h>
-#include <math.h>
-#include "atca_hal.h"
-
-/** \defgroup hal_ Hardware abstraction layer (hal_)
- *
- * \brief
- * These methods define the hardware abstraction layer for communicating with a CryptoAuth device
- *
-   @{ */
-
-
-/** \brief This function delays for a number of microseconds.
- *
- * \param[in] delay number of microseconds to delay
- */
-void atca_delay_us(uint32_t delay)
-{
-    // divide by 1000 to convert us to ms
-    // todo: use a timer with us accuracy
-    long ms = (long)(delay / 1.0e3 + 0.5);    // Miliseconds
-
-    // use Windows supplied delay
-    Sleep(delay);
-}
-
-/** \brief This function delays for a number of tens of microseconds.
- *
- * \param[in] delay number of 0.01 milliseconds to delay
- */
-void atca_delay_10us(uint32_t delay)
-{
-    // divide by 100 to convert 10's of us to ms
-    // todo: use a timer with us accuracy
-    long ms = (long)(delay / 1.0e2 + 0.5);    // Miliseconds
-
-    // use Windows supplied delay
-    Sleep(delay);
-}
-
-/** \brief This function delays for a number of milliseconds.
- *
- *         You can override this function if you like to do
- *         something else in your system while delaying.
- * \param[in] delay number of milliseconds to delay
- */
-
-/* ASF already has delay_ms - see delay.h */
-void atca_delay_ms(uint32_t delay)
-{
-    // use Windows supplied delay
-    Sleep(delay);
-}
-
-/** @} */
diff --git a/lib/hal/hal_xmega_a3bu_i2c_asf.c b/lib/hal/hal_xmega_a3bu_i2c_asf.c
deleted file mode 100644
index 2d8fa71c9b21..000000000000
--- a/lib/hal/hal_xmega_a3bu_i2c_asf.c
+++ /dev/null
@@ -1,520 +0,0 @@
-/**
- * \file
- * \brief ATCA Hardware abstraction layer for XMEGA-A3BU I2C over ASF drivers.
- *
- * Prerequisite: add I2C Master Polled support to application in Atmel Studio
- *
- * \copyright (c) 2017 Microchip Technology Inc. and its subsidiaries.
- *            You may use this software and any derivatives exclusively with
- *            Microchip products.
- *
- * \page License
- *
- * (c) 2017 Microchip Technology Inc. and its subsidiaries. You may use this
- * software and any derivatives exclusively with Microchip products.
- *
- * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
- * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
- * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
- * PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
- * WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
- *
- * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
- * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
- * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
- * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
- * FULLEST EXTENT ALLOWED BY LAW, MICROCHIPS TOTAL LIABILITY ON ALL CLAIMS IN
- * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
- * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
- *
- * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
- * TERMS.
- */
-
-#include <asf.h>
-#include <string.h>
-#include <stdio.h>
-#include "atca_hal.h"
-#include "hal_xmega_a3bu_i2c_asf.h"
-#include "atca_device.h"
-
-/** \defgroup hal_ Hardware abstraction layer (hal_)
- *
- * \brief
- * These methods define the hardware abstraction layer for communicating with a CryptoAuth device
- * using I2C driver of ASF.
- *
-   @{ */
-
-/** \brief logical to physical bus mapping structure */
-ATCAI2CMaster_t *i2c_hal_data[MAX_I2C_BUSES];   // map logical, 0-based bus number to index
-int i2c_bus_ref_ct = 0;                         // total in-use count across buses
-static twi_master_options_t config_i2c_master;
-
-
-/** \brief discover i2c buses available for this hardware
- * this maintains a list of logical to physical bus mappings freeing the application
- * of the a-priori knowledge
- * \param[in] i2c_buses - an array of logical bus numbers
- * \param[in] max_buses - maximum number of buses the app wants to attempt to discover
- * \return ATCA_SUCCESS
- */
-
-ATCA_STATUS hal_i2c_discover_buses(int i2c_buses[], int max_buses)
-{
-
-    /* if every PORT was a likely candidate bus, then would need to initialize the entire array to all PORT n numbers.
-     * As an optimization and making discovery safer, make assumptions about bus-num / PORT map based on XMEGA-A3BU Xplained Pro board
-     * If you were using a raw XMEGA on your own board, you would supply your own bus numbers based on your particular hardware configuration.
-     */
-    i2c_buses[0] = 2;   // default xmega-a3bu for xplained dev board
-
-    return ATCA_SUCCESS;
-}
-
-/** \brief discover any CryptoAuth devices on a given logical bus number
- * \param[in] busNum - logical bus number on which to look for CryptoAuth devices
- * \param[out] cfg[] - pointer to head of an array of interface config structures which get filled in by this method
- * \param[out] *found - number of devices found on this bus
- * \return ATCA_SUCCESS
- */
-
-ATCA_STATUS hal_i2c_discover_devices(int busNum, ATCAIfaceCfg cfg[], int *found)
-{
-    ATCAIfaceCfg *head = cfg;
-    uint8_t slaveAddress = 0x01;
-    ATCADevice device;
-    ATCAIface discoverIface;
-    ATCACommand command;
-    ATCAPacket packet;
-    ATCA_STATUS status;
-    uint8_t revs508[1][4] = { { 0x00, 0x00, 0x50, 0x00 } };
-    uint8_t revs108[1][4] = { { 0x80, 0x00, 0x10, 0x01 } };
-    uint8_t revs204[3][4] = { { 0x00, 0x02, 0x00, 0x08 },
-                              { 0x00, 0x02, 0x00, 0x09 },
-                              { 0x00, 0x04, 0x05, 0x00 } };
-    int i;
-
-    /** \brief default configuration, to be reused during discovery process */
-    ATCAIfaceCfg discoverCfg = {
-        .iface_type             = ATCA_I2C_IFACE,
-        .devtype                = ATECC508A,
-        .atcai2c.slave_address  = 0x07,
-        .atcai2c.bus            = busNum,
-        .atcai2c.baud           = 400000,
-        //.atcai2c.baud = 100000,
-        .wake_delay             = 800,
-        .rx_retries             = 3
-    };
-
-    // build an info command
-    packet.param1 = INFO_MODE_REVISION;
-    packet.param2 = 0;
-
-    device = newATCADevice(&discoverCfg);
-    discoverIface = atGetIFace(device);
-    command = atGetCommands(device);
-
-    // iterate through all addresses on given i2c bus
-    // all valid 7-bit addresses go from 0x07 to 0x78
-    for (slaveAddress = 0x07; slaveAddress <= 0x78; slaveAddress++)
-    {
-        discoverCfg.atcai2c.slave_address = slaveAddress << 1;  // turn it into an 8-bit address which is what the rest of the i2c HAL is expecting when a packet is sent
-
-        // wake up device
-        // If it wakes, send it a dev rev command.  Based on that response, determine the device type
-        // BTW - this will wake every cryptoauth device living on the same bus (ecc508a, sha204a)
-
-        if (hal_i2c_wake(discoverIface) == ATCA_SUCCESS)
-        {
-            (*found)++;
-            memcpy( (uint8_t*)head, (uint8_t*)&discoverCfg, sizeof(ATCAIfaceCfg));
-
-            memset(packet.data, 0x00, sizeof(packet.data));
-
-            // get devrev info and set device type accordingly
-            atInfo(command, &packet);
-            if ((status = atGetExecTime(packet.opcode, command)) != ATCA_SUCCESS)
-            {
-                continue;
-            }
-
-            // send the command
-            if ( (status = atsend(discoverIface, (uint8_t*)&packet, packet.txsize)) != ATCA_SUCCESS)
-            {
-                printf("packet send error\r\n");
-                continue;
-            }
-
-            // delay the appropriate amount of time for command to execute
-            atca_delay_ms((command->execution_time_msec) + 1);
-
-            // receive the response
-            if ( (status = atreceive(discoverIface, &(packet.data[0]), &(packet.rxsize) )) != ATCA_SUCCESS)
-            {
-                continue;
-            }
-
-            if ( (status = isATCAError(packet.data)) != ATCA_SUCCESS)
-            {
-                printf("command response error\r\n");
-                continue;
-            }
-
-            // determine device type from common info and dev rev response byte strings
-            for (i = 0; i < sizeof(revs508) / 4; i++)
-            {
-                if (memcmp(&packet.data[1], &revs508[i], 4) == 0)
-                {
-                    discoverCfg.devtype = ATECC508A;
-                    break;
-                }
-            }
-
-            for (i = 0; i < sizeof(revs204) / 4; i++)
-            {
-                if (memcmp(&packet.data[1], &revs204[i], 4) == 0)
-                {
-                    discoverCfg.devtype = ATSHA204A;
-                    break;
-                }
-            }
-
-            for (i = 0; i < sizeof(revs108) / 4; i++)
-            {
-                if (memcmp(&packet.data[1], &revs108[i], 4) == 0)
-                {
-                    discoverCfg.devtype = ATECC108A;
-                    break;
-                }
-            }
-
-            atca_delay_ms(15);
-            // now the device type is known, so update the caller's cfg array element with it
-            head->devtype = discoverCfg.devtype;
-            head++;
-        }
-
-        hal_i2c_idle(discoverIface);
-    }
-
-    deleteATCADevice(&device);
-
-    return ATCA_SUCCESS;
-}
-
-
-/** \brief
-    - this HAL implementation assumes you've included the ASF I2C libraries in your project, otherwise,
-    the HAL layer will not compile because the ASF I2C drivers are a dependency *
- */
-
-/** \brief hal_i2c_init manages requests to initialize a physical interface.  it manages use counts so when an interface
- * has released the physical layer, it will disable the interface for some other use.
- * You can have multiple ATCAIFace instances using the same bus, and you can have multiple ATCAIFace instances on
- * multiple i2c buses, so hal_i2c_init manages these things and ATCAIFace is abstracted from the physical details.
- */
-
-/** \brief initialize an I2C interface using given config
- * \param[in] hal - opaque ptr to HAL data
- * \param[in] cfg - interface configuration
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-ATCA_STATUS hal_i2c_init(void *hal, ATCAIfaceCfg *cfg)
-{
-    int bus = cfg->atcai2c.bus;   // 0-based logical bus number
-    ATCAHAL_t *phal = (ATCAHAL_t*)hal;
-
-    if (i2c_bus_ref_ct == 0)       // power up state, no i2c buses will have been used
-    {
-        for (int i = 0; i < MAX_I2C_BUSES; i++)
-        {
-            i2c_hal_data[i] = NULL;
-        }
-    }
-
-    i2c_bus_ref_ct++;  // total across buses
-
-    if (bus >= 0 && bus < MAX_I2C_BUSES)
-    {
-        // if this is the first time this bus and interface has been created, do the physical work of enabling it
-        if (i2c_hal_data[bus] == NULL)
-        {
-            i2c_hal_data[bus] = malloc(sizeof(ATCAI2CMaster_t) );
-            i2c_hal_data[bus]->ref_ct = 1;  // buses are shared, this is the first instance
-
-            config_i2c_master.speed = cfg->atcai2c.baud;
-            config_i2c_master.chip  = 0x50;
-            config_i2c_master.speed_reg = TWI_BAUD(sysclk_get_cpu_hz(), cfg->atcai2c.baud);
-            switch (bus)
-            {
-            case 0: i2c_hal_data[bus]->i2c_master_instance = &TWIC; break;
-            //case 1: i2c_hal_data[bus]->i2c_master_instance = &TWID; break;	// for XMEGA-A1
-            case 2: i2c_hal_data[bus]->i2c_master_instance = &TWIE; break;
-                //case 3: i2c_hal_data[bus]->i2c_master_instance = &TWIF; break;	// for XMEGA-A1
-            }
-
-            twi_master_setup((i2c_hal_data[bus]->i2c_master_instance), &config_i2c_master);
-            // store this for use during the release phase
-            i2c_hal_data[bus]->bus_index = bus;
-            twi_master_enable(i2c_hal_data[bus]->i2c_master_instance);
-        }
-        else
-        {
-            // otherwise, another interface already initialized the bus, so this interface will share it and any different
-            // cfg parameters will be ignored...first one to initialize this sets the configuration
-            i2c_hal_data[bus]->ref_ct++;
-        }
-
-        phal->hal_data = i2c_hal_data[bus];
-
-        return ATCA_SUCCESS;
-    }
-
-    return ATCA_COMM_FAIL;
-}
-
-/** \brief HAL implementation of I2C post init
- * \param[in] iface  instance
- * \return ATCA_SUCCESS
- */
-ATCA_STATUS hal_i2c_post_init(ATCAIface iface)
-{
-    return ATCA_SUCCESS;
-}
-
-/** \brief HAL implementation of I2C send over ASF
- * \param[in] iface     instance
- * \param[in] txdata    pointer to space to bytes to send
- * \param[in] txlength  number of bytes to send
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-
-ATCA_STATUS hal_i2c_send(ATCAIface iface, uint8_t *txdata, int txlength)
-{
-    ATCAIfaceCfg *cfg = atgetifacecfg(iface);
-    int bus = cfg->atcai2c.bus;
-
-    twi_package_t packet = {
-        .addr_length    = 0,                                // TWI slave memory address data size
-        .chip           = cfg->atcai2c.slave_address >> 1,  // TWI slave bus address
-        .buffer         = txdata,                           // transfer data source buffer
-        .length         = txlength,                         // transfer data size (bytes)
-    };
-
-    // for this implementation of I2C with CryptoAuth chips, txdata is assumed to have ATCAPacket format
-
-    // other device types that don't require i/o tokens on the front end of a command need a different hal_i2c_send and wire it up instead of this one
-    // this covers devices such as ATSHA204A and ATECCx08A that require a word address value pre-pended to the packet
-    // txdata[0] is using _reserved byte of the ATCAPacket
-    txdata[0] = 0x03;   // insert the Word Address Value, Command token
-    txlength++;         // account for word address value byte.
-    packet.length = txlength;
-
-    if (twi_master_write(i2c_hal_data[bus]->i2c_master_instance, &packet) != STATUS_OK)
-    {
-        return ATCA_COMM_FAIL;
-    }
-
-    return ATCA_SUCCESS;
-}
-
-/** \brief HAL implementation of I2C receive function for ASF I2C
- * \param[in] iface     instance
- * \param[out] rxdata    pointer to space to receive the data
- * \param[in] rxlength  ptr to expected number of receive bytes to request
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-
-ATCA_STATUS hal_i2c_receive(ATCAIface iface, uint8_t *rxdata, uint16_t *rxlength)
-{
-    ATCAIfaceCfg *cfg = atgetifacecfg(iface);
-    int bus = cfg->atcai2c.bus;
-    int retries = cfg->rx_retries;
-    int status = !STATUS_OK;
-
-    twi_package_t packet = {
-        .addr_length    = 0,                                // TWI slave memory address data size
-        .chip           = cfg->atcai2c.slave_address >> 1,  // TWI slave bus address
-        .buffer         = rxdata,                           // transfer data source buffer
-        .length         = *rxlength,                        // transfer data size (bytes)
-    };
-
-    while (retries-- > 0 && status != STATUS_OK)
-    {
-        status = twi_master_read(i2c_hal_data[bus]->i2c_master_instance, &packet);
-    }
-
-    if (status != STATUS_OK)
-    {
-        return ATCA_COMM_FAIL;
-    }
-
-    return ATCA_SUCCESS;
-}
-
-/** \brief method to change the bus speec of I2C
- * \param[in] iface  interface on which to change bus speed
- * \param[in] speed  baud rate (typically 100000 or 400000)
- */
-
-void change_i2c_speed(ATCAIface iface, uint32_t speed)
-{
-    ATCAIfaceCfg *cfg = atgetifacecfg(iface);
-    int bus = cfg->atcai2c.bus;
-
-    config_i2c_master.speed = speed;
-    config_i2c_master.speed_reg = TWI_BAUD(sysclk_get_cpu_hz(), speed);
-
-    twi_master_disable(i2c_hal_data[bus]->i2c_master_instance);
-
-    switch (bus)
-    {
-    case 0: i2c_hal_data[bus]->i2c_master_instance = &TWIC; break;
-    case 2: i2c_hal_data[bus]->i2c_master_instance = &TWIE; break;
-    }
-
-    twi_master_setup((i2c_hal_data[bus]->i2c_master_instance), &config_i2c_master);
-
-    twi_master_enable(i2c_hal_data[bus]->i2c_master_instance);
-}
-
-/** \brief wake up CryptoAuth device using I2C bus
- * \param[in] iface  interface to logical device to wakeup
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-
-ATCA_STATUS hal_i2c_wake(ATCAIface iface)
-{
-    ATCAIfaceCfg *cfg = atgetifacecfg(iface);
-    int bus = cfg->atcai2c.bus;
-    int retries = cfg->rx_retries;
-    uint32_t bdrt = cfg->atcai2c.baud;
-    int status = !STATUS_OK;
-    uint8_t data[4], expected[4] = { 0x04, 0x11, 0x33, 0x43 };
-
-    if (bdrt != 100000)    // if not already at 100KHz, change it
-    {
-        change_i2c_speed(iface, 100000);
-    }
-
-    // Send the wake by writing to an address of 0x00
-    twi_package_t packet = {
-        .addr_length    = 0,        // TWI slave memory address data size
-        .chip           = 0x00,     // TWI slave bus address
-        .buffer         = &data[0], // transfer data source buffer
-        .length         = 0         // transfer data size (bytes)
-    };
-
-
-    // Send the 00 address as the wake pulse
-    twi_master_write(i2c_hal_data[bus]->i2c_master_instance, &packet);  // part will NACK, so don't check for status
-
-    atca_delay_us(cfg->wake_delay);                                     // wait tWHI + tWLO which is configured based on device type and configuration structure
-
-    packet.chip = cfg->atcai2c.slave_address >> 1;
-    packet.length = 4;
-    packet.buffer = data;
-
-    while (retries-- > 0 && status != STATUS_OK)
-    {
-        status = twi_master_read(i2c_hal_data[bus]->i2c_master_instance, &packet);
-    }
-
-    if (status != STATUS_OK)
-    {
-        return ATCA_COMM_FAIL;
-    }
-
-    // if necessary, revert baud rate to what came in.
-    if (bdrt != 100000)
-    {
-        change_i2c_speed(iface, bdrt);
-    }
-
-    if (memcmp(data, expected, 4) == 0)
-    {
-        return ATCA_SUCCESS;
-    }
-
-    return ATCA_COMM_FAIL;
-}
-
-/** \brief idle CryptoAuth device using I2C bus
- * \param[in] iface  interface to logical device to idle
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-
-ATCA_STATUS hal_i2c_idle(ATCAIface iface)
-{
-    ATCAIfaceCfg *cfg = atgetifacecfg(iface);
-    int bus = cfg->atcai2c.bus;
-    uint8_t data[4];
-
-    twi_package_t packet = {
-        .addr_length    = 0,                                // TWI slave memory address data size
-        .chip           = cfg->atcai2c.slave_address >> 1,  // TWI slave bus address
-        .buffer         = &data[0],                         // transfer data source buffer
-        .length         = 1                                 // transfer data size (bytes)
-    };
-
-    data[0] = 0x02;  // idle word address value
-    if (twi_master_write((i2c_hal_data[bus]->i2c_master_instance), &packet) != STATUS_OK)
-    {
-        return ATCA_COMM_FAIL;
-    }
-
-    return ATCA_SUCCESS;
-
-}
-
-/** \brief sleep CryptoAuth device using I2C bus
- * \param[in] iface  interface to logical device to sleep
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-
-ATCA_STATUS hal_i2c_sleep(ATCAIface iface)
-{
-    ATCAIfaceCfg *cfg = atgetifacecfg(iface);
-    int bus = cfg->atcai2c.bus;
-    uint8_t data[4];
-
-    twi_package_t packet = {
-        .addr_length    = 0,                                // TWI slave memory address data size
-        .chip           = cfg->atcai2c.slave_address >> 1,  // TWI slave bus address
-        .buffer         = &data[0],                         // transfer data source buffer
-        .length         = 1                                 // transfer data size (bytes)
-    };
-
-    data[0] = 0x01;  // sleep word address value
-    if (twi_master_write((i2c_hal_data[bus]->i2c_master_instance), &packet) != STATUS_OK)
-    {
-        return ATCA_COMM_FAIL;
-    }
-
-    return ATCA_SUCCESS;
-}
-
-/** \brief manages reference count on given bus and releases resource if no more refences exist
- * \param[in] hal_data - opaque pointer to hal data structure - known only to the HAL implementation
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-
-ATCA_STATUS hal_i2c_release(void *hal_data)
-{
-    ATCAI2CMaster_t *hal = (ATCAI2CMaster_t*)hal_data;
-
-    i2c_bus_ref_ct--;  // track total i2c bus interface instances for consistency checking and debugging
-
-    // if the use count for this bus has gone to 0 references, disable it.  protect against an unbracketed release
-    if (hal && --(hal->ref_ct) <= 0 && i2c_hal_data[hal->bus_index] != NULL)
-    {
-        twi_master_disable(hal->i2c_master_instance);
-        free(i2c_hal_data[hal->bus_index]);
-        i2c_hal_data[hal->bus_index] = NULL;
-    }
-
-    return ATCA_SUCCESS;
-}
-
-/** @} */
diff --git a/lib/hal/hal_xmega_a3bu_i2c_asf.h b/lib/hal/hal_xmega_a3bu_i2c_asf.h
deleted file mode 100644
index 4617c739245d..000000000000
--- a/lib/hal/hal_xmega_a3bu_i2c_asf.h
+++ /dev/null
@@ -1,64 +0,0 @@
-/**
- * \file
- * \brief ATCA Hardware abstraction layer for XMEGA-A3BU I2C over ASF drivers.
- *
- * Prerequisite: add I2C Master Polled support to application in Atmel Studio
- *
- * \copyright (c) 2017 Microchip Technology Inc. and its subsidiaries.
- *            You may use this software and any derivatives exclusively with
- *            Microchip products.
- *
- * \page License
- *
- * (c) 2017 Microchip Technology Inc. and its subsidiaries. You may use this
- * software and any derivatives exclusively with Microchip products.
- *
- * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
- * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
- * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
- * PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
- * WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
- *
- * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
- * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
- * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
- * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
- * FULLEST EXTENT ALLOWED BY LAW, MICROCHIPS TOTAL LIABILITY ON ALL CLAIMS IN
- * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
- * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
- *
- * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
- * TERMS.
- */
-
-#ifndef HAL_XMEGA_A3BU_I2C_ASF_H_
-#define HAL_XMEGA_A3BU_I2C_ASF_H_
-
-#include <asf.h>
-#include "twi_master.h"
-
-/** \defgroup hal_ Hardware abstraction layer (hal_)
- *
- * \brief
- * These methods define the hardware abstraction layer for communicating with a CryptoAuth device
- * using I2C driver of ASF.
- *
-   @{ */
-
-
-#define MAX_I2C_BUSES    4   // XMEGA A3BU has up to 4 PORT that can be configured as I2C
-
-/** \brief this is the hal_data for ATCA HAL created using ASF
- */
-typedef struct atcaI2Cmaster
-{
-    twi_master_t i2c_master_instance;
-    int          ref_ct;
-    // for conveniences during interface release phase
-    int bus_index;
-} ATCAI2CMaster_t;
-
-void change_i2c_speed(ATCAIface iface, uint32_t speed);
-
-/** @} */
-#endif /* HAL_XMEGA_A3BU_I2C_ASF_H_ */
\ No newline at end of file
diff --git a/lib/hal/hal_xmega_a3bu_timer_asf.c b/lib/hal/hal_xmega_a3bu_timer_asf.c
deleted file mode 100644
index e2f4a4337e03..000000000000
--- a/lib/hal/hal_xmega_a3bu_timer_asf.c
+++ /dev/null
@@ -1,78 +0,0 @@
-/**
- * \file
- * \brief ATCA Hardware abstraction layer for SAMD21 timer/delay over ASF drivers.
- *
- * \copyright (c) 2017 Microchip Technology Inc. and its subsidiaries.
- *            You may use this software and any derivatives exclusively with
- *            Microchip products.
- *
- * \page License
- *
- * (c) 2017 Microchip Technology Inc. and its subsidiaries. You may use this
- * software and any derivatives exclusively with Microchip products.
- *
- * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
- * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
- * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
- * PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
- * WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
- *
- * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
- * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
- * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
- * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
- * FULLEST EXTENT ALLOWED BY LAW, MICROCHIPS TOTAL LIABILITY ON ALL CLAIMS IN
- * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
- * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
- *
- * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
- * TERMS.
- */
-
-#include <asf.h>
-#include <delay.h>
-#include "atca_hal.h"
-
-/** \defgroup hal_ Hardware abstraction layer (hal_)
- *
- * \brief
- * These methods define the hardware abstraction layer for communicating with a CryptoAuth device
- *
-   @{ */
-
-/** \brief This function delays for a number of microseconds.
- *
- * \param[in] delay number of 0.001 milliseconds to delay
- */
-void atca_delay_us(uint32_t delay)
-{
-    // use ASF supplied delay
-    delay_us(delay);
-}
-
-/** \brief This function delays for a number of tens of microseconds.
- *
- * \param[in] delay number of 0.01 milliseconds to delay
- */
-void atca_delay_10us(uint32_t delay)
-{
-    // use ASF supplied delay
-    delay_us(delay * 10);
-
-}
-
-/** \brief This function delays for a number of milliseconds.
- *
- *         You can override this function if you like to do
- *         something else in your system while delaying.
- * \param[in] delay number of milliseconds to delay
- */
-
-/* ASF already has delay_ms - see delay.h */
-void atca_delay_ms(uint32_t delay)
-{
-    // use ASF supplied delay
-    delay_ms(delay);
-}
-
-/** @} */
diff --git a/lib/hal/i2c_bitbang_samd21.c b/lib/hal/i2c_bitbang_samd21.c
deleted file mode 100644
index 0cdac42912b9..000000000000
--- a/lib/hal/i2c_bitbang_samd21.c
+++ /dev/null
@@ -1,262 +0,0 @@
-/**
- * \file
- * \brief  Hardware Interface Functions - I2C bit-bang for SAMd21
- * \author Atmel Crypto Group
- * \date   November 18, 2015
- *
- * \copyright (c) 2017 Microchip Technology Inc. and its subsidiaries.
- *            You may use this software and any derivatives exclusively with
- *            Microchip products.
- *
- * \page License
- *
- * (c) 2017 Microchip Technology Inc. and its subsidiaries. You may use this
- * software and any derivatives exclusively with Microchip products.
- *
- * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
- * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
- * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
- * PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
- * WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
- *
- * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
- * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
- * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
- * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
- * FULLEST EXTENT ALLOWED BY LAW, MICROCHIPS TOTAL LIABILITY ON ALL CLAIMS IN
- * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
- * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
- *
- * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
- * TERMS.
- */
-
-#include <asf.h>
-#include <stdint.h>
-#include "i2c_bitbang_samd21.h"
-#define DEFAULT_I2C_BUS 2
-
-
-I2CBuses i2c_buses_default = {
-    { EXT3_PIN_3, EXT3_PIN_9,  EXT3_PIN_I2C_SDA,  EXT3_PIN_13,  EXT2_PIN_3,  EXT2_PIN_5,  EXT2_PIN_7,  EXT2_PIN_9,  EXT2_PIN_13,  EXT2_PIN_15,  EXT2_PIN_17,  EXT1_PIN_3,  EXT1_PIN_5,  EXT1_PIN_7, EXT1_PIN_9,  EXT1_PIN_13,  EXT1_PIN_15,  EXT1_PIN_17    },
-    { EXT3_PIN_7, EXT3_PIN_10, EXT3_PIN_I2C_SCL,  EXT3_PIN_14,  EXT2_PIN_4,  EXT2_PIN_6,  EXT2_PIN_8,  EXT2_PIN_10, EXT2_PIN_14,  EXT2_PIN_16,  EXT2_PIN_18,  EXT1_PIN_4,  EXT1_PIN_6,  EXT1_PIN_8, EXT1_PIN_10, EXT1_PIN_14,  EXT1_PIN_16,  EXT1_PIN_18    }
-};
-
-uint8_t pin_sda, pin_scl;
-
-void i2c_discover_buses(int i2c_bitbang_buses[], int max_buses)
-{
-
-    i2c_bitbang_buses[0] = DEFAULT_I2C_BUS;
-
-}
-
-void i2c_set_pin(uint8_t sda, uint8_t scl)
-{
-    pin_sda = sda;
-    pin_scl = scl;
-}
-
-void i2c_enable(void)
-{
-    I2C_ENABLE();
-    I2C_DATA_HIGH();
-    I2C_CLOCK_HIGH();
-}
-
-void i2c_disable(void)
-{
-    I2C_DISABLE();
-}
-
-
-void i2c_send_start(void)
-{
-    //! Set clock high in case we re-start.
-    I2C_CLOCK_HIGH();
-    I2C_SET_OUTPUT_HIGH();
-    I2C_DATA_LOW();
-    I2C_HOLD_DELAY();
-    I2C_CLOCK_LOW();
-}
-
-void i2c_send_ack(uint8_t ack)
-{
-    if (ack)
-    {
-        I2C_SET_OUTPUT_LOW();   //!< Low data line indicates an ACK.
-        while (I2C_DATA_IN())
-        {
-            ;
-        }
-    }
-    else
-    {
-        I2C_SET_OUTPUT_HIGH();  //!< High data line indicates a NACK.
-        while (!I2C_DATA_IN())
-        {
-            ;
-        }
-    }
-
-    //! Clock out acknowledgment.
-    I2C_CLOCK_HIGH();
-    I2C_CLOCK_DELAY_SEND_ACK();
-    I2C_CLOCK_LOW();
-}
-
-void i2c_send_stop(void)
-{
-    I2C_SET_OUTPUT_LOW();
-    I2C_CLOCK_DELAY_WRITE_LOW();
-    I2C_CLOCK_HIGH();
-    I2C_HOLD_DELAY();
-    I2C_DATA_HIGH();
-}
-
-
-void i2c_send_wake_token(void)
-{
-    I2C_DATA_LOW();
-    delay_us(80);
-    I2C_DATA_HIGH();
-}
-
-ATCA_STATUS i2c_send_byte(uint8_t i2c_byte)
-{
-    ATCA_STATUS status = ATCA_TX_TIMEOUT;
-
-    uint8_t i;
-
-    DISABLE_INTERRUPT();
-
-    //! This avoids spikes but adds an if condition.
-    //! We could parametrize the call to I2C_SET_OUTPUT
-    //! and translate the msb to OUTSET or OUTCLR,
-    //! but then the code would become target specific.
-    if (i2c_byte & 0x80)
-    {
-        I2C_SET_OUTPUT_HIGH();
-    }
-    else
-    {
-        I2C_SET_OUTPUT_LOW();
-    }
-
-    //! Send 8 bits of data.
-    for (i = 0; i < 8; i++)
-    {
-        I2C_CLOCK_LOW();
-        if (i2c_byte & 0x80)
-        {
-            I2C_DATA_HIGH();
-        }
-        else
-        {
-            I2C_DATA_LOW();
-        }
-        I2C_CLOCK_DELAY_WRITE_LOW();
-
-        //! Clock out the data bit.
-        I2C_CLOCK_HIGH();
-
-        //! Shifting while clock is high compensates for the time it
-        //! takes to evaluate the bit while clock is low.
-        //! That way, the low and high time of the clock pin is
-        //! almost equal.
-        i2c_byte <<= 1;
-        I2C_CLOCK_DELAY_WRITE_HIGH();
-    }
-    //! Clock in last data bit.
-    I2C_CLOCK_LOW();
-
-    //! Set data line to be an input.
-    I2C_SET_INPUT();
-
-    I2C_CLOCK_DELAY_READ_LOW();
-    //! Wait for the ack.
-    I2C_CLOCK_HIGH();
-    for (i = 0; i < I2C_ACK_TIMEOUT; i++)
-    {
-        if (!I2C_DATA_IN())
-        {
-            status = ATCA_SUCCESS;
-            I2C_CLOCK_DELAY_READ_HIGH();
-            break;
-        }
-    }
-    I2C_CLOCK_LOW();
-
-    ENABLE_INTERRUPT();
-
-    return status;
-}
-
-ATCA_STATUS i2c_send_bytes(uint8_t count, uint8_t *data)
-{
-    ATCA_STATUS status = ATCA_TX_TIMEOUT;
-
-    uint8_t i;
-
-    for (i = 0; i < count; i++)
-    {
-        status = i2c_send_byte(data[i]);
-        if (status != ATCA_SUCCESS)
-        {
-            if (i > 0)
-            {
-                status = ATCA_TX_FAIL;
-            }
-            break;
-        }
-    }
-
-    return status;
-}
-
-uint8_t i2c_receive_one_byte(uint8_t ack)
-{
-    uint8_t i2c_byte;
-    uint8_t i;
-
-    DISABLE_INTERRUPT();
-
-    I2C_SET_INPUT();
-    for (i = 0x80, i2c_byte = 0; i; i >>= 1)
-    {
-        I2C_CLOCK_HIGH();
-        I2C_CLOCK_DELAY_READ_HIGH();
-        if (I2C_DATA_IN())
-        {
-            i2c_byte |= i;
-        }
-        I2C_CLOCK_LOW();
-        if (i > 1)
-        {
-            //! We don't need to delay after the last bit because
-            //! it takes time to switch the pin to output for acknowledging.
-            I2C_CLOCK_DELAY_READ_LOW();
-        }
-    }
-    i2c_send_ack(ack);
-
-    ENABLE_INTERRUPT();
-
-    return i2c_byte;
-}
-
-void i2c_receive_byte(uint8_t *data)
-{
-    *data = i2c_receive_one_byte(1);
-}
-
-void i2c_receive_bytes(uint8_t count, uint8_t *data)
-{
-    while (--count)
-    {
-        *data++ = i2c_receive_one_byte(1);
-    }
-    *data = i2c_receive_one_byte(0);
-
-    i2c_send_stop();
-}
\ No newline at end of file
diff --git a/lib/hal/i2c_bitbang_samd21.h b/lib/hal/i2c_bitbang_samd21.h
deleted file mode 100644
index 00fc7977e305..000000000000
--- a/lib/hal/i2c_bitbang_samd21.h
+++ /dev/null
@@ -1,195 +0,0 @@
-/**
- * \file
- * \brief  definitions for bit-banged I2C
- *
- * \copyright (c) 2017 Microchip Technology Inc. and its subsidiaries.
- *            You may use this software and any derivatives exclusively with
- *            Microchip products.
- *
- * \page License
- *
- * (c) 2017 Microchip Technology Inc. and its subsidiaries. You may use this
- * software and any derivatives exclusively with Microchip products.
- *
- * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
- * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
- * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
- * PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
- * WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
- *
- * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
- * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
- * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
- * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
- * FULLEST EXTENT ALLOWED BY LAW, MICROCHIPS TOTAL LIABILITY ON ALL CLAIMS IN
- * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
- * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
- *
- * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
- * TERMS.
- */
-
-#ifndef I2C_BITBANG_SAMD21_H_
-#define I2C_BITBANG_SAMD21_H_
-
-#include "atca_status.h"
-#include <delay.h>
-
-
-#define MAX_I2C_BUSES   18       //The MAX_I2C_BUSES is the number of free pins in samd21 xplained pro
-
-
-typedef struct
-{
-    uint8_t pin_sda[MAX_I2C_BUSES];
-    uint8_t pin_scl[MAX_I2C_BUSES];
-} I2CBuses;
-
-extern I2CBuses i2c_buses_default;
-
-extern uint8_t pin_sda;
-extern uint8_t pin_scl;
-
-#   define I2C_ENABLE()         {  struct port_config pin_conf; \
-                                   port_get_config_defaults(&pin_conf); \
-                                   pin_conf.direction  = PORT_PIN_DIR_OUTPUT_WTH_READBACK; \
-                                   port_pin_set_config(pin_sda, &pin_conf); \
-                                   pin_conf.direction  = PORT_PIN_DIR_OUTPUT; \
-                                   port_pin_set_config(pin_scl, &pin_conf); }
-#   define I2C_DISABLE()         {  struct port_config pin_conf; \
-                                    port_get_config_defaults(&pin_conf); \
-                                    pin_conf.direction  = PORT_PIN_DIR_INPUT; \
-                                    pin_conf.input_pull = PORT_PIN_PULL_UP; \
-                                    port_pin_set_config(pin_sda, &pin_conf); \
-                                    port_pin_set_config(pin_scl, &pin_conf); }
-#   define I2C_CLOCK_LOW()       port_pin_set_output_level(pin_scl, false)
-#   define I2C_CLOCK_HIGH()      port_pin_set_output_level(pin_scl, true)
-#   define I2C_DATA_LOW()        port_pin_set_output_level(pin_sda, false)
-#   define I2C_DATA_HIGH()       port_pin_set_output_level(pin_sda, true)
-#   define I2C_DATA_IN()         port_pin_get_input_level(pin_sda)
-#   define I2C_SET_OUTPUT()      {  struct port_config pin_conf; \
-                                    port_get_config_defaults(&pin_conf); \
-                                    pin_conf.direction  = PORT_PIN_DIR_OUTPUT_WTH_READBACK; \
-                                    port_pin_set_config(pin_sda, &pin_conf); }
-#   define I2C_SET_OUTPUT_HIGH() { I2C_SET_OUTPUT(); I2C_DATA_HIGH(); }
-#   define I2C_SET_OUTPUT_LOW()  { I2C_SET_OUTPUT(); I2C_DATA_LOW(); }
-#   define I2C_SET_INPUT()       {  struct port_config pin_conf; \
-                                    port_get_config_defaults(&pin_conf); \
-                                    pin_conf.direction  = PORT_PIN_DIR_INPUT; \
-                                    port_pin_set_config(pin_sda, &pin_conf); }
-#   define DISABLE_INTERRUPT()   cpu_irq_disable()
-#   define ENABLE_INTERRUPT()    cpu_irq_enable()
-
-
-#define I2C_CLOCK_DELAY_WRITE_LOW()  delay_us(1)
-#define I2C_CLOCK_DELAY_WRITE_HIGH() delay_us(1)
-#define I2C_CLOCK_DELAY_READ_LOW()   delay_us(1)
-#define I2C_CLOCK_DELAY_READ_HIGH()  delay_us(1)
-#define I2C_CLOCK_DELAY_SEND_ACK()   delay_us(1)
-//! This delay is inserted to make the Start and Stop hold time at least 250 ns.
-#define I2C_HOLD_DELAY()    delay_us(1)
-
-
-
-
-//! loop count when waiting for an acknowledgment
-#define I2C_ACK_TIMEOUT                 (4)
-
-
-/**
- * \brief Set I2C data and clock pin.
- *        Other functions will use these pins.
- *
- * \param[in] sda  definition of GPIO pin to be used as data pin
- * \param[in] scl  definition of GPIO pin to be used as clock pin
- */
-void i2c_set_pin(uint8_t sda, uint8_t scl);
-
-
-/**
- * \brief  Assigns the logical bus number for discovering the devices
- *
- *
- * \param[in]  i2c_bitbang_buses         The logical bus numbers are assigned to the variables.
- * \param[in]  max_buses                 Maximum number of bus used for discovering.
- */
-
-void i2c_discover_buses(int i2c_bitbang_buses[], int max_buses);
-
-/**
- * \brief Configure GPIO pins for I2C clock and data as output.
- */
-void i2c_enable(void);
-
-/**
- * \brief Configure GPIO pins for I2C clock and data as input.
- */
-void i2c_disable(void);
-
-
-/**
- * \brief Send a START condition.
- */
-void i2c_send_start(void);
-
-/**
- * \brief Send an ACK or NACK (after receive).
- *
- * \param[in] ack  0: NACK, else: ACK
- */
-void i2c_send_ack(uint8_t ack);
-
-/**
- * \brief Send a STOP condition.
- */
-void i2c_send_stop(void);
-
-/**
- * \brief Send a Wake Token.
- */
-void i2c_send_wake_token(void);
-
-/**
- * \brief Send one byte.
- *
- * \param[in] i2c_byte  byte to write
- *
- * \return ATCA_STATUS
- */
-ATCA_STATUS i2c_send_byte(uint8_t i2c_byte);
-
-/**
- * \brief Send a number of bytes.
- *
- * \param[in] count  number of bytes to send
- * \param[in] data   pointer to buffer containing bytes to send
- *
- * \return ATCA_STATUS
- */
-ATCA_STATUS i2c_send_bytes(uint8_t count, uint8_t *data);
-
-/**
- * \brief Receive one byte (MSB first).
- *
- * \param[in] ack  0:NACK, else:ACK
- *
- * \return Number of bytes received
- */
-uint8_t i2c_receive_one_byte(uint8_t ack);
-
-/**
- * \brief Receive one byte and send ACK.
- *
- * \param[out] data  pointer to received byte
- */
-void i2c_receive_byte(uint8_t *data);
-
-/**
- * \brief Receive a number of bytes.
- *
- * \param[out] data   pointer to receive buffer
- * \param[in]  count  number of bytes to receive
- */
-void i2c_receive_bytes(uint8_t count, uint8_t *data);
-
-#endif /* I2C_BITBANG_SAMD21_H_ */
\ No newline at end of file
diff --git a/lib/hal/kit_phy.h b/lib/hal/kit_phy.h
deleted file mode 100644
index f0b6ecd35f90..000000000000
--- a/lib/hal/kit_phy.h
+++ /dev/null
@@ -1,62 +0,0 @@
-/**
- * \file
- * \brief  ATCA Hardware abstraction layer physical send & receive function definitions.
- *
- * This is included for kit protocol implementations.
- * It is included in the kit protocol callback to actually send and recieve bytes.
- *
- * \copyright (c) 2017 Microchip Technology Inc. and its subsidiaries.
- *            You may use this software and any derivatives exclusively with
- *            Microchip products.
- *
- * \page License
- *
- * (c) 2017 Microchip Technology Inc. and its subsidiaries. You may use this
- * software and any derivatives exclusively with Microchip products.
- *
- * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
- * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
- * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
- * PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
- * WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
- *
- * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
- * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
- * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
- * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
- * FULLEST EXTENT ALLOWED BY LAW, MICROCHIPS TOTAL LIABILITY ON ALL CLAIMS IN
- * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
- * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
- *
- * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
- * TERMS.
- */
-
-#ifndef KIT_PHY_H_
-#define KIT_PHY_H_
-
-#include "cryptoauthlib.h"
-
-
-/** \defgroup hal_ Hardware abstraction layer (hal_)
- *
- * \brief
- * These methods define the hardware abstraction layer for communicating with a CryptoAuth device
- *
-   @{ */
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-ATCA_STATUS kit_phy_num_found(int8_t* num_found);
-ATCA_STATUS kit_phy_send(ATCAIface iface, const char *txdata, int txlength);
-ATCA_STATUS kit_phy_receive(ATCAIface iface, char* rxdata, int* rxlength);
-
-#ifdef __cplusplus
-}
-#endif
-
-/** @} */
-
-#endif /* ATCA_HAL_PHY_H_ */
diff --git a/lib/hal/kit_protocol.c b/lib/hal/kit_protocol.c
deleted file mode 100644
index 55f8708d1d94..000000000000
--- a/lib/hal/kit_protocol.c
+++ /dev/null
@@ -1,430 +0,0 @@
-/**
- * \file
- *
- * \brief  Microchip Crypto Auth hardware interface object
- *
- * \copyright (c) 2017 Microchip Technology Inc. and its subsidiaries.
- *            You may use this software and any derivatives exclusively with
- *            Microchip products.
- *
- * \page License
- *
- * (c) 2017 Microchip Technology Inc. and its subsidiaries. You may use this
- * software and any derivatives exclusively with Microchip products.
- *
- * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
- * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
- * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
- * PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
- * WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
- *
- * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
- * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
- * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
- * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
- * FULLEST EXTENT ALLOWED BY LAW, MICROCHIPS TOTAL LIABILITY ON ALL CLAIMS IN
- * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
- * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
- *
- * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
- * TERMS.
- */
-
-#include <stdlib.h>
-#include <stdio.h>
-#include "kit_phy.h"
-#include "kit_protocol.h"
-#include "basic/atca_helpers.h"
-
-/** \defgroup hal_ Hardware abstraction layer (hal_)
- *
- * \brief
- * These methods define the hardware abstraction layer for communicating with a CryptoAuth device
- *
-   @{ */
-
-
-
-/** \brief HAL implementation of kit protocol init.  This function calls back to the physical protocol to send the bytes
- *  \param[in] iface  instance
- *  \return ATCA_SUCCESS on success, otherwise an error code.
- */
-ATCA_STATUS kit_init(ATCAIface iface)
-{
-    ATCA_STATUS status = ATCA_SUCCESS;
-    uint8_t kitstatus = 0;
-    char address[] = "board:device(00)\n";
-    int addresssize = sizeof(address);
-    char reply[KIT_RX_WRAP_SIZE + 4];
-    int replysize = sizeof(reply);
-    uint8_t rxdata[2];
-    int rxsize = sizeof(rxdata);
-    char selectaddress[KIT_MSG_SIZE];
-    int selectaddresssize = sizeof(selectaddress);
-    char selectaddresspre[] = "s:physical:select(";
-    char selectaddresspost[] = ")\n";
-    int copysize = 0;
-
-    // Send the address bytes
-    status = kit_phy_send(iface, address, addresssize);
-
-    // Receive the reply to address "...(C0)\n"
-    memset(reply, 0, replysize);
-    status = kit_phy_receive(iface, reply, &replysize);
-    if (status != ATCA_SUCCESS)
-    {
-        return ATCA_GEN_FAIL;
-    }
-
-    if (replysize == 4)
-    {
-        // Probably an error
-        status = kit_parse_rsp(reply, replysize, &kitstatus, rxdata, &rxsize);
-        if (status != ATCA_SUCCESS)
-        {
-            return status;
-        }
-        if (kitstatus != 0)
-        {
-            return ATCA_NO_DEVICES;
-        }
-    }
-    rxsize = 2;
-    memcpy(rxdata, strchr(reply, '(') + 1, rxsize);
-
-    // Send the select address bytes
-    memset(selectaddress, 0, selectaddresssize);
-    copysize = sizeof(selectaddresspre);
-    memcpy(&selectaddress[0], selectaddresspre, copysize);
-    memcpy(&selectaddress[(copysize - 1)], rxdata, rxsize);
-    copysize = (sizeof(selectaddresspre) + rxsize);
-    memcpy(&selectaddress[(copysize - 1)], selectaddresspost, sizeof(selectaddresspost));
-    copysize = (sizeof(selectaddresspre) + rxsize + sizeof(selectaddresspost));
-    status = kit_phy_send(iface, selectaddress, copysize);
-
-    // Receive the reply to select address "00()\n"
-    memset(reply, 0, replysize);
-    status = kit_phy_receive(iface, reply, &replysize);
-    if (status != ATCA_SUCCESS)
-    {
-        return ATCA_GEN_FAIL;
-    }
-
-    return status;
-}
-
-/** \brief HAL implementation of kit protocol send.  This function calls back to the physical protocol to send the bytes
- *  \param[in] iface     instance
- *  \param[in] txdata    pointer to bytes to send
- *  \param[in] txlength  number of bytes to send
- *  \return ATCA_SUCCESS on success, otherwise an error code.
- */
-ATCA_STATUS kit_send(ATCAIface iface, const uint8_t* txdata, int txlength)
-{
-    ATCA_STATUS status = ATCA_SUCCESS;
-    int nkitbuf = txlength * 2 + KIT_TX_WRAP_SIZE;
-    char* pkitbuf = NULL;
-
-    // Check the pointers
-    if ((txdata == NULL))
-    {
-        return ATCA_BAD_PARAM;
-    }
-    // Wrap in kit protocol
-    pkitbuf = malloc(nkitbuf);
-    memset(pkitbuf, 0, nkitbuf);
-    status = kit_wrap_cmd(&txdata[1], txlength, pkitbuf, &nkitbuf);
-    if (status != ATCA_SUCCESS)
-    {
-        free(pkitbuf);
-        return ATCA_GEN_FAIL;
-    }
-    // Send the bytes
-    status = kit_phy_send(iface, pkitbuf, nkitbuf);
-
-#ifdef KIT_DEBUG
-    // Print the bytes
-    printf("\nKit Write: %s", pkitbuf);
-#endif
-
-    // Free the bytes
-    free(pkitbuf);
-
-    return status;
-}
-
-/** \brief HAL implementation to receive bytes and unwrap from kit protocol.  This function calls back to the physical protocol to receive the bytes
- * \param[in]    iface   instance
- * \param[in]    rxdata  pointer to space to receive the data
- * \param[inout] rxsize  ptr to expected number of receive bytes to request
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-ATCA_STATUS kit_receive(ATCAIface iface, uint8_t* rxdata, uint16_t* rxsize)
-{
-    ATCA_STATUS status = ATCA_SUCCESS;
-    uint8_t kitstatus = 0;
-    int nkitbuf = 0;
-    int dataSize = 0;
-    char* pkitbuf = NULL;
-
-    // Check the pointers
-    if ((rxdata == NULL) || (rxsize == NULL))
-    {
-        return ATCA_BAD_PARAM;
-    }
-
-    // Adjust the read buffer size
-    dataSize = *rxsize;
-    nkitbuf = dataSize * 2 + KIT_RX_WRAP_SIZE;
-    pkitbuf = malloc(nkitbuf);
-    memset(pkitbuf, 0, nkitbuf);
-
-    // Receive the bytes
-    status = kit_phy_receive(iface, pkitbuf, &nkitbuf);
-    if (status != ATCA_SUCCESS)
-    {
-        free(pkitbuf);
-        return ATCA_GEN_FAIL;
-    }
-
-#ifdef KIT_DEBUG
-    // Print the bytes
-    printf("Kit Read: %s\r", pkitbuf);
-#endif
-
-    // Unwrap from kit protocol
-    memset(rxdata, 0, *rxsize);
-    status = kit_parse_rsp(pkitbuf, nkitbuf, &kitstatus, rxdata, &dataSize);
-    *rxsize = dataSize;
-
-    // Free the bytes
-    free(pkitbuf);
-
-    return status;
-}
-
-/** \brief Call the wake for kit protocol
- * \param[in] iface  the interface object to send the bytes over
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-ATCA_STATUS kit_wake(ATCAIface iface)
-{
-    ATCA_STATUS status = ATCA_SUCCESS;
-    uint8_t kitstatus = 0;
-    char wake[] = "s:w()\n";
-    int wakesize = sizeof(wake);
-    char reply[KIT_RX_WRAP_SIZE + 4];
-    int replysize = sizeof(reply);
-    uint8_t rxdata[10];
-    int rxsize = sizeof(rxdata);
-
-    // Send the bytes
-    status = kit_phy_send(iface, wake, wakesize);
-
-#ifdef KIT_DEBUG
-    // Print the bytes
-    printf("\nKit Write: %s", wake);
-#endif
-
-    // Receive the reply to wake "00(04...)\n"
-    memset(reply, 0, replysize);
-    status = kit_phy_receive(iface, reply, &replysize);
-    if (status != ATCA_SUCCESS)
-    {
-        return ATCA_GEN_FAIL;
-    }
-
-#ifdef KIT_DEBUG
-    // Print the bytes
-    printf("Kit Read: %s\n", reply);
-#endif
-
-    // Unwrap from kit protocol
-    memset(rxdata, 0, rxsize);
-    status = kit_parse_rsp(reply, replysize, &kitstatus, rxdata, &rxsize);
-
-    return status;
-}
-
-/** \brief Call the idle for kit protocol
- * \param[in] iface  the interface object to send the bytes over
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-ATCA_STATUS kit_idle(ATCAIface iface)
-{
-    ATCA_STATUS status = ATCA_SUCCESS;
-    uint8_t kitstatus = 0;
-    char idle[] = "s:i()\n";
-    int idlesize = sizeof(idle);
-    char reply[KIT_RX_WRAP_SIZE];
-    int replysize = sizeof(reply);
-    uint8_t rxdata[10];
-    int rxsize = sizeof(rxdata);
-
-    // Send the bytes
-    status = kit_phy_send(iface, idle, idlesize);
-
-#ifdef KIT_DEBUG
-    // Print the bytes
-    printf("\nKit Write: %s", idle);
-#endif
-
-    // Receive the reply to sleep "00()\n"
-    memset(reply, 0, replysize);
-    status = kit_phy_receive(iface, reply, &replysize);
-    if (status != ATCA_SUCCESS)
-    {
-        return ATCA_GEN_FAIL;
-    }
-
-#ifdef KIT_DEBUG
-    // Print the bytes
-    printf("Kit Read: %s\r", reply);
-#endif
-
-    // Unwrap from kit protocol
-    memset(rxdata, 0, rxsize);
-    status = kit_parse_rsp(reply, replysize, &kitstatus, rxdata, &rxsize);
-
-    return status;
-}
-
-/** \brief Call the sleep for kit protocol
- * \param[in] iface  the interface object to send the bytes over
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-ATCA_STATUS kit_sleep(ATCAIface iface)
-{
-    ATCA_STATUS status = ATCA_SUCCESS;
-    uint8_t kitstatus = 0;
-
-    char sleep[] = "s:s()\n";
-    int sleepsize = sizeof(sleep);
-    char reply[KIT_RX_WRAP_SIZE];
-    int replysize = sizeof(reply);
-    uint8_t rxdata[10];
-    int rxsize = sizeof(rxdata);
-
-    // Send the bytes
-    status = kit_phy_send(iface, sleep, sleepsize);
-
-#ifdef KIT_DEBUG
-    // Print the bytes
-    printf("\nKit Write: %s", sleep);
-#endif
-
-    // Receive the reply to sleep "00()\n"
-    memset(reply, 0, replysize);
-    status = kit_phy_receive(iface, reply, &replysize);
-    if (status != ATCA_SUCCESS)
-    {
-        return ATCA_GEN_FAIL;
-    }
-
-#ifdef KIT_DEBUG
-    // Print the bytes
-    printf("Kit Read: %s\r", reply);
-#endif
-
-    // Unwrap from kit protocol
-    memset(rxdata, 0, rxsize);
-    status = kit_parse_rsp(reply, replysize, &kitstatus, rxdata, &rxsize);
-
-    return status;
-}
-
-/** \brief Wrap binary bytes in ascii kit protocol
- * \param[in] txdata pointer to the binary data to wrap
- * \param[in] txlen length of the binary data to wrap
- * \param[out] pkitcmd pointer to binary data converted to ascii kit protocol
- * \param[inout] nkitcmd pointer to the size of the binary data converted to ascii kit protocol
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-ATCA_STATUS kit_wrap_cmd(const uint8_t* txdata, int txlen, char* pkitcmd, int* nkitcmd)
-{
-    ATCA_STATUS status = ATCA_SUCCESS;
-    char cmdpre[] = "s:t(";     // sha:talk(
-    char cmdpost[] = ")\n";
-//	char* pkitcmd = NULL;
-    int cmdAsciiLen = txlen * 2;
-    int cmdlen = txlen * 2 + sizeof(cmdpre) + sizeof(cmdpost) + 1;
-    int cpylen = 0;
-    int cpyindex = 0;
-
-    // Check the variables
-    if (txdata == NULL || pkitcmd == NULL || nkitcmd == NULL)
-    {
-        return ATCA_BAD_PARAM;
-    }
-    if (*nkitcmd > cmdlen)
-    {
-        return ATCA_BAD_PARAM;
-    }
-
-    // Wrap in kit protocol
-    memset(pkitcmd, 0, *nkitcmd);
-
-    // Copy the prefix
-    cpylen = (int)strlen(cmdpre);
-    memcpy(&pkitcmd[cpyindex], cmdpre, cpylen);
-    cpyindex += cpylen;
-
-    // Copy the ascii binary bytes
-    status = atcab_bin2hex_(txdata, txlen, &pkitcmd[cpyindex], &cmdAsciiLen, false);
-    if (status != ATCA_SUCCESS)
-    {
-        return status;
-    }
-    cpyindex += cmdAsciiLen;
-
-    // Copy the postfix
-    cpylen = (int)strlen(cmdpost);
-    memcpy(&pkitcmd[cpyindex], cmdpost, cpylen);
-    cpyindex += cpylen;
-
-    *nkitcmd = cpyindex;
-
-    return status;
-}
-
-/** \brief Parse the response ascii from the kit
- * \param[out] pkitbuf pointer to ascii kit protocol data to parse
- * \param[in] nkitbuf length of the ascii kit protocol data
- * \param[in] kitstatus status of the ascii device
- * \param[in] rxdata pointer to the binary data buffer
- * \param[in] datasize size of the pointer to the binary data buffer
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-ATCA_STATUS kit_parse_rsp(const char* pkitbuf, int nkitbuf, uint8_t* kitstatus, uint8_t* rxdata, int* datasize)
-{
-    ATCA_STATUS status = ATCA_SUCCESS;
-    int statusId = 0;
-    int dataId = 3;
-    int binSize = 1;
-    int asciiDataSize = 0;
-    char* endDataPtr = 0;
-
-    // First get the kit status
-    status = atcab_hex2bin(&pkitbuf[statusId], 2, kitstatus, &binSize);
-    if (status != ATCA_SUCCESS)
-    {
-        return status;
-    }
-
-    // Next get the binary data bytes
-    endDataPtr = strchr((char*)pkitbuf, ')');
-    if (endDataPtr < (&pkitbuf[dataId]))
-    {
-        return ATCA_GEN_FAIL;
-    }
-    asciiDataSize = (int)(endDataPtr - (&pkitbuf[dataId]));
-    status = atcab_hex2bin(&pkitbuf[dataId], asciiDataSize, rxdata, datasize);
-    if (status != ATCA_SUCCESS)
-    {
-        return status;
-    }
-
-    return ATCA_SUCCESS;
-}
-
-/** @} */
diff --git a/lib/hal/kit_protocol.h b/lib/hal/kit_protocol.h
deleted file mode 100644
index 84f7fee454cb..000000000000
--- a/lib/hal/kit_protocol.h
+++ /dev/null
@@ -1,77 +0,0 @@
-/**
- * \file
- *
- * \brief  Atmel Crypto Auth hardware interface object
- *
- * \copyright (c) 2017 Microchip Technology Inc. and its subsidiaries.
- *            You may use this software and any derivatives exclusively with
- *            Microchip products.
- *
- * \page License
- *
- * (c) 2017 Microchip Technology Inc. and its subsidiaries. You may use this
- * software and any derivatives exclusively with Microchip products.
- *
- * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
- * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
- * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
- * PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
- * WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
- *
- * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
- * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
- * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
- * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
- * FULLEST EXTENT ALLOWED BY LAW, MICROCHIPS TOTAL LIABILITY ON ALL CLAIMS IN
- * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
- * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
- *
- * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
- * TERMS.
- */
-
-#ifndef KIT_PROTOCOL_H_
-#define KIT_PROTOCOL_H_
-
-#include "cryptoauthlib.h"
-
-// Define this for debugging communication
-//#define KIT_DEBUG
-
-/** \defgroup hal_ Hardware abstraction layer (hal_)
- *
- * \brief
- * These methods define the hardware abstraction layer for communicating with a CryptoAuth device
- *
-   @{ */
-
-// The number of bytes to wrap a command in kit protocol.  sizeof("s:t()\n<null>")
-#define KIT_TX_WRAP_SIZE    (7)
-
-// The number of bytes to wrap a response in kit protocol.  sizeof("<KIT_MSG_SIZE>00()\n<null>")
-#define KIT_MSG_SIZE        (32)
-#define KIT_RX_WRAP_SIZE    (KIT_MSG_SIZE + 6)
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-ATCA_STATUS kit_init(ATCAIface iface);
-
-ATCA_STATUS kit_send(ATCAIface iface, const uint8_t* txdata, int txlength);
-ATCA_STATUS kit_receive(ATCAIface iface, uint8_t* rxdata, uint16_t* rxsize);
-
-ATCA_STATUS kit_wrap_cmd(const uint8_t* txdata, int txlength, char* pkitbuf, int* nkitbuf);
-ATCA_STATUS kit_parse_rsp(const char* pkitbuf, int nkitbuf, uint8_t* kitstatus, uint8_t* rxdata, int* nrxdata);
-
-ATCA_STATUS kit_wake(ATCAIface iface);
-ATCA_STATUS kit_idle(ATCAIface iface);
-ATCA_STATUS kit_sleep(ATCAIface iface);
-
-#ifdef __cplusplus
-}
-#endif
-
-/** @} */
-
-#endif // KIT_PROTOCOL_H
diff --git a/lib/hal/swi_bitbang_samd21.c b/lib/hal/swi_bitbang_samd21.c
deleted file mode 100644
index 3c540109cb4c..000000000000
--- a/lib/hal/swi_bitbang_samd21.c
+++ /dev/null
@@ -1,272 +0,0 @@
-/**
- * \file
- * \brief  Hardware Interface Functions - SWI bit-banged
- *
- * \copyright (c) 2017 Microchip Technology Inc. and its subsidiaries.
- *            You may use this software and any derivatives exclusively with
- *            Microchip products.
- *
- * \page License
- *
- * (c) 2017 Microchip Technology Inc. and its subsidiaries. You may use this
- * software and any derivatives exclusively with Microchip products.
- *
- * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
- * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
- * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
- * PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
- * WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
- *
- * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
- * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
- * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
- * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
- * FULLEST EXTENT ALLOWED BY LAW, MICROCHIPS TOTAL LIABILITY ON ALL CLAIMS IN
- * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
- * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
- *
- * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
- * TERMS.
- */
-
-#include <asf.h>
-#include <stdint.h>
-#include "swi_bitbang_samd21.h"
-
-
-
-
-
-SWIBuses swi_buses_default = {
-    { EXT3_PIN_3, EXT3_PIN_9, EXT3_PIN_I2C_SDA, EXT3_PIN_13, EXT2_PIN_3, EXT2_PIN_5, EXT2_PIN_7, EXT2_PIN_9, EXT2_PIN_13, EXT2_PIN_15, EXT2_PIN_17, EXT1_PIN_3, EXT1_PIN_5, EXT1_PIN_7, EXT1_PIN_9, EXT1_PIN_13, EXT1_PIN_15, EXT1_PIN_17, EXT3_PIN_7, EXT3_PIN_10, EXT3_PIN_I2C_SCL, EXT3_PIN_14, EXT2_PIN_4, EXT2_PIN_6, EXT2_PIN_8, EXT2_PIN_10, EXT2_PIN_14, EXT2_PIN_16, EXT2_PIN_18, EXT1_PIN_4, EXT1_PIN_6, EXT1_PIN_8, EXT1_PIN_10, EXT1_PIN_14, EXT1_PIN_16, EXT1_PIN_18 }
-
-};
-
-
-//! declaration of the variable indicating which pin the selected device is connected to
-static uint8_t device_pin;
-
-
-void swi_set_pin(uint8_t id)
-{
-    device_pin = id;
-}
-
-
-
-void swi_enable(void)
-{
-    struct port_config pin_conf;
-
-    port_get_config_defaults(&pin_conf);
-    pin_conf.direction  = PORT_PIN_DIR_OUTPUT;
-    port_pin_set_config(device_pin, &pin_conf);
-}
-
-void swi_disable(void)
-{
-    struct port_config pin_conf;
-
-    port_get_config_defaults(&pin_conf);
-    port_pin_set_config(device_pin, &pin_conf);
-}
-
-
-void swi_set_signal_pin(uint8_t is_high)
-{
-    if (is_high)
-    {
-        port_pin_set_output_level(device_pin, true);
-    }
-    else
-    {
-        port_pin_set_output_level(device_pin, false);
-    }
-}
-
-void swi_send_wake_token(void)
-{
-    swi_set_signal_pin(0);
-    delay_us(60);
-    swi_set_signal_pin(1);
-}
-
-void swi_send_bytes(uint8_t count, uint8_t *buffer)
-{
-    uint8_t i, bit_mask;
-    struct port_config pin_conf;
-
-    port_get_config_defaults(&pin_conf);
-    pin_conf.direction  = PORT_PIN_DIR_OUTPUT;
-    port_pin_set_config(device_pin, &pin_conf);
-
-    //! Wait turn around time.
-    RX_TX_DELAY;
-    cpu_irq_disable();
-
-
-    for (i = 0; i < count; i++)
-    {
-        for (bit_mask = 1; bit_mask > 0; bit_mask <<= 1)
-        {
-            if (bit_mask & buffer[i])   //!< Send Logic 1 (7F)
-            {
-                port_pin_set_output_level(device_pin, false);
-                BIT_DELAY_1L;
-                port_pin_set_output_level(device_pin, true);
-                BIT_DELAY_7;
-            }
-            else     //!< Send Logic 0 (7D)
-            {
-                port_pin_set_output_level(device_pin, false);
-                BIT_DELAY_1L;
-                port_pin_set_output_level(device_pin, true);
-                BIT_DELAY_1H;
-                port_pin_set_output_level(device_pin, false);
-                BIT_DELAY_1L;
-                port_pin_set_output_level(device_pin, true);
-                BIT_DELAY_5;
-            }
-        }
-    }
-    cpu_irq_enable();
-
-
-
-}
-
-
-void swi_send_byte(uint8_t byte)
-{
-    swi_send_bytes(1, &byte);
-
-}
-
-
-
-
-ATCA_STATUS swi_receive_bytes(uint8_t count, uint8_t *buffer)
-{
-    ATCA_STATUS status = ATCA_SUCCESS;
-
-    uint8_t i;
-    uint8_t bit_mask;
-    uint8_t pulse_count;
-    uint16_t timeout_count;
-    struct port_config pin_conf;
-
-
-    port_get_config_defaults(&pin_conf);
-    port_pin_set_config(device_pin, &pin_conf);
-
-
-    cpu_irq_disable();
-    //! Receive bits and store in buffer.
-    for (i = 0; i < count; i++)
-    {
-        buffer[i] = 0;
-        for (bit_mask = 1; bit_mask > 0; bit_mask <<= 1)
-        {
-            pulse_count = 0;
-
-
-            timeout_count = START_PULSE_TIME_OUT;
-            //! Detect start bit.
-
-            while (--timeout_count > 0)
-            {
-                //! Wait for falling edge.
-                if (port_pin_get_input_level(device_pin) == 0)
-                {
-
-                    break;
-                }
-            }
-            if (timeout_count == 0)
-            {
-                status = ATCA_RX_TIMEOUT;
-                break;
-            }
-
-            timeout_count = START_PULSE_TIME_OUT;
-
-            do
-            {
-                //! Wait for rising edge.
-                if (port_pin_get_input_level(device_pin) != 0)
-                {
-                    pulse_count = 1;
-
-                    break;
-                }
-            }
-            while (--timeout_count > 0);
-
-            if (pulse_count == 0)
-            {
-                status = ATCA_RX_TIMEOUT;
-                break;
-            }
-
-            //!  let's just wait the maximum time for the falling edge of a zero bit
-            //! to arrive after we have detected the rising edge of the start bit.
-            timeout_count = ZERO_PULSE_TIME_OUT;
-
-            //! Detect possible edge indicating zero bit.
-            do
-            {
-                if (port_pin_get_input_level(device_pin) == 0)
-                {
-                    pulse_count = 2;
-                    break;
-                }
-            }
-            while (--timeout_count > 0);
-
-
-            //! Wait for rising edge of zero pulse before returning. Otherwise we might interpret
-            //! its rising edge as the next start pulse.
-            if (pulse_count == 2)
-            {
-                timeout_count = ZERO_PULSE_TIME_OUT;
-
-                do
-                {
-                    if (port_pin_get_input_level(device_pin) != 0)
-                    {
-                        break;
-                    }
-                }
-
-                while (timeout_count-- > 0);
-
-            }
-            //! Update byte at current buffer index.
-            else
-            //! received "one" bit
-            {
-                buffer[i] |= bit_mask;
-            }
-        }
-
-
-        if (status != ATCA_SUCCESS)
-        {
-            break;
-        }
-    }
-
-    if (status == ATCA_RX_TIMEOUT)
-    {
-        if (i > 0)
-        {
-            //! Indicate that we timed out after having received at least one byte.
-            status = ATCA_RX_FAIL;
-        }
-    }
-
-    cpu_irq_enable();
-
-
-    return status;
-}
\ No newline at end of file
diff --git a/lib/hal/swi_bitbang_samd21.h b/lib/hal/swi_bitbang_samd21.h
deleted file mode 100644
index b6d20f6153ba..000000000000
--- a/lib/hal/swi_bitbang_samd21.h
+++ /dev/null
@@ -1,148 +0,0 @@
-/**
- * \file
- * \brief Hardware Interface Functions - SWI bit-banged
- *
- * \copyright (c) 2017 Microchip Technology Inc. and its subsidiaries.
- *            You may use this software and any derivatives exclusively with
- *            Microchip products.
- *
- * \page License
- *
- * (c) 2017 Microchip Technology Inc. and its subsidiaries. You may use this
- * software and any derivatives exclusively with Microchip products.
- *
- * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
- * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
- * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
- * PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
- * WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
- *
- * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
- * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
- * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
- * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
- * FULLEST EXTENT ALLOWED BY LAW, MICROCHIPS TOTAL LIABILITY ON ALL CLAIMS IN
- * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
- * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
- *
- * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
- * TERMS.
- */
-
-#ifndef SWI_BITBANG_SAMD21_H_
-#define SWI_BITBANG_SAMD21_H_
-
-#include "atca_status.h"
-#include <delay.h>
-
-
-#define MAX_SWI_BUSES   36      //!< SAMD21 xplainned pro has 36 free GPIO pins available
-
-
-typedef struct
-{
-    uint32_t pin_sda[MAX_SWI_BUSES];
-} SWIBuses;
-
-extern SWIBuses swi_buses_default;
-
-
-/**
- * \name Macros for Bit-Banged SWI Timing
- *
- * Times to drive bits at 230.4 kbps.
-   @{ */
-
-//! delay macro for width of one pulse (start pulse or zero pulse)
-//! should be 4.34 us, is 4.05 us
-
-#define BIT_DELAY_1L        delay_us(3)
-//! should be 4.34 us, is 4.05us
-#define BIT_DELAY_1H        delay_us(3)
-
-//! time to keep pin high for five pulses plus stop bit (used to bit-bang CryptoAuth 'zero' bit)
-//! should be 26.04 us, is 26.92 us
-#define BIT_DELAY_5        delay_us(26)    // considering pin set delay
-
-//! time to keep pin high for seven bits plus stop bit (used to bit-bang CryptoAuth 'one' bit)
-//! should be 34.72 us, is 35.13 us
-#define BIT_DELAY_7        delay_us(34)    // considering pin set delay
-
-//! turn around time when switching from receive to transmit
-//! should be 15 us, is 15.58 us
-#define RX_TX_DELAY         delay_us(15)
-
-
-//! Lets set the timeout value for start pulse detection to the uint8_t maximum.
-//! This value is decremented while waiting for the falling edge of a start pulse.
-#define START_PULSE_TIME_OUT    (600)
-
-//! Maximum time between rising edge of start pulse
-//! and falling edge of zero pulse is 8.6 us. Therefore, a value of 40 (around 15 us)
-//! gives ample time to detect a zero pulse and also leaves enough time to detect
-//! the following start pulse.
-//! This value is decremented while waiting for the falling edge of a zero pulse.
-#define ZERO_PULSE_TIME_OUT     (40)
-
-/** @} */
-
-
-/**
- * \brief Set SWI signal pin.
- *        Other functions will use this pin.
- *
- * \param[in] id  definition of GPIO pin to be used
- */
-void swi_set_pin(uint8_t id);
-
-
-
-/**
- * \brief Configure GPIO pin for SWI signal as output.
- */
-void swi_enable(void);
-
-/**
- * \brief Configure GPIO pin for SWI signal as input.
- */
-void swi_disable(void);
-
-/**
- * \brief Set signal pin Low or High.
- *
- * \param[in] is_high  0: Low, else: High.
- */
-void swi_set_signal_pin(uint8_t is_high);
-
-/**
- * \brief Send a Wake Token.
- */
-void swi_send_wake_token(void);
-
-/**
- * \brief Send a number of bytes.This function should not be called directly ,instead should use hal_swi_send() which call this function.
- *
- * \param[in] count   number of bytes to send.
- * \param[in] buffer  pointer to buffer containing bytes to send
- */
-void swi_send_bytes(uint8_t count, uint8_t *buffer);
-
-/**
- * \brief Send one byte.
- *
- * \param[in] byte  byte to send
- */
-void swi_send_byte(uint8_t byte);
-
-/**
- * \brief Receive a number of bytes.This function should not be called directly ,instead should use hal_swi_receive() which call this function.
- *
- * \param[in]  count   number of bytes to receive
- * \param[out] buffer  pointer to receive buffer
- *
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-ATCA_STATUS swi_receive_bytes(uint8_t count, uint8_t *buffer);
-
-
-#endif /* SWI_BITBANG_SAMD21_H_ */
\ No newline at end of file
diff --git a/lib/hal/swi_uart_at90usb1287_asf.c b/lib/hal/swi_uart_at90usb1287_asf.c
deleted file mode 100644
index 68efbf61eec5..000000000000
--- a/lib/hal/swi_uart_at90usb1287_asf.c
+++ /dev/null
@@ -1,260 +0,0 @@
-/**
- * \file
- * \brief ATXMEGA's ATCA Hardware abstraction layer for SWI interface over AT90USB1287 UART drivers.
- *
- * Prerequisite: add UART Polled support to application in Atmel Studio
- *
- * \copyright (c) 2017 Microchip Technology Inc. and its subsidiaries.
- *            You may use this software and any derivatives exclusively with
- *            Microchip products.
- *
- * \page License
- *
- * (c) 2017 Microchip Technology Inc. and its subsidiaries. You may use this
- * software and any derivatives exclusively with Microchip products.
- *
- * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
- * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
- * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
- * PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
- * WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
- *
- * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
- * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
- * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
- * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
- * FULLEST EXTENT ALLOWED BY LAW, MICROCHIPS TOTAL LIABILITY ON ALL CLAIMS IN
- * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
- * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
- *
- * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
- * TERMS.
- */
-
-#include <stdlib.h>
-#include <stdio.h>
-#include "usart_serial.h"
-#include "swi_uart_at90usb1287_asf.h"
-#include "basic/atca_helpers.h"
-
-/*#define DEBUG_PIN*/
-
-#ifdef DEBUG_PIN
-    #define DEBUG_PIN_1 IOPORT_CREATE_PIN(PORTB, 0)
-    #define DEBUG_PIN_2 IOPORT_CREATE_PIN(PORTB, 1)
-#endif
-
-/** \defgroup hal_ Hardware abstraction layer (hal_)
- *
- * \brief
- * These methods define the hardware abstraction layer for communicating with a CryptoAuth device
- *
-   @{ */
-
-/** \brief usart configuration struct */
-static usart_serial_options_t config_usart;
-/** \brief sysclk_get_per_hz value  */
-static uint32_t u32sysclk;
-
-/** \brief
-    - this HAL implementation assumes you've included the ASF SERCOM UART libraries in your project, otherwise,
-    the HAL layer will not compile because the ASF UART drivers are a dependency *
- */
-
-/** \brief Implementation of SWI UART init.
- * \param[in] instance  instance
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-ATCA_STATUS swi_uart_init(ATCASWIMaster_t *instance)
-{
-#ifdef DEBUG_PIN
-    ioport_init();
-    ioport_set_pin_dir(DEBUG_PIN_1, IOPORT_DIR_OUTPUT);
-    ioport_set_pin_dir(DEBUG_PIN_2, IOPORT_DIR_OUTPUT);
-    gpio_set_pin_high(DEBUG_PIN_1);
-    gpio_set_pin_high(DEBUG_PIN_2);
-#endif
-    ATCA_STATUS status = ATCA_SUCCESS;
-
-    //Save sysclk_get_per_hz value
-    u32sysclk = sysclk_get_source_clock_hz();
-    // Set data size to 7
-    config_usart.charlength = USART_CHSIZE_7BIT_gc;
-    // Set parity to no parity
-    config_usart.paritytype = USART_PMODE_DISABLED_gc;
-    // Set data byte to one stopbit
-    config_usart.stopbits = false;
-    // Set baudrate to 230400
-    config_usart.baudrate = 230400;
-
-    switch (instance->bus_index)
-    {
-    case 0: instance->usart_instance = &USARTA1; break; // AT90USB1287 has only 1 UART channel which maps to ATMEGARF's UART 1
-    }
-    status = usart_serial_init(instance->usart_instance, &config_usart);
-    return status;
-}
-
-/** \brief Implementation of SWI UART deinit.
- * \param[in] instance  instance
- * \return ATCA_SUCCESS
- */
-ATCA_STATUS swi_uart_deinit(ATCASWIMaster_t *instance)
-{
-    ATCA_STATUS status = ATCA_SUCCESS;
-
-    instance->usart_instance = NULL;
-    return status;
-}
-
-/** \brief implementation of SWI UART change baudrate.
- * \param[in] instance  instance
- * \param[in] baudrate  (typically 230400 , 160000 or 115200)
- */
-void swi_uart_setbaud(ATCASWIMaster_t *instance, uint32_t baudrate)
-{
-    /*usart_double_baud_enable(instance->usart_instance);*/
-    // Set baudrate for UART module
-    usart_set_baudrate(instance->usart_instance, baudrate, u32sysclk);
-}
-
-
-/** \brief implementation of SWI UART change mode.
- * \param[in] instance  instance
- * \param[in] mode      (TRANSMIT_MODE or RECEIVE_MODE)
- */
-void swi_uart_mode(ATCASWIMaster_t *instance, uint8_t mode)
-{
-    switch (mode)
-    {
-    case TRANSMIT_MODE:
-        swi_uart_setbaud(instance, 230400);
-        break;
-    case RECEIVE_MODE:
-        //Reset UART RX buffer.
-        usart_rx_disable(instance->usart_instance);
-        usart_rx_enable(instance->usart_instance);
-        break;
-    default:
-        break;
-    }
-
-}
-
-/** \brief discover UART buses available for this hardware
- * this maintains a list of logical to physical bus mappings freeing the application
- * of the a-priori knowledge
- * \param[in] swi_uart_buses - an array of logical bus numbers
- * \param[in] max_buses - maximum number of buses the app wants to attempt to discover
- */
-void swi_uart_discover_buses(int swi_uart_buses[], int max_buses)
-{
-    /* if every PORT was a likely candidate bus, then would need to initialize the entire array to all PORT n numbers.
-     * As an optimization and making discovery safer, make assumptions about bus-num / PORT map based on AT90USB1287
-     * If you were using a raw XMEGA on your own board, you would supply your own bus numbers based on your particular hardware configuration.
-     */
-    swi_uart_buses[0] = 0;   // AT90USB1287 supports single UART channel
-}
-
-/** \brief HAL implementation of SWI UART send byte over ASF.  This function send one byte over UART
- * \param[in] instance  instance
- * \param[in] data      byte to send
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-ATCA_STATUS swi_uart_send_byte(ATCASWIMaster_t *instance, uint8_t data)
-{
-    int8_t timeout = 0x7F;
-    bool data_reg_empty = false;
-    ATCA_STATUS status = ATCA_EXECUTION_ERROR /*ATCA_CMD_FAIL*/;
-
-    // Send one byte over UART module
-#ifdef DEBUG_PIN
-    gpio_toggle_pin(DEBUG_PIN_1);
-#endif
-
-    // Send one byte over UART module
-    timeout = 0x7F;
-
-    while ((timeout > 0) && (data_reg_empty == false))
-    {
-        data_reg_empty = usart_data_register_is_empty(instance->usart_instance);
-        timeout--;
-    }
-
-    if (data_reg_empty)
-    {
-        usart_serial_putchar(instance->usart_instance, data);
-        while (!usart_tx_is_complete(instance->usart_instance))
-        {
-            ;
-        }
-        usart_clear_tx_complete(instance->usart_instance);
-        status = ATCA_SUCCESS;
-    }
-
-#ifdef DEBUG_PIN
-    gpio_toggle_pin(DEBUG_PIN_1);
-#endif
-    if (timeout > 0)
-    {
-        return status;
-    }
-    else
-    {
-        return ATCA_TIMEOUT;
-    }
-}
-
-/** \brief HAL implementation of SWI UART receive bytes over ASF.  This function receive one byte over UART
- * \param[in]    instance  instance
- * \param[inout] data      pointer to space to receive the data
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-ATCA_STATUS swi_uart_receive_byte(ATCASWIMaster_t *instance, uint8_t *data)
-{
-    int8_t timeout, retries = 0x2; // This retry is used to compensate the baudrate that do not match when receiving response
-
-    *data = 0xFF;
-    bool rx_complete = false;
-    ATCA_STATUS status = ATCA_EXECUTION_ERROR /*ATCA_CMD_FAIL*/;
-#ifdef DEBUG_PIN
-    gpio_toggle_pin(DEBUG_PIN_2);
-#endif
-    // Receive one byte over UART module
-    while ((retries > 0) && (status != ATCA_SUCCESS))
-    {
-        timeout = 0x7F; retries--;
-        while ((timeout > 0) && (rx_complete == false))
-        {
-            rx_complete = usart_rx_is_complete(instance->usart_instance);
-            timeout--;
-        }
-
-        if (rx_complete)
-        {
-            usart_serial_getchar(instance->usart_instance, data);
-            //if ((*data == 0x7D) || (*data == 0x7F))
-            if ((*data >= 0x70) && (*data <= 0x7F))
-            {
-                status = ATCA_SUCCESS;
-            }
-            else
-            {
-                status = ATCA_EXECUTION_ERROR /*ATCA_CMD_FAIL*/;
-            }
-        }
-    }
-#ifdef DEBUG_PIN
-    gpio_toggle_pin(DEBUG_PIN_2);
-#endif
-    if (timeout > 0)
-    {
-        return status;
-    }
-    else
-    {
-        return ATCA_TIMEOUT;
-    }
-}
-
-/** @} */
diff --git a/lib/hal/swi_uart_at90usb1287_asf.h b/lib/hal/swi_uart_at90usb1287_asf.h
deleted file mode 100644
index 2b11b2467937..000000000000
--- a/lib/hal/swi_uart_at90usb1287_asf.h
+++ /dev/null
@@ -1,83 +0,0 @@
-/**
- * \file
- * \brief ATMEGA's ATCA Hardware abstraction layer for SWI interface over AT90USB1287 UART drivers.
- *
- * Prerequisite: add UART Polled support to application in Atmel Studio
- *
- * \copyright (c) 2017 Microchip Technology Inc. and its subsidiaries.
- *            You may use this software and any derivatives exclusively with
- *            Microchip products.
- *
- * \page License
- *
- * (c) 2017 Microchip Technology Inc. and its subsidiaries. You may use this
- * software and any derivatives exclusively with Microchip products.
- *
- * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
- * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
- * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
- * PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
- * WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
- *
- * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
- * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
- * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
- * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
- * FULLEST EXTENT ALLOWED BY LAW, MICROCHIPS TOTAL LIABILITY ON ALL CLAIMS IN
- * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
- * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
- *
- * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
- * TERMS.
- */
-
-#ifndef SWI_UART_AT90USB1287_ASF_H
-#define SWI_UART_AT90USB1287_ASF_H
-
-#include <asf.h>
-#include "cryptoauthlib.h"
-#include "serial.h"
-
-/** \defgroup hal_ Hardware abstraction layer (hal_)
- *
- * \brief
- * These methods define the hardware abstraction layer for communicating with a CryptoAuth device
- *
-   @{ */
-
-
-/** \brief
-    - this HAL implementation assumes you've included the ASF UART libraries in your project, otherwise,
-    the HAL layer will not compile because the ASF UART drivers are a dependency *
- */
-
-#define MAX_SWI_BUSES    1  // AT90USB1287 has only 1 port
-
-#define RECEIVE_MODE     0  // UART Receive mode, RX enabled
-#define TRANSMIT_MODE    1  // UART Transmit mode, RX disabled
-#define RX_DELAY        10  // Delay before responses come
-#define TX_DELAY        90  // Delay before new flag is sent
-
-/** \brief this is the hal_data for ATCA HAL for SWI UART
- */
-typedef struct atcaSWImaster
-{
-    // struct usart_module for Atmel SWI interface
-    usart_if usart_instance;
-    // for conveniences during interface release phase
-    int bus_index;
-} ATCASWIMaster_t;
-
-
-ATCA_STATUS swi_uart_init(ATCASWIMaster_t *instance);
-ATCA_STATUS swi_uart_deinit(ATCASWIMaster_t *instance);
-void swi_uart_setbaud(ATCASWIMaster_t *instance, uint32_t baudrate);
-void swi_uart_mode(ATCASWIMaster_t *instance, uint8_t mode);
-void swi_uart_discover_buses(int swi_uart_buses[], int max_buses);
-
-ATCA_STATUS swi_uart_send_byte(ATCASWIMaster_t *instance, uint8_t data);
-ATCA_STATUS swi_uart_receive_byte(ATCASWIMaster_t *instance, uint8_t *data);
-
-/** @} */
-
-#endif // SWI_UART_AT90USB1287_ASF_H
diff --git a/lib/hal/swi_uart_samd21_asf.c b/lib/hal/swi_uart_samd21_asf.c
deleted file mode 100644
index 1a5b698381e0..000000000000
--- a/lib/hal/swi_uart_samd21_asf.c
+++ /dev/null
@@ -1,238 +0,0 @@
-/**
- * \file
- * \brief ATXMEGA's ATCA Hardware abstraction layer for SWI interface over UART drivers.
- *
- * Prerequisite: add UART Polled support to application in Atmel Studio
- *
- * \copyright (c) 2017 Microchip Technology Inc. and its subsidiaries.
- *            You may use this software and any derivatives exclusively with
- *            Microchip products.
- *
- * \page License
- *
- * (c) 2017 Microchip Technology Inc. and its subsidiaries. You may use this
- * software and any derivatives exclusively with Microchip products.
- *
- * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
- * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
- * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
- * PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
- * WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
- *
- * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
- * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
- * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
- * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
- * FULLEST EXTENT ALLOWED BY LAW, MICROCHIPS TOTAL LIABILITY ON ALL CLAIMS IN
- * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
- * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
- *
- * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
- * TERMS.
- */
-
-#include <stdlib.h>
-#include <stdio.h>
-#include "swi_uart_samd21_asf.h"
-#include "basic/atca_helpers.h"
-
-/** \defgroup hal_ Hardware abstraction layer (hal_)
- *
- * \brief
- * These methods define the hardware abstraction layer for communicating with a CryptoAuth device
- *
-   @{ */
-
-/** \brief usart configuration struct */
-static struct usart_config config_usart;
-struct port_config pin_conf; //for DEBUG purpose
-
-
-/** \brief
-    - this HAL implementation assumes you've included the ASF SERCOM UART libraries in your project, otherwise,
-    the HAL layer will not compile because the ASF UART drivers are a dependency *
- */
-
-/** \brief Implementation of SWI UART init.
- * \param[in] instance  instance
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-ATCA_STATUS swi_uart_init(ATCASWIMaster_t *instance)
-{
-#ifdef DEBUG_PIN
-    port_get_config_defaults(&pin_conf);
-    pin_conf.direction  = PORT_PIN_DIR_OUTPUT;
-    port_pin_set_config(DEBUG_PIN_1, &pin_conf);
-    port_pin_set_config(DEBUG_PIN_2, &pin_conf);
-    port_pin_set_output_level(DEBUG_PIN_1, HIGH);
-    port_pin_set_output_level(DEBUG_PIN_2, HIGH);
-#endif
-
-    ATCA_STATUS status = ATCA_SUCCESS;
-    usart_get_config_defaults(&config_usart);
-    // Set data size to 7
-    config_usart.character_size = USART_CHARACTER_SIZE_7BIT;
-    // Set parity to no parity
-    config_usart.parity = USART_PARITY_NONE;
-    // Set data byte to one stopbit
-    config_usart.stopbits = USART_STOPBITS_1;
-    // Set baudrate to 230400
-    config_usart.baudrate = 230400;
-#ifdef __SAMD21J18A__
-    config_usart.mux_setting = EXT3_UART_SERCOM_MUX_SETTING;
-    config_usart.pinmux_pad0 = EXT3_UART_SERCOM_PINMUX_PAD0;
-    config_usart.pinmux_pad1 = EXT3_UART_SERCOM_PINMUX_PAD1;
-    config_usart.pinmux_pad2 = EXT3_UART_SERCOM_PINMUX_PAD2;
-    config_usart.pinmux_pad3 = EXT3_UART_SERCOM_PINMUX_PAD3;
-#endif
-#ifdef __SAMR21G18A__
-    config_usart.mux_setting = EXT1_UART_SERCOM_MUX_SETTING;
-    config_usart.pinmux_pad0 = EXT1_UART_SERCOM_PINMUX_PAD0;
-    config_usart.pinmux_pad1 = EXT1_UART_SERCOM_PINMUX_PAD1;
-    config_usart.pinmux_pad2 = EXT1_UART_SERCOM_PINMUX_PAD2;
-    config_usart.pinmux_pad3 = EXT1_UART_SERCOM_PINMUX_PAD3;
-#endif
-    switch (instance->bus_index)
-    {
-    case 0: status = usart_init(&(instance->usart_instance), SERCOM0, &config_usart); break;
-    case 1: status = usart_init(&(instance->usart_instance), SERCOM1, &config_usart); break;
-    case 2: status = usart_init(&(instance->usart_instance), SERCOM2, &config_usart); break;
-    case 3: status = usart_init(&(instance->usart_instance), SERCOM3, &config_usart); break;
-    case 4: status = usart_init(&(instance->usart_instance), SERCOM4, &config_usart); break;
-    case 5: status = usart_init(&(instance->usart_instance), SERCOM5, &config_usart); break;
-    }
-    usart_enable(&(instance->usart_instance));
-    return status;
-}
-
-/** \brief Implementation of SWI UART deinit.
- * \param[in] instance  instance
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-ATCA_STATUS swi_uart_deinit(ATCASWIMaster_t *instance)
-{
-    ATCA_STATUS status = ATCA_SUCCESS;
-
-    usart_reset(&(instance->usart_instance));
-    return status;
-}
-
-/** \brief implementation of SWI UART change baudrate.
- * \param[in] instance  instance
- * \param[in] baudrate (typically 230400 , 160000 or 115200)
- */
-void swi_uart_setbaud(ATCASWIMaster_t *instance, uint32_t baudrate)
-{
-    // Disable UART module
-    usart_disable(&(instance->usart_instance));
-    // Set baudrate for UART module
-    config_usart.baudrate    = baudrate;
-    switch (instance->bus_index)
-    {
-    case 0: usart_init(&(instance->usart_instance), SERCOM0, &config_usart); break;
-    case 1: usart_init(&(instance->usart_instance), SERCOM1, &config_usart); break;
-    case 2: usart_init(&(instance->usart_instance), SERCOM2, &config_usart); break;
-    case 3: usart_init(&(instance->usart_instance), SERCOM3, &config_usart); break;
-    case 4: usart_init(&(instance->usart_instance), SERCOM4, &config_usart); break;
-    case 5: usart_init(&(instance->usart_instance), SERCOM5, &config_usart); break;
-    }
-    usart_enable(&(instance->usart_instance));
-}
-
-
-/** \brief implementation of SWI UART change mode.
- * \param[in] instance  instance
- * \param[in] mode (TRANSMIT_MODE or RECEIVE_MODE)
- */
-void swi_uart_mode(ATCASWIMaster_t *instance, uint8_t mode)
-{
-    usart_disable(&(instance->usart_instance));
-    // Do nothing as the available time is not enough for setting the baudrate in ASF
-    usart_enable(&(instance->usart_instance));
-}
-
-/** \brief discover UART buses available for this hardware
- * this maintains a list of logical to physical bus mappings freeing the application
- * of the a-priori knowledge
- * \param[in] swi_uart_buses - an array of logical bus numbers
- * \param[in] max_buses - maximum number of buses the app wants to attempt to discover
- */
-void swi_uart_discover_buses(int swi_uart_buses[], int max_buses)
-{
-    /* if every SERCOM was a likely candidate bus, then would need to initialize the entire array to all SERCOM n numbers.
-     * As an optimization and making discovery safer, make assumptions about bus-num / SERCOM map based on SAMD21 Xplained Pro board
-     * If you were using a raw SAMD21 on your own board, you would supply your own bus numbers based on your particular hardware configuration.
-     */
-    swi_uart_buses[0] = 4;   // default samd21 for xplained dev board
-}
-
-
-/** \brief HAL implementation of SWI UART send byte over ASF.  This function send one byte over UART
- * \param[in] instance  instance
- * \param[in] data      number of byte to send
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-ATCA_STATUS swi_uart_send_byte(ATCASWIMaster_t *instance, uint8_t data)
-{
-    int8_t retries = 90;
-    uint16_t bitdata = (uint16_t)data;
-
-    // Send one byte over UART module
-#ifdef DEBUG_PIN
-    port_pin_toggle_output_level(DEBUG_PIN_1);
-#endif
-
-    while ((retries > 0) && (usart_write_wait(&(instance->usart_instance), bitdata) != STATUS_OK))
-    {
-        retries--;
-    }
-
-#ifdef DEBUG_PIN
-    port_pin_toggle_output_level(DEBUG_PIN_1);
-#endif
-
-    if (retries <= 0x00)
-    {
-        return ATCA_TIMEOUT;
-    }
-    else
-    {
-        return ATCA_SUCCESS;
-    }
-}
-
-/** \brief HAL implementation of SWI UART receive bytes over ASF.  This function receive one byte over UART
- * \param[in]    instance instance
- * \param[out] data     pointer to space to receive the data
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-ATCA_STATUS swi_uart_receive_byte(ATCASWIMaster_t *instance, uint8_t *data)
-{
-    uint8_t retries = 100; // This retry is used to compensate the baudrate that do not match when receiving response
-    uint16_t bitdata = 0x00;
-
-#ifdef DEBUG_PIN
-    port_pin_toggle_output_level(DEBUG_PIN_2);
-#endif
-    // Receive one byte over UART module
-    while ((retries > 0) && (usart_read_wait(&(instance->usart_instance), &bitdata) != STATUS_OK))
-    {
-        retries--;
-    }
-
-#ifdef DEBUG_PIN
-    port_pin_toggle_output_level(DEBUG_PIN_2);
-#endif
-
-    *data = bitdata;
-    if (retries <= 0x00)
-    {
-        return ATCA_TIMEOUT;
-    }
-    else
-    {
-        return ATCA_SUCCESS;
-    }
-}
-
-/** @} */
diff --git a/lib/hal/swi_uart_samd21_asf.h b/lib/hal/swi_uart_samd21_asf.h
deleted file mode 100644
index eb518a3430fd..000000000000
--- a/lib/hal/swi_uart_samd21_asf.h
+++ /dev/null
@@ -1,84 +0,0 @@
-/**
- * \file
- * \brief ATXMEGA's ATCA Hardware abstraction layer for SWI interface over UART drivers.
- *
- * Prerequisite: add UART Polled support to application in Atmel Studio
- *
- * \copyright (c) 2017 Microchip Technology Inc. and its subsidiaries.
- *            You may use this software and any derivatives exclusively with
- *            Microchip products.
- *
- * \page License
- *
- * (c) 2017 Microchip Technology Inc. and its subsidiaries. You may use this
- * software and any derivatives exclusively with Microchip products.
- *
- * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
- * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
- * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
- * PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
- * WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
- *
- * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
- * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
- * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
- * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
- * FULLEST EXTENT ALLOWED BY LAW, MICROCHIPS TOTAL LIABILITY ON ALL CLAIMS IN
- * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
- * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
- *
- * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
- * TERMS.
- */
-
-#ifndef SWI_UART_SAMD21_ASF_H_
-#define SWI_UART_SAMD21_ASF_H_
-
-#include <asf.h>
-#include "cryptoauthlib.h"
-
-/** \defgroup hal_ Hardware abstraction layer (hal_)
- *
- * \brief
- * These methods define the hardware abstraction layer for communicating with a CryptoAuth device
- *
-   @{ */
-
-
-/** \brief
-    - this HAL implementation assumes you've included the ASF SERCOM UART libraries in your project, otherwise,
-    the HAL layer will not compile because the ASF UART drivers are a dependency *
- */
-
-#define MAX_SWI_BUSES    6  // SAMD21 has up to 6 SERCOMS that can be configured as UART
-
-#define RECEIVE_MODE    0   // UART Receive mode, RX enabled
-#define TRANSMIT_MODE   1   // UART Transmit mode, RX disabled
-#define RX_DELAY        { volatile uint8_t delay = 90; while (delay--) { __asm__ (""); } }
-#define TX_DELAY        90
-
-#define DEBUG_PIN_1     EXT2_PIN_5
-#define DEBUG_PIN_2     EXT2_PIN_6
-/** \brief this is the hal_data for ATCA HAL for ASF SERCOM
- */
-typedef struct atcaSWImaster
-{
-    // struct usart_module for Atmel SWI interface
-    struct usart_module usart_instance;
-    // for conveniences during interface release phase
-    int bus_index;
-} ATCASWIMaster_t;
-
-
-ATCA_STATUS swi_uart_init(ATCASWIMaster_t *instance);
-ATCA_STATUS swi_uart_deinit(ATCASWIMaster_t *instance);
-void swi_uart_setbaud(ATCASWIMaster_t *instance, uint32_t baudrate);
-void swi_uart_mode(ATCASWIMaster_t *instance, uint8_t mode);
-void swi_uart_discover_buses(int swi_uart_buses[], int max_buses);
-
-ATCA_STATUS swi_uart_send_byte(ATCASWIMaster_t *instance, uint8_t data);
-ATCA_STATUS swi_uart_receive_byte(ATCASWIMaster_t *instance, uint8_t *data);
-
-/** @} */
-
-#endif // SWI_UART_ASF_H
diff --git a/lib/hal/swi_uart_samd21_start.c b/lib/hal/swi_uart_samd21_start.c
deleted file mode 100644
index 0bf4650afaa0..000000000000
--- a/lib/hal/swi_uart_samd21_start.c
+++ /dev/null
@@ -1,208 +0,0 @@
-/**
- * \file
- *
- * \brief  Atmel Crypto Auth hardware interface object
- *
- * \copyright (c) 2017 Microchip Technology Inc. and its subsidiaries.
- *            You may use this software and any derivatives exclusively with
- *            Microchip products.
- *
- * \page License
- *
- * (c) 2017 Microchip Technology Inc. and its subsidiaries. You may use this
- * software and any derivatives exclusively with Microchip products.
- *
- * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
- * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
- * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
- * PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
- * WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
- *
- * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
- * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
- * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
- * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
- * FULLEST EXTENT ALLOWED BY LAW, MICROCHIPS TOTAL LIABILITY ON ALL CLAIMS IN
- * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
- * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
- *
- * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
- * TERMS.
- */
-
-#include <stdlib.h>
-#include <stdio.h>
-#include "swi_uart_samd21_start.h"
-#include "basic/atca_helpers.h"
-
-/** \defgroup hal_ Hardware abstraction layer (hal_)
- *
- * \brief
- * These methods define the hardware abstraction layer for communicating with a CryptoAuth device
- *
-   @{ */
-
-/** \brief
-   - this HAL implementation assumes you've included the START SERCOM UART libraries in your project, otherwise,
-   the HAL layer will not compile because the START UART drivers are a dependency *
- */
-
-/** \brief HAL implementation of SWI UART init.
- * \param[in] instance  instance
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-ATCA_STATUS swi_uart_init(ATCASWIMaster_t *instance)
-{
-    ATCA_STATUS status = ATCA_SUCCESS;
-
-    instance->USART_SWI = USART_1;
-
-    status |= usart_sync_set_mode(&(instance->USART_SWI), USART_MODE_ASYNCHRONOUS);
-    // Set data size to 7
-    status |= usart_sync_set_character_size(&(instance->USART_SWI), USART_CHARACTER_SIZE_7BITS);
-    // Set parity to no parity
-    status |= usart_sync_set_parity(&(instance->USART_SWI), USART_PARITY_NONE);
-    // Set data byte to one stopbit
-    status |= usart_sync_set_stopbits(&(instance->USART_SWI), USART_STOP_BITS_ONE);
-    // Set baudrate to 230400
-    status |= usart_sync_set_baud_rate(&(instance->USART_SWI), 230400);
-    // Enable SWI UART
-    status |= usart_sync_enable(&(instance->USART_SWI));
-    return status;
-}
-
-/** \brief HAL implementation of SWI UART deinit.
- * \param[in] instance  instance
- * \return ATCA_SUCCESS
- */
-ATCA_STATUS swi_uart_deinit(ATCASWIMaster_t *instance)
-{
-    ATCA_STATUS status = ATCA_SUCCESS;
-
-    usart_sync_disable(&(instance->USART_SWI));
-
-    return status;
-}
-
-/** \brief HAL implementation of SWI UART change baudrate.
- * \param[in] instance  instance
- * \param[in] baudrate (typically 230400 or 115200)
- */
-void swi_uart_setbaud(ATCASWIMaster_t *instance, uint32_t baudrate)
-{
-    // Set baudrate for UART module
-    delay_us(50);
-    usart_sync_set_baud_rate(&(instance->USART_SWI), baudrate);
-
-}
-
-
-/** \brief HAL implementation of SWI UART change mode.
- * \param[in] instance  instance
- * \param[in] mode (TRANSMIT_MODE or RECEIVE_MODE)
- */
-void swi_uart_mode(ATCASWIMaster_t *instance, uint8_t mode)
-{
-
-    usart_sync_disable(&(instance->USART_SWI));
-
-    if (mode == TRANSMIT_MODE)
-    {
-        // Set baudrate to 230400
-        usart_sync_set_baud_rate(&(instance->USART_SWI), 230400);
-        // Disable Receiver
-        hri_sercomusart_clear_CTRLB_RXEN_bit(&(instance->USART_SWI.device.hw));
-        hri_sercomusart_set_CTRLB_TXEN_bit(&(instance->USART_SWI.device.hw));
-    }
-    else if (mode == RECEIVE_MODE)
-    {
-        // Set baudrate to 160000
-        usart_sync_set_baud_rate(&(instance->USART_SWI), 160000);
-        // Enable Receiver
-        hri_sercomusart_clear_CTRLB_TXEN_bit(&(instance->USART_SWI.device.hw));
-        hri_sercomusart_set_CTRLB_RXEN_bit(&(instance->USART_SWI.device.hw));
-    }
-    usart_sync_enable(&(instance->USART_SWI));
-    instance->bus_index &= 0x07;
-}
-
-/** \brief discover UART buses available for this hardware
- * this maintains a list of logical to physical bus mappings freeing the application
- * of the a-priori knowledge
- * \param[in] swi_uart_buses - an array of logical bus numbers
- * \param[in] max_buses - maximum number of buses the app wants to attempt to discover
- */
-void swi_uart_discover_buses(int swi_uart_buses[], int max_buses)
-{
-    /* if every SERCOM was a likely candidate bus, then would need to initialize the entire array to all SERCOM n numbers.
-     * As an optimization and making discovery safer, make assumptions about bus-num / SERCOM map based on SAMD21 Xplained Pro board
-     * If you were using a raw SAMD21 on your own board, you would supply your own bus numbers based on your particular hardware configuration.
-     */
-    swi_uart_buses[0] = 4;   // default samd21 for xplained dev board
-}
-
-/** \brief HAL implementation of SWI UART send byte over ASF.  This function send one byte over UART
- * \param[in] instance  instance
- * \param[in] data      number of byte to send
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-ATCA_STATUS swi_uart_send_byte(ATCASWIMaster_t *instance, uint8_t data)
-{
-    uint8_t retries = 2;
-    int32_t byte_sent = 0;
-
-#ifdef DEBUG_PIN
-    gpio_toggle_pin_level(PA20);
-#endif
-    // Send one byte over UART module
-    while ((retries > 0) && (byte_sent < 1))
-    {
-        byte_sent = io_write(&(instance->USART_SWI.io), &data, 1);
-        retries--;
-    }
-#ifdef DEBUG_PIN
-    gpio_toggle_pin_level(PA20);
-#endif
-    if (byte_sent <= 0)
-    {
-        return ATCA_TIMEOUT;
-    }
-    else
-    {
-        return ATCA_SUCCESS;
-    }
-}
-
-/** \brief HAL implementation of SWI UART receive bytes over ASF.  This function receive one byte over UART
- * \param[in]    instance instance
- * \param[out] data     pointer to space to receive the data
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-ATCA_STATUS swi_uart_receive_byte(ATCASWIMaster_t *instance, uint8_t *data)
-{
-    int32_t byte_sent = 0;
-    uint8_t retries = 2;
-
-#ifdef DEBUG_PIN
-    gpio_toggle_pin_level(PA21);
-#endif
-    // Receive one byte over UART module
-    while ((retries > 0) && (byte_sent < 1))
-    {
-        byte_sent = io_read(&(instance->USART_SWI.io), data, 1);
-        retries--;
-    }
-#ifdef DEBUG_PIN
-    gpio_toggle_pin_level(PA21);
-#endif
-    if (byte_sent <= 0)
-    {
-        return ATCA_TIMEOUT;
-    }
-    else
-    {
-        return ATCA_SUCCESS;
-    }
-}
-
-/** @} */
diff --git a/lib/hal/swi_uart_samd21_start.h b/lib/hal/swi_uart_samd21_start.h
deleted file mode 100644
index e039228ef7c3..000000000000
--- a/lib/hal/swi_uart_samd21_start.h
+++ /dev/null
@@ -1,80 +0,0 @@
-/**
- * \file
- *
- * \brief  Atmel Crypto Auth hardware interface object
- *
- * \copyright (c) 2017 Microchip Technology Inc. and its subsidiaries.
- *            You may use this software and any derivatives exclusively with
- *            Microchip products.
- *
- * \page License
- *
- * (c) 2017 Microchip Technology Inc. and its subsidiaries. You may use this
- * software and any derivatives exclusively with Microchip products.
- *
- * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
- * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
- * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
- * PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
- * WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
- *
- * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
- * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
- * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
- * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
- * FULLEST EXTENT ALLOWED BY LAW, MICROCHIPS TOTAL LIABILITY ON ALL CLAIMS IN
- * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
- * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
- *
- * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
- * TERMS.
- */
-
-#ifndef SWI_UART_SAMD21_START_H_
-#define SWI_UART_SAMD21_START_H_
-
-#include <stdlib.h>
-#include <hri_sercom_v200.h>
-#include "atmel_start.h"
-#include "cryptoauthlib.h"
-
-/** \defgroup hal_ Hardware abstraction layer (hal_)
- *
- * \brief
- * These methods define the hardware abstraction layer for communicating with a CryptoAuth device
- *
-   @{ */
-
-
-/** \brief
-    - this HAL implementation assumes you've included the ASF SERCOM UART libraries in your project, otherwise,
-    the HAL layer will not compile because the ASF UART drivers are a dependency *
- */
-
-#define MAX_SWI_BUSES    6  // SAMD21 has up to 6 SERCOMS that can be configured as UART
-
-#define RECEIVE_MODE    0   // UART Receive mode, RX enabled
-#define TRANSMIT_MODE   1   // UART Transmit mode, RX disabled
-#define RX_DELAY        10
-#define TX_DELAY        93
-/** \brief this is the hal_data for ATCA HAL for ASF SERCOM
- */
-typedef struct atcaSWImaster
-{
-    // struct usart_module for Atmel SWI interface
-    struct usart_sync_descriptor USART_SWI;
-    // for conveniences during interface release phase
-    int bus_index;
-} ATCASWIMaster_t;
-
-ATCA_STATUS swi_uart_init(ATCASWIMaster_t *instance);
-ATCA_STATUS swi_uart_deinit(ATCASWIMaster_t *instance);
-void swi_uart_setbaud(ATCASWIMaster_t *instance, uint32_t baudrate);
-void swi_uart_mode(ATCASWIMaster_t *instance, uint8_t mode);
-void swi_uart_discover_buses(int swi_uart_buses[], int max_buses);
-
-ATCA_STATUS swi_uart_send_byte(ATCASWIMaster_t *instance, uint8_t data);
-ATCA_STATUS swi_uart_receive_byte(ATCASWIMaster_t *instance, uint8_t *data);
-/** @} */
-
-#endif // SWI_UART_ASF_H
diff --git a/lib/hal/swi_uart_xmega_a3bu_asf.c b/lib/hal/swi_uart_xmega_a3bu_asf.c
deleted file mode 100644
index 26785cd795ee..000000000000
--- a/lib/hal/swi_uart_xmega_a3bu_asf.c
+++ /dev/null
@@ -1,258 +0,0 @@
-/**
- * \file
- * \brief ATXMEGA's ATCA Hardware abstraction layer for SWI interface over XMEGA UART drivers.
- *
- * Prerequisite: add UART Polled support to application in Atmel Studio
- *
- * \copyright (c) 2017 Microchip Technology Inc. and its subsidiaries.
- *            You may use this software and any derivatives exclusively with
- *            Microchip products.
- *
- * \page License
- *
- * (c) 2017 Microchip Technology Inc. and its subsidiaries. You may use this
- * software and any derivatives exclusively with Microchip products.
- *
- * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
- * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
- * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
- * PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
- * WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
- *
- * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
- * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
- * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
- * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
- * FULLEST EXTENT ALLOWED BY LAW, MICROCHIPS TOTAL LIABILITY ON ALL CLAIMS IN
- * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
- * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
- *
- * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
- * TERMS.
- */
-
-#include <stdlib.h>
-#include <stdio.h>
-#include "swi_uart_xmega_a3bu_asf.h"
-#include "basic/atca_helpers.h"
-
-#define DEBUG_PIN 1
-
-#ifdef DEBUG_PIN
-    #define DEBUG_PIN_1 IOPORT_CREATE_PIN(PORTB, 0)
-    #define DEBUG_PIN_2 IOPORT_CREATE_PIN(PORTB, 1)
-#endif
-/** \defgroup hal_ Hardware abstraction layer (hal_)
- *
- * \brief
- * These methods define the hardware abstraction layer for communicating with a CryptoAuth device
- *
-   @{ */
-
-/** \brief usart configuration struct */
-static usart_serial_options_t config_usart;
-/** \brief sysclk_get_per_hz value  */
-static uint32_t u32sysclk;
-
-
-/** \brief
-    - this HAL implementation assumes you've included the ASF SERCOM UART libraries in your project, otherwise,
-    the HAL layer will not compile because the ASF UART drivers are a dependency *
- */
-
-/** \brief Implementation of SWI UART init.
- * \param[in] instance  instance
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-ATCA_STATUS swi_uart_init(ATCASWIMaster_t *instance)
-{
-#ifdef DEBUG_PIN
-    ioport_init();
-    ioport_set_pin_dir(DEBUG_PIN_1, IOPORT_DIR_OUTPUT);
-    ioport_set_pin_dir(DEBUG_PIN_2, IOPORT_DIR_OUTPUT);
-    gpio_set_pin_high(DEBUG_PIN_1);
-    gpio_set_pin_high(DEBUG_PIN_2);
-#endif
-    ATCA_STATUS status = ATCA_SUCCESS;
-
-    //Save sysclk_get_per_hz value
-    u32sysclk = sysclk_get_per_hz();
-    // Set data size to 7
-    config_usart.charlength = USART_CHSIZE_7BIT_gc;
-    // Set parity to no parity
-    config_usart.paritytype = USART_PMODE_DISABLED_gc;
-    // Set data byte to one stopbit
-    config_usart.stopbits = false;
-    // Set baudrate to 230400
-    config_usart.baudrate = 230400;
-
-    switch (instance->bus_index)
-    {
-    case 0: instance->usart_instance = &USARTC0; break;
-    case 1: instance->usart_instance = &USARTC1; break;
-    case 2: instance->usart_instance = &USARTD0; break;
-    case 3: instance->usart_instance = &USARTD1; break;
-    case 4: instance->usart_instance = &USARTE0; break;
-    case 5: instance->usart_instance = &USARTF0; break;
-    }
-    status = usart_serial_init(instance->usart_instance, &config_usart);
-    return status;
-}
-
-/** \brief Implementation of SWI UART deinit.
- * \param[in] instance  instance
- * \return ATCA_SUCCESS
- */
-ATCA_STATUS swi_uart_deinit(ATCASWIMaster_t *instance)
-{
-    ATCA_STATUS status = ATCA_SUCCESS;
-
-    instance->usart_instance = NULL;
-    return status;
-}
-
-/** \brief implementation of SWI UART change baudrate.
- * \param[in] instance  instance
- * \param[in] baudrate  (typically 230400 , 160000 or 115200)
- */
-void swi_uart_setbaud(ATCASWIMaster_t *instance, uint32_t baudrate)
-{
-    // Set baudrate for UART module
-    usart_set_baudrate(instance->usart_instance, baudrate, u32sysclk);
-}
-
-
-/** \brief implementation of SWI UART change mode.
- * \param[in] instance  instance
- * \param[in] mode      (TRANSMIT_MODE or RECEIVE_MODE)
- */
-void swi_uart_mode(ATCASWIMaster_t *instance, uint8_t mode)
-{
-    switch (mode)
-    {
-    case TRANSMIT_MODE:
-        usart_set_baudrate(instance->usart_instance, 230400, u32sysclk);
-        break;
-    case RECEIVE_MODE:
-        //Reset UART RX buffer.
-        usart_rx_disable(instance->usart_instance);
-        usart_rx_enable(instance->usart_instance);
-        break;
-    default:
-        break;
-    }
-
-}
-
-/** \brief discover UART buses available for this hardware
- * this maintains a list of logical to physical bus mappings freeing the application
- * of the a-priori knowledge
- * \param[in] swi_uart_buses - an array of logical bus numbers
- * \param[in] max_buses - maximum number of buses the app wants to attempt to discover
- */
-void swi_uart_discover_buses(int swi_uart_buses[], int max_buses)
-{
-    /* if every PORT was a likely candidate bus, then would need to initialize the entire array to all PORT n numbers.
-     * As an optimization and making discovery safer, make assumptions about bus-num / PORT map based on XMEGA-A3BU Xplained board
-     * If you were using a raw XMEGA on your own board, you would supply your own bus numbers based on your particular hardware configuration.
-     */
-    swi_uart_buses[0] = 4;   // default xmega-a3bu for xplained dev board
-}
-
-/** \brief HAL implementation of SWI UART send byte over ASF.  This function send one byte over UART
- * \param[in] instance  instance
- * \param[in] data      byte to send
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-ATCA_STATUS swi_uart_send_byte(ATCASWIMaster_t *instance, uint8_t data)
-{
-    int8_t timeout = 0x7F;
-    bool data_reg_empty = false;
-    ATCA_STATUS status = ATCA_COMM_FAIL;
-
-    // Send one byte over UART module
-#ifdef DEBUG_PIN
-    gpio_toggle_pin(DEBUG_PIN_1);
-#endif
-    // Send one byte over UART module
-    timeout = 0x7F;
-    while ((timeout > 0) && (data_reg_empty == false))
-    {
-        data_reg_empty = usart_data_register_is_empty(instance->usart_instance);
-        timeout--;
-    }
-    if (data_reg_empty)
-    {
-        usart_put(instance->usart_instance, data);
-        while (!usart_tx_is_complete(instance->usart_instance))
-        {
-            ;
-        }
-        usart_clear_tx_complete(instance->usart_instance);
-        status = ATCA_SUCCESS;
-    }
-#ifdef DEBUG_PIN
-    gpio_toggle_pin(DEBUG_PIN_1);
-#endif
-    if (timeout > 0)
-    {
-        return status;
-    }
-    else
-    {
-        return ATCA_TIMEOUT;
-    }
-}
-
-/** \brief HAL implementation of SWI UART receive bytes over ASF.  This function receive one byte over UART
- * \param[in]    instance  instance
- * \param[out]   data      pointer to space to receive the data
- * \return ATCA_SUCCESS on success, otherwise an error code.
- */
-ATCA_STATUS swi_uart_receive_byte(ATCASWIMaster_t *instance, uint8_t *data)
-{
-    int8_t timeout, retries = 0x2; // This retry is used to compensate the baudrate that do not match when receiving response
-
-    *data = 0xFF;
-    bool rx_complete = false;
-    ATCA_STATUS status = ATCA_COMM_FAIL;
-#ifdef DEBUG_PIN
-    gpio_toggle_pin(DEBUG_PIN_2);
-#endif
-    // Receive one byte over UART module
-    while ((retries > 0) && (status != ATCA_SUCCESS))
-    {
-        timeout = 0x7F; retries--;
-        while ((timeout > 0) && (rx_complete == false))
-        {
-            rx_complete = usart_rx_is_complete(instance->usart_instance);
-            timeout--;
-        }
-
-        if (rx_complete)
-        {
-            *data = usart_get(instance->usart_instance);
-            if ((*data >= 0x70) && (*data <= 0x7F))
-            {
-                status = ATCA_SUCCESS;
-            }
-            else
-            {
-                status = ATCA_COMM_FAIL;
-            }
-        }
-    }
-#ifdef DEBUG_PIN
-    gpio_toggle_pin(DEBUG_PIN_2);
-#endif
-    if (timeout > 0)
-    {
-        return status;
-    }
-    else
-    {
-        return ATCA_TIMEOUT;
-    }
-}
-
-/** @} */
diff --git a/lib/hal/swi_uart_xmega_a3bu_asf.h b/lib/hal/swi_uart_xmega_a3bu_asf.h
deleted file mode 100644
index e9bfffc58fc6..000000000000
--- a/lib/hal/swi_uart_xmega_a3bu_asf.h
+++ /dev/null
@@ -1,83 +0,0 @@
-/**
- * \file
- * \brief ATXMEGA's ATCA Hardware abstraction layer for SWI interface over XMEGA UART drivers.
- *
- * Prerequisite: add UART Polled support to application in Atmel Studio
- *
- * \copyright (c) 2017 Microchip Technology Inc. and its subsidiaries.
- *            You may use this software and any derivatives exclusively with
- *            Microchip products.
- *
- * \page License
- *
- * (c) 2017 Microchip Technology Inc. and its subsidiaries. You may use this
- * software and any derivatives exclusively with Microchip products.
- *
- * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
- * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
- * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
- * PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
- * WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
- *
- * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
- * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
- * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
- * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
- * FULLEST EXTENT ALLOWED BY LAW, MICROCHIPS TOTAL LIABILITY ON ALL CLAIMS IN
- * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
- * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
- *
- * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
- * TERMS.
- */
-
-#ifndef SWI_UART_XMEGA_A3BU_ASF_H_
-#define SWI_UART_XMEGA_A3BU_ASF_H_
-
-#include <asf.h>
-#include "cryptoauthlib.h"
-#include "serial.h"
-
-/** \defgroup hal_ Hardware abstraction layer (hal_)
- *
- * \brief
- * These methods define the hardware abstraction layer for communicating with a CryptoAuth device
- *
-   @{ */
-
-
-/** \brief
-    - this HAL implementation assumes you've included the ASF UART libraries in your project, otherwise,
-    the HAL layer will not compile because the ASF UART drivers are a dependency *
- */
-
-#define MAX_SWI_BUSES    6  // XMEGA A3BU has up to 6 ports
-
-#define RECEIVE_MODE    0   // UART Receive mode, RX enabled
-#define TRANSMIT_MODE   1   // UART Transmit mode, RX disabled
-#define RX_DELAY        10  // Delay before responses come
-#define TX_DELAY        90  // Delay before new flag is sent
-
-/** \brief this is the hal_data for ATCA HAL for SWI UART
- */
-typedef struct atcaSWImaster
-{
-    // struct usart_module for Atmel SWI interface
-    usart_if usart_instance;
-    // for conveniences during interface release phase
-    int bus_index;
-} ATCASWIMaster_t;
-
-
-ATCA_STATUS swi_uart_init(ATCASWIMaster_t *instance);
-ATCA_STATUS swi_uart_deinit(ATCASWIMaster_t *instance);
-void swi_uart_setbaud(ATCASWIMaster_t *instance, uint32_t baudrate);
-void swi_uart_mode(ATCASWIMaster_t *instance, uint8_t mode);
-void swi_uart_discover_buses(int swi_uart_buses[], int max_buses);
-
-ATCA_STATUS swi_uart_send_byte(ATCASWIMaster_t *instance, uint8_t data);
-ATCA_STATUS swi_uart_receive_byte(ATCASWIMaster_t *instance, uint8_t *data);
-
-/** @} */
-
-#endif // SWI_UART_XMEGA_A3BU_ASF_H
